---
author: aitx
title: 大厂算法刷题
time: 2025-12-16 周二
tags:
  - 算法
  - 编程
---
# 大厂算法刷题

>参考链接: <https://github.com/algorithmzuo/coding-for-great-offer>

## 绳子压中几个点

```java
package com.aitx.study.base;  
  
import java.util.Arrays;  
  
/**  
 * 给定一个有序数组arr，代表坐落在X轴上的点  
 * 给定一个正数K，代表绳子的长度  
 * 返回绳子最多压中几个点？  
 * 即使绳子边缘处盖住点也算盖住  
 * <p>  
 * 思考:  
 * 1) 贪心 + 二分  
 * 最多压几中几个点是典型的贪心,我们就假设正数k是以某个点结尾,  
 * 求出[end-K,end]区间内有几个符合的点,求的过程分为 遍历 或者 二分查找 这2个方法  
 * <p>  
 * 2) 滑动窗口  
 * 有left,right指针,如果arr[right]- arr[left]的值 <= K,就计数1 直到不满足  
 * 这里left是当成K的开头  
 *  
 */public class StudyClass {  
  
  
    /**  
     * 解法一: 贪心 + 有序数组的二分法  
     *  
     * @param arr  
     * @param K  
     * @return  
     */    public static int cordCoverMaxPoint(int[] arr, int K) {  
  
        if (arr == null || arr.length == 0) {  
            return 0;  
        }  
        if (K <= 0) {  
            return 0;  
        }  
        int result = 0;  
  
        int N = arr.length;  
  
        for (int i = 0; i < N; i++) {  
            // 假设以arr[i]为结尾 计算起始范围  
            int end = arr[i];  
            int start = end - K;  
            // 相当于求 子数组 有几个数>=start, 看到有序 想到二分法  
            int nearMostLeftIndex = nearMostLeftIndex(arr, i, start);  
            result = Math.max(result, i - nearMostLeftIndex + 1);  
        }  
  
        return result;  
    }  
  
    public static int cordCoverMaxPoint2(int[] arr, int K) {  
        if (arr == null || arr.length == 0) {  
            return 0;  
        }  
  
        if (K <= 0) {  
            return 0;  
        }  
  
        int result = 0;  
  
        int N = arr.length;  
  
        int left = 0;  
        int right = 0;  
        while (left < N) {  
  
            while (right < N && arr[right] - arr[left] <= K) {  
                right++;  
            }  
            // 退出循环, right >=N || arr[right] - arr[left] > K  
            result = Math.max(result, right - left);  
            left++;  
        }  
  
        return result;  
  
    }  
  
    /**  
     * 求[0,R]数组区间 >= target 最左边的索引  
     *  
     * @param arr  
     * @param R  
     * @param target  
     * @return  
     */    private static int nearMostLeftIndex(int[] arr, int R, int target) {  
        if (arr == null || arr.length == 0) {  
            return 0;  
        }  
  
        int N = arr.length;  
  
        // R位置的值 肯定大于 起始点的值target  
        int nearMostLeftIndex = R;  
  
        int l = 0;  
        int r = R;  
  
        while (l <= r) {  
            int mid = l + ((r - l) >> 1);  
            if (arr[mid] >= target) {  
                nearMostLeftIndex = mid;  
                r = mid - 1;  
            } else {  
                l = mid + 1;  
            }  
        }  
  
        return nearMostLeftIndex;  
    }  
  
  
    // ------------------------TEST----------------------  
    private static int[] getRandomArray(int maxLength, int maxValue) {  
  
        // [0,maxLength]  
        int length = (int) (Math.random() * (maxLength + 1));  
  
        int[] arr = new int[length];  
  
        for (int i = 0; i < length; i++) {  
            arr[i] = getRandomPositiveValue(maxValue);  
        }  
  
        return arr;  
    }  
  
    private static int[] getRandomSeqArray(int maxLength, int maxValue) {  
        int[] randomArray = getRandomArray(maxLength, maxValue);  
        Arrays.sort(randomArray);  
        return randomArray;  
    }  
  
    private static int getRandomValue(int maxValue) {  
        // [0,maxValue] - [0,maxValue] -> [-maxValue,maxValue]  
        return ((int) (Math.random() * (maxValue + 1))) - ((int) (Math.random() * (maxValue + 1)));  
    }  
  
    private static int getRandomPositiveValue(int maxValue) {  
        // [0,maxValue-1] +1 -> [1,maxValue]  
        return ((int) (Math.random() * (maxValue))) + 1;  
    }  
  
  
    /**  
     * 解法一的暴力求解: 贪心 + 暴力遍历  
     *  
     * @param arr  
     * @param K  
     * @return  
     */    private static int right(int[] arr, int K) {  
        if (arr == null || arr.length == 0) {  
            return 0;  
        }  
        if (K <= 0) {  
            return 0;  
        }  
        int result = 0;  
  
        int N = arr.length;  
  
        for (int i = 0; i < N; i++) {  
  
            int end = arr[i];  
            int start = end - K;  
  
            int count = 0;  
            for (int j = 0; j <= i; j++) {  
                if (arr[j] >= start) {  
                    count += 1;  
                }  
            }  
            result = Math.max(result, count);  
  
        }  
  
        return result;  
    }  
  
    public static void main(String[] args) {  
  
        int times = 10000;  
        int maxLength = 10;  
        int maxValue = 100;  
  
        for (int i = 0; i < times; i++) {  
            int[] array = getRandomSeqArray(maxLength, maxValue);  
            int K = getRandomPositiveValue(maxValue);  
            if (cordCoverMaxPoint(array, K) != right(array, K) || right(array, K) != cordCoverMaxPoint2(array, K)) {  
                System.out.println("有问题");  
                break;  
            }  
        }  
    }  
  
  
}
```


## 求目录下的文件数量

```java
package com.aitx.study.base;  
  
  
import java.io.File;  
import java.util.Stack;  
  
/**  
 * 给定一个文件目录的路径，  
 * 写一个函数统计这个目录下所有的文件数量并返回  
 * 隐藏文件也算，但是文件夹不算  
 * <p>  
 * 思考:  
 * 求目录下所有的文件个数,可以考虑用容器接收来遍历,  
 * 可以考虑 按层遍历 用队列 或 用栈  
 */  
public class CountFiles {  
  
  
    public static int countFiles(String path) {  
  
        if (path == null || path.isEmpty()) {  
            return 0;  
        }  
  
        File file = new File(path);  
  
        if (!file.exists()) {  
            return 0;  
        }  
        if (!file.isDirectory() && !file.isFile()) {  
            return 0;  
        }  
        // 走到这,代表是文件或目录  
  
        // 文件下没有文件,直接返回1  
        if (file.isFile()) {  
            return 1;  
        }  
  
        int result = 0;  
  
        // 走到这,代表是目录  
        Stack<File> stack = new Stack<>();  
        stack.push(file);  
        while (!stack.isEmpty()) {  
  
            File popFile = stack.pop();  
            File[] listFiles = popFile.listFiles();  
  
            if (listFiles != null) {  
                for (File listFile : listFiles) {  
                    if (listFile.isFile()) {  
                        result += 1;  
                        continue;  
                    }  
                    if (listFile.isDirectory()) {  
                        stack.push(listFile);  
                    }  
                }  
            }  
        }  
        // 退出循环时 stack.isEmpty()        
        return result;  
  
    }  
  
}
```

## 大于非负整数最近的2的n次方数


```java
package com.aitx.study.base;  
  
/**  
 * 给定一个非负整数num，  
 * 如何不用循环语句，  
 * 返回>=num，并且离num最近的，2的某次方  
 * <p>  
 * 思考: 2的某次方从 位运算 角度看就是只有某位是1,其他位是0  
 * 现在要求>=num,考虑将num - 1后的数 每位都变成1,最后+1就是 最近的2的某次方  
 * -1的原因是可能刚好num就是2的某次方  
 */  
public class Near2PowerN {  
  
  
    public static int near2PowerN(int num) {  
        if (num < 0) {  
            return -1;  
        }  
        num = num - 1;  
        num |= num >>> 1;  
        num |= num >> 2;  
        num |= num >> 4;  
        num |= num >> 8;  
        num |= num >> 16; // int 最大32位  
  
        // 假设num最开始是0 减1后位上全是1,则最后计算的num<0,所以有num < 0的判断  
        return num < 0 ? 1 : num + 1;  
  
    }  
  
  
}
```


## 字符最小移动步数

```java
package com.aitx.study.base;  
  
  
import java.util.Arrays;  
  
/**  
 * 一个数组中只有两种字符'G'和’B’，  
 * 可以让所有的G都放在左侧，所有的B都放在右侧  
 * 或者可以让所有的G都放在右侧，所有的B都放在左侧  
 * 但是只能在相邻字符之间进行交换操作，  
 * 返回至少需要交换几次  
 * <p>  
 * 思考:贪心  
 * 如果要最少,可以让最靠近的G移到0位置,第2靠近的移到1位置  
 */  
public class MinSwapStep {  
  
  
    public static int minSwapStep(int[] arr) {  
        if (arr == null || arr.length == 0) {  
            return 0;  
        }  
  
        int N = arr.length;  
  
  
        int putIndexG = 0;  
        int putIndexB = 0;  
  
        int stepG = 0;  
        int stepB = 0;  
  
        for (int i = 0; i < N; i++) {  
            if (arr[i] == 'G') {  
                // 从i位置到putIndex位置要交换多少步  
                stepG += i - putIndexG;  
                putIndexG++;  
            } else {  
                stepB += i - putIndexB;  
                // 为什么要搞2个步长,可能出现连续的G/B 移动,两个字符移动并不一致  
                putIndexB++;  
            }  
        }  
  
        return Math.min(stepG, stepB);  
  
    }  
  
}
```


## 最长的递增链长度

```java
package com.aitx.study.base;  
  
/**  
 * 给定一个二维数组matrix，  
 * 你可以从任何位置出发，走向上下左右四个方向  
 * 返回能走出来的最长的递增链长度  
 * <p>  
 * 思考:  
 * 从任何位置出发,肯定有遍历  
 * <p>  
 * 上下左右四个方向肯定都要走 -》 暴力递归  
 */  
public class LongestIncreasingPath {  
  
  
    /**  
     * 解法一: 暴务递归  
     *  
     * @param matrix  
     * @return  
     */    public static int longestIncreasingPath(int[][] matrix) {  
  
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {  
            return 0;  
        }  
  
        int rowNum = matrix.length;  
        int colNum = matrix[0].length;  
  
        int result = 0;  
  
        for (int i = 0; i < rowNum; i++) {  
            for (int j = 0; j < colNum; j++) {  
                result = Math.max(result, process(matrix, i, j));  
            }  
        }  
  
        return result;  
  
    }  
  
    /**  
     * matrix 从(i,j)位置走 最长递增链长度是多少,记得加上本步  
     *  
     * @param matrix  
     * @param i  
     * @param j  
     * @return  
     */    private static int process(int[][] matrix, int i, int j) {  
  
        // 左右上下剩下的步数是多少  
        int left = (j - 1) >= 0 && (matrix[i][j] < matrix[i][j - 1]) ? process(matrix, i, j - 1) : 0;  
        int right = (j + 1) < matrix[0].length && (matrix[i][j] < matrix[i][j + 1]) ? process(matrix, i, j + 1) : 0;  
        int up = (i - 1) >= 0 && (matrix[i][j] < matrix[i - 1][j]) ? process(matrix, i - 1, j) : 0;  
        int down = (i + 1) < matrix.length && (matrix[i][j] < matrix[i + 1][j]) ? process(matrix, i + 1, j) : 0;  
  
        // 最后加上当前位置的步数  
        return Math.max(Math.max(left, right), Math.max(up, down)) + 1;  
  
    }  
  
  
    /**  
     * 解法二: 暴力递归 到 傻缓存  
     *  
     * @param matrix  
     * @return  
     */    public static int longestIncreasingPath2(int[][] matrix) {  
  
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {  
            return 0;  
        }  
  
        int rowNum = matrix.length;  
        int colNum = matrix[0].length;  
  
        int result = 0;  
        // i [0,rowNum-1]  
        // j [0,colNUm-1]        int[][] dp = new int[rowNum][colNum];  
  
        for (int i = 0; i < rowNum; i++) {  
            for (int j = 0; j < colNum; j++) {  
                result = Math.max(result, process2(matrix, i, j, dp));  
            }  
        }  
  
        return result;  
  
    }  
  
  
    /**  
     * matrix 从(i,j)位置走 最长递增链长度是多少,记得加上本步  
     *  
     * @param matrix  
     * @param i  
     * @param j  
     * @param dp  
     * @return  
     */    private static int process2(int[][] matrix, int i, int j, int[][] dp) {  
  
        if (dp[i][j] != 0) {  
            return dp[i][j];  
        }  
  
        // 左右上下剩下的步数是多少  
        int left = (j - 1) >= 0 && (matrix[i][j] < matrix[i][j - 1]) ? process(matrix, i, j - 1) : 0;  
        int right = (j + 1) < matrix[0].length && (matrix[i][j] < matrix[i][j + 1]) ? process(matrix, i, j + 1) : 0;  
        int up = (i - 1) >= 0 && (matrix[i][j] < matrix[i - 1][j]) ? process(matrix, i - 1, j) : 0;  
        int down = (i + 1) < matrix.length && (matrix[i][j] < matrix[i + 1][j]) ? process(matrix, i + 1, j) : 0;  
  
        // 最后加上当前位置的步数  
        int res = Math.max(Math.max(left, right), Math.max(up, down)) + 1;  
  
        dp[i][j] = res;  
  
        return res;  
  
    }  
  
}
```



