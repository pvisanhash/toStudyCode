---
author: aitx
title: 大厂算法刷题
time: 2025-12-16 周二
tags:
  - 算法
  - 编程
---
# 大厂算法刷题

>参考链接: <https://github.com/algorithmzuo/coding-for-great-offer>

## 绳子压中几个点

```java
package com.aitx.study.base;  
  
import java.util.Arrays;  
  
/**  
 * 给定一个有序数组arr，代表坐落在X轴上的点  
 * 给定一个正数K，代表绳子的长度  
 * 返回绳子最多压中几个点？  
 * 即使绳子边缘处盖住点也算盖住  
 * <p>  
 * 思考:  
 * 1) 贪心 + 二分  
 * 最多压几中几个点是典型的贪心,我们就假设正数k是以某个点结尾,  
 * 求出[end-K,end]区间内有几个符合的点,求的过程分为 遍历 或者 二分查找 这2个方法  
 * <p>  
 * 2) 滑动窗口  
 * 有left,right指针,如果arr[right]- arr[left]的值 <= K,就计数1 直到不满足  
 * 这里left是当成K的开头  
 *  
 */public class StudyClass {  
  
  
    /**  
     * 解法一: 贪心 + 有序数组的二分法  
     *  
     * @param arr  
     * @param K  
     * @return  
     */    public static int cordCoverMaxPoint(int[] arr, int K) {  
  
        if (arr == null || arr.length == 0) {  
            return 0;  
        }  
        if (K <= 0) {  
            return 0;  
        }  
        int result = 0;  
  
        int N = arr.length;  
  
        for (int i = 0; i < N; i++) {  
            // 假设以arr[i]为结尾 计算起始范围  
            int end = arr[i];  
            int start = end - K;  
            // 相当于求 子数组 有几个数>=start, 看到有序 想到二分法  
            int nearMostLeftIndex = nearMostLeftIndex(arr, i, start);  
            result = Math.max(result, i - nearMostLeftIndex + 1);  
        }  
  
        return result;  
    }  
  
    public static int cordCoverMaxPoint2(int[] arr, int K) {  
        if (arr == null || arr.length == 0) {  
            return 0;  
        }  
  
        if (K <= 0) {  
            return 0;  
        }  
  
        int result = 0;  
  
        int N = arr.length;  
  
        int left = 0;  
        int right = 0;  
        while (left < N) {  
  
            while (right < N && arr[right] - arr[left] <= K) {  
                right++;  
            }  
            // 退出循环, right >=N || arr[right] - arr[left] > K  
            result = Math.max(result, right - left);  
            left++;  
        }  
  
        return result;  
  
    }  
  
    /**  
     * 求[0,R]数组区间 >= target 最左边的索引  
     *  
     * @param arr  
     * @param R  
     * @param target  
     * @return  
     */    private static int nearMostLeftIndex(int[] arr, int R, int target) {  
        if (arr == null || arr.length == 0) {  
            return 0;  
        }  
  
        int N = arr.length;  
  
        // R位置的值 肯定大于 起始点的值target  
        int nearMostLeftIndex = R;  
  
        int l = 0;  
        int r = R;  
  
        while (l <= r) {  
            int mid = l + ((r - l) >> 1);  
            if (arr[mid] >= target) {  
                nearMostLeftIndex = mid;  
                r = mid - 1;  
            } else {  
                l = mid + 1;  
            }  
        }  
  
        return nearMostLeftIndex;  
    }  
  
  
    // ------------------------TEST----------------------  
    private static int[] getRandomArray(int maxLength, int maxValue) {  
  
        // [0,maxLength]  
        int length = (int) (Math.random() * (maxLength + 1));  
  
        int[] arr = new int[length];  
  
        for (int i = 0; i < length; i++) {  
            arr[i] = getRandomPositiveValue(maxValue);  
        }  
  
        return arr;  
    }  
  
    private static int[] getRandomSeqArray(int maxLength, int maxValue) {  
        int[] randomArray = getRandomArray(maxLength, maxValue);  
        Arrays.sort(randomArray);  
        return randomArray;  
    }  
  
    private static int getRandomValue(int maxValue) {  
        // [0,maxValue] - [0,maxValue] -> [-maxValue,maxValue]  
        return ((int) (Math.random() * (maxValue + 1))) - ((int) (Math.random() * (maxValue + 1)));  
    }  
  
    private static int getRandomPositiveValue(int maxValue) {  
        // [0,maxValue-1] +1 -> [1,maxValue]  
        return ((int) (Math.random() * (maxValue))) + 1;  
    }  
  
  
    /**  
     * 解法一的暴力求解: 贪心 + 暴力遍历  
     *  
     * @param arr  
     * @param K  
     * @return  
     */    private static int right(int[] arr, int K) {  
        if (arr == null || arr.length == 0) {  
            return 0;  
        }  
        if (K <= 0) {  
            return 0;  
        }  
        int result = 0;  
  
        int N = arr.length;  
  
        for (int i = 0; i < N; i++) {  
  
            int end = arr[i];  
            int start = end - K;  
  
            int count = 0;  
            for (int j = 0; j <= i; j++) {  
                if (arr[j] >= start) {  
                    count += 1;  
                }  
            }  
            result = Math.max(result, count);  
  
        }  
  
        return result;  
    }  
  
    public static void main(String[] args) {  
  
        int times = 10000;  
        int maxLength = 10;  
        int maxValue = 100;  
  
        for (int i = 0; i < times; i++) {  
            int[] array = getRandomSeqArray(maxLength, maxValue);  
            int K = getRandomPositiveValue(maxValue);  
            if (cordCoverMaxPoint(array, K) != right(array, K) || right(array, K) != cordCoverMaxPoint2(array, K)) {  
                System.out.println("有问题");  
                break;  
            }  
        }  
    }  
  
  
}
```


## 求目录下的文件数量

```java
package com.aitx.study.base;  
  
  
import java.io.File;  
import java.util.Stack;  
  
/**  
 * 给定一个文件目录的路径，  
 * 写一个函数统计这个目录下所有的文件数量并返回  
 * 隐藏文件也算，但是文件夹不算  
 * <p>  
 * 思考:  
 * 求目录下所有的文件个数,可以考虑用容器接收来遍历,  
 * 可以考虑 按层遍历 用队列 或 用栈  
 */  
public class CountFiles {  
  
  
    public static int countFiles(String path) {  
  
        if (path == null || path.isEmpty()) {  
            return 0;  
        }  
  
        File file = new File(path);  
  
        if (!file.exists()) {  
            return 0;  
        }  
        if (!file.isDirectory() && !file.isFile()) {  
            return 0;  
        }  
        // 走到这,代表是文件或目录  
  
        // 文件下没有文件,直接返回1  
        if (file.isFile()) {  
            return 1;  
        }  
  
        int result = 0;  
  
        // 走到这,代表是目录  
        Stack<File> stack = new Stack<>();  
        stack.push(file);  
        while (!stack.isEmpty()) {  
  
            File popFile = stack.pop();  
            File[] listFiles = popFile.listFiles();  
  
            if (listFiles != null) {  
                for (File listFile : listFiles) {  
                    if (listFile.isFile()) {  
                        result += 1;  
                        continue;  
                    }  
                    if (listFile.isDirectory()) {  
                        stack.push(listFile);  
                    }  
                }  
            }  
        }  
        // 退出循环时 stack.isEmpty()        
        return result;  
  
    }  
  
}
```

## 大于非负整数最近的2的n次方数


```java
package com.aitx.study.base;  
  
/**  
 * 给定一个非负整数num，  
 * 如何不用循环语句，  
 * 返回>=num，并且离num最近的，2的某次方  
 * <p>  
 * 思考: 2的某次方从 位运算 角度看就是只有某位是1,其他位是0  
 * 现在要求>=num,考虑将num - 1后的数 每位都变成1,最后+1就是 最近的2的某次方  
 * -1的原因是可能刚好num就是2的某次方  
 */  
public class Near2PowerN {  
  
  
    public static int near2PowerN(int num) {  
        if (num < 0) {  
            return -1;  
        }  
        num = num - 1;  
        num |= num >>> 1;  
        num |= num >> 2;  
        num |= num >> 4;  
        num |= num >> 8;  
        num |= num >> 16; // int 最大32位  
  
        // 假设num最开始是0 减1后位上全是1,则最后计算的num<0,所以有num < 0的判断  
        return num < 0 ? 1 : num + 1;  
  
    }  
  
  
}
```

