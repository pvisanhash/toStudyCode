# 算法学习 Algorithm Study



## 稀疏数组 Sparse Array



稀疏数组 sparse array：当一个二维数组（矩阵）中大部分元素为0或为同一个值时，可以用稀疏数组来保存原数组信息



第一行记录：行数row，列数colum，有效值value个数N  
N行：有效值所在的行数，有效值所在的列数，有效值  
构成一个N+1行3列的压缩数组，即为稀疏数组




二维数组转稀疏数的思路：   
1. 遍历原始的二维数组，得到有效数据的个数sum
2. 根据sum就可以创建稀疏数组sparseArray int [sum+1] [3]
3. 将二维数组的有效数据存入到稀疏数组



稀疏数组转为原始的二维数组的思路：   
1. 先读取稀疏数组的第一行，根据第一行的行与列创建原始的二维数组originArr = int [row] [column]
2. 在读取稀疏数组后几行的数据，并赋给原始的二维数组即可



完成以下任务：   
- 二维数组转稀疏数组
- 稀疏数组转二维数组



```java
public class SparseArray {

    /**
     * 矩阵转稀疏数组
     */
    public int[][] originalArray2SparseArray(int[][] originalArray) {
        // 原始数组的行数
        int row = originalArray.length;
        // 原始数组的列数
        int column = originalArray[0].length;
        // 原始数组有效元素的个数
        int count = 0;
        for (int i = 0; i < originalArray.length; i++) {
            for (int j = 0; j < originalArray[i].length; j++) {
                // 这里记录非0元素的个数
                if (originalArray[i][j] != 0) {
                    count++;
                }
            }
        }

        // 定义稀疏数组
        int[][] sparseArray = new int[count + 1][3];

        // 初始化第一行的值
        sparseArray[0][0] = row;
        sparseArray[0][1] = column;
        sparseArray[0][2] = count;

        // 稀疏数组填充值
        int cnt = 0;
        for (int i = 0; i < originalArray.length; i++) {
            for (int j = 0; j < originalArray[i].length; j++) {
                if (originalArray[i][j] != 0) {
                    // 第几个有效元素
                    cnt++;
                    // 记录行号
                    sparseArray[cnt][0] = i;
                    // 记录列号
                    sparseArray[cnt][1] = j;
                    // 记录值
                    sparseArray[cnt][2] = originalArray[i][j];
                }
            }
        }

        return sparseArray;
    }

    /**
     * 稀疏数组转矩阵
     */
    public int[][] sparseArray2OriginalArray(int[][] sparseArray) {
        // 原始数组的行数
        int row = sparseArray[0][0];
        // 原始数组的列数
        int column = sparseArray[0][1];
        // 原始数组的有效元素的个数
        int sum = sparseArray[0][2];

        // 创建原始数组,默认元素为0
        int[][] originalArray = new int[row][column];

        // 填充值，注意：从索引为1开始（1开始，才记录有效元素的信息）
        for (int i = 1; i < sum + 1; i++) {
            // 当前行的索引
            int curRowIndex = sparseArray[i][0];
            // 当前列的索引
            int curColumnIndex = sparseArray[i][1];
            // 当前值
            int curValue = sparseArray[i][2];
            // 给原始数组相应位置赋值
            originalArray[curRowIndex][curColumnIndex] = curValue;
        }

        return originalArray;

    }
}

```



## 队列 Queue



队列是有序列表，可以用数组实现或是链表实现

先入先出：先存入的数据，先取出



![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226730.png)



完成如下的任务：

- 创建队列的数据结构
- 判断是否满isFull
- 判断是否空isEmpty
- 队尾入队列offer
- 队首出队列poll
- 查看队首元素peek
- 展示队列所有元素



不考虑数组循环的队列实现：

```Java
public class NoCircleArrayQueue {

    // 数组
    private int[] array;

    // 数组的最大长度
    private int maxSize;

    // 队首指针
    private int front;

    // 队尾指针
    private int rear;

    public NoCircleArrayQueue(int maxSize) {
        // 最大长度
        this.maxSize = maxSize;
        // 队首指针，这里初始化为-1,指向队首元素的前一位置
        front = -1;
        // 队尾指针，这里初始化为-1,指向队尾元素
        rear = -1;
        // 初始化数组
        array = new int[maxSize];
    }

    /**
     * 判断队列是否满
     * 因为是非循环数组，就看rear==maxSize-1
     */
    public boolean isFull() {
        return rear == maxSize - 1;
    }

    /**
     * 判断队列是否空
     * 因为是非循环数组，就看front==rear
     */
    public boolean isEmpty() {
        return front == rear;
    }

    /**
     * 队尾入队列offer
     */
    public void offer(int value) {
        if (isFull()) {
            System.out.println("队列已满");
            return;
        }
        // 尾指针向后移
        rear++;
        // 设定值
        array[rear] = value;
    }

    /**
     * 队首出队列poll
     */
    public int poll() {
        if (isEmpty()) {
            throw new RuntimeException("队列为空");
        }
        // 首指针向后移
        front++;
        // 取出无素返回
        return array[front];
    }

    /**
     * 查看队首元素
     */
    public int peek() {
        if (isEmpty()) {
            throw new RuntimeException("队列为空");
        }
        // 注意：不要改变front值，front指向队首元素的前一位置
        int cur = front + 1;
        return array[cur];
    }

    /**
     * 展示所有的元素
     */
    public void show() {
        // 遍历
        if (isEmpty()) {
            System.out.println("队列为空，没有数据");
            return;
        }
        for (int i = 0; i < array.length; i++) {
            System.out.printf("arr[%d]=%d\n", i, array[i]);
        }
    }
}
```

```java
public class NoCircleArrayQueueTest {

    public static void main(String[] args) {
        NoCircleArrayQueue myQueue = new NoCircleArrayQueue(5);
        char key = ' ';
        Scanner scanner = new Scanner(System.in);
        boolean loop = true;
        while (loop) {
            System.out.println("s(show):显示队列");
            System.out.println("e(exit):退出程序");
            System.out.println("a(add):添加队列数据");
            System.out.println("g(get):从队列取出数据");
            System.out.println("h(head):查看队列头的数据");
            key = scanner.next().charAt(0);
            switch (key) {
                case 's':
                    myQueue.show();
                    break;
                case 'a':
                    System.out.println("输入一个数");
                    int value = scanner.nextInt();
                    myQueue.offer(value);
                    break;
                case 'g':
                    try {
                        int result = myQueue.poll();
                        System.out.printf("取出的数据是%d\n", result);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    break;
                case 'h':
                    try {
                        int head = myQueue.peek();
                        System.out.printf("队列头的数据是：%d\n", head);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    break;
                case 'e':
                    scanner.close();
                    loop = false;
                    break;
                default:
                    break;
            }
        }
        System.out.println("程序退出");
    }

}
```



显然，我们需要改进上面的队列实现，现在使用循环数组来优化：

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226731.png)



完成如下的任务：

- 创建队列的数据结构
- 判断是否满isFull
- 判断是否空isEmpty
- 队尾入队列offer
- 队首出队列poll
- 查看队首元素peek
- 展示队列所有元素
- <mark>求队列的有效元素的个数Size</mark>



使用循环数组模拟环形队列：

```java
public class CircleArrayQueue {

    // 数组
    private int[] array;

    // 最大长度
    private int maxSize;

    // 队首指针
    private int front;

    // 队尾指针
    private int rear;

    public CircleArrayQueue(int maxSize) {
        // 自定义数组的最大长度
        this.maxSize = maxSize;
        // 队首指针初始化为0,这里指向队首元素
        front = 0;
        // 队尾指针初始化为0,这里指向队尾元素的后一位置，并且数组中有一格不使用
        rear = 0;
        // 初始化数组
        array = new int[maxSize];
    }

    /**
     * 判断是否满
     */
    public boolean isFull() {
        return (rear + 1) % maxSize == front;
    }

    /**
     * 判断是否空
     */
    public boolean isEmpty() {
        return front == rear;
    }

    /**
     * 队尾入队列元素，注意这里rear指向队尾元素的后一位置
     */
    public void offer(int value) {
        if (isFull()) {
            System.out.println("队列已满");
            return;
        }
        // 添加元素
        array[rear] = value;
        // rear指针后移
        rear = (rear + 1) % maxSize;
    }

    /**
     * 队首出队列元素，注意这里front指向队首元素
     */
    public int poll() {
        if (isEmpty()) {
            throw new RuntimeException("队列为空");
        }
        // 记录当前front指针
        int cur = this.front;
        // front指针后移
        front = (front + 1) % maxSize;
        // 返回元素值
        return array[cur];
    }

    /**
     * 查看队首元素
     */
    public int peek() {
        if (isEmpty()) {
            throw new RuntimeException("队列为空");
        }
        // 返回队首元素值
        return array[front];
    }

    /**
     * 返回有效元素的个数，size
     */
    public int getSize() {
        return (rear - front + maxSize) % maxSize;
    }

    /**
     * 展示所有元素
     */
    public void show() {
        // 遍历
        if (isEmpty()) {
            System.out.println("队列为空，没有数据");
            return;
        }
        // 注意：从front开始遍历,size是有效元素的个数
        for (int i = front; i < front + getSize(); i++) {
            System.out.printf("arr[%d]=%d\n", i % maxSize, array[i % maxSize]);
        }
    }

}
```

```java
public class CircleArrayQueueTest {

    public static void main(String[] args) {
        CircleArrayQueue myQueue = new CircleArrayQueue(4);
        char key = ' ';
        Scanner scanner = new Scanner(System.in);
        boolean loop = true;
        while (loop) {
            System.out.println("s(show):显示队列");
            System.out.println("e(exit):退出程序");
            System.out.println("a(add):添加队列数据");
            System.out.println("g(get):从队列取出数据");
            System.out.println("h(head):查看队列头的数据");
            key = scanner.next().charAt(0);
            switch (key) {
                case 's':
                    myQueue.show();
                    break;
                case 'a':
                    System.out.println("输入一个数");
                    int value = scanner.nextInt();
                    myQueue.offer(value);
                    break;
                case 'g':
                    try {
                        int result = myQueue.poll();
                        System.out.printf("取出的数据是%d\n", result);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    break;
                case 'h':
                    try {
                        int head = myQueue.peek();
                        System.out.printf("队列头的数据是：%d\n", head);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    break;
                case 'e':
                    scanner.close();
                    loop = false;
                    break;
                default:
                    break;
            }
        }
        System.out.println("程序退出");
    }

}
```



## 链表 Linked List



![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226732.png)

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226733.png)



因为头节点不能动，所以加个head指针用于辅助移动



### 单向链表



用单向链表存储水浒英雄：

1 实现尾部插入新的节点

2 实现按编号大小插入新的节点

3 根据编号删除节点

4 根据编号修改节点

5 打印所有的节点（显示链表）

6 有效节点的个数

7 查找链表中倒数第k个节点

8 单链表的反转

9 反转打印链表

10 合并两个有序链表，合并之后还要有序（比如自然排序）



```java
public class SingleLinkedListDemo {
    public static void main(String[] args) {
        //  进行测试
        HeroNode heroNode1 = new HeroNode(1, "宋江", "及时雨");
        HeroNode heroNode2 = new HeroNode(2, "卢俊义", "玉麒麟");
        HeroNode heroNode3 = new HeroNode(3, "吴用", "智多星");
        HeroNode heroNode4 = new HeroNode(4, "林冲", "豹子头");

        // 创建链表
        SingleLikedList singleLikedList = new SingleLikedList();
        // 加入节点
        singleLikedList.addByOrder(heroNode1);
        singleLikedList.addByOrder(heroNode4);
        singleLikedList.addByOrder(heroNode2);
        singleLikedList.addByOrder(heroNode3);
        singleLikedList.addByOrder(heroNode3);

        // 测试修改节点的代码
        HeroNode heroNode = new HeroNode(2, "小卢", "修改了");

        // 显示
        singleLikedList.list();
        System.out.println();

        // 测试更新
        singleLikedList.update(heroNode);
        // 测试删除
        singleLikedList.del(1);
        singleLikedList.list();

        // 测试查看链表中有效节点的个数
        System.out.println("有效节点的个数：" + singleLikedList.getLength(singleLikedList.getHead()));

        // 测试是否找到倒数第k个节点
        HeroNode lastKNode = singleLikedList.findLastKNode(singleLikedList.getHead(), 1);
        System.out.println("倒数第k个节点" + lastKNode);

        // 测试反转链表
        singleLikedList.reverseList(singleLikedList.getHead());
        singleLikedList.list();

        System.out.println();

        // 测试逆序打印链表
        singleLikedList.reversePrint(singleLikedList.getHead());
    }
}

class SingleLikedList {

    // 先初始化一个头结点
    private HeroNode head = new HeroNode(0, null, null);

    public HeroNode getHead() {
        return this.head;
    }

    /**
     * 第一种添加方式
     * 添加节点，当前实现尾部添加
     * 思路：当不考虑编号有序时：
     * 1找到当前链表的最后节点
     * 2将最后的这个节点的next指向新的节点
     */
    public void add(HeroNode heroNode) {
        // 因为head节点不能动，所以需要辅助指针遍历链表
        HeroNode temp = head;
        while (true) {
            // 如果指针域为null,代表最后节点
            if (temp.getNext() == null) {
                break;
            }
            // 如果没有找到最后，将temp后移
            temp = temp.getNext();
        }
        // 当退出while循环时，temp就指向链表的最后节点
        temp.setNext(heroNode);
    }

    /**
     * 第二种添加方式
     * 在添加英雄时，根据排名将英雄插入到指定的位置
     * 如果已经有这个排名，则添加失败并给出提示
     */
    public void addByOrder(HeroNode heroNode) {
        // 因为头节点不能动，因此我们仍然通过一个辅助指针来帮助找到添加的位置
        // 因为是单链表，我们找的temp是位于添加位置的前一个节点
        HeroNode temp = head;
        // 添加的编号是否存在，默认false
        boolean flag = false;
        while (true) {
            if (temp.getNext() == null) {
                break;
            }
            // 位置找到，就在temp的后面插入新的节点
            if (temp.getNext().getNo() > heroNode.getNo()) {
                break;
            } else if (temp.getNext().getNo() == heroNode.getNo()) {
                // 说明编号存在
                flag = true;
                break;
            }
            temp = temp.getNext();
        }
        // 退出while循环后
        if (flag) {
            System.out.printf("准务插入的英雄编号%d已经存在，不能加入\n", heroNode.getNo());
        } else {
            // 插入到temp后面
            heroNode.setNext(temp.getNext());
            temp.setNext(heroNode);
        }
    }

    /**
     * 修改节点的信息，根据编号来修改，即编号不能改
     */
    public void update(HeroNode heroNode) {
        // 判断是否为空
        if (head.getNext() == null) {
            System.out.println("链表为空");
            return;
        }
        // 找到需要修改的节点，根据编号修改
        // 定义一个辅助变量
        HeroNode temp = head.getNext();
        // 是否找到该节点
        boolean flag = false;
        while (true) {
            if (temp == null) {
                break; // 已经遍历完成
            }
            if (temp.getNo() == heroNode.getNo()) {
                flag = true;
                break;
            }
            temp = temp.getNext();
        }
        // 根据flag判断是否找到要修改的节点
        if (flag) {
            temp.setName(heroNode.getName());
            temp.setNickname(heroNode.getNickname());
        } else {
            System.out.printf("没有找到编号为%d的节点，不能修改", heroNode.getNo());
        }
    }

    /**
     * 删除节点
     * 思路：
     * 1 head节点不能动，因此我们需要一个temp辅助节点删除节点的前一个节点
     */
    public void del(int no) {
        HeroNode temp = head;
        // 是否找到待删除节点的标志
        boolean flag = false;
        while (true) {
            //  已经到链表的最后了
            if (temp.getNext() == null) {
                break;
            }
            if (temp.getNext().getNo() == no) {
                flag = true;
                break;
            }
            temp = temp.getNext();
        }
        if (flag) {
            temp.setNext(temp.getNext().getNext());
        } else {
            System.out.println("待删除的节点不存在");
        }
    }

    /**
     * 方法获取单链表的节点个数，如果带头节点，不统计头结点
     */
    public int getLength(HeroNode head) {
        if (head.getNext() == null) {
            return 0;
        }
        int length = 0;
        // 定义一个辅助的变量cur
        HeroNode cur = head.getNext();
        while (cur != null) {
            length++;
            cur = cur.getNext();
        }
        return length;
    }

    /**
     * 查找单链表中倒数第k个节点,k从1开始
     * 思路
     * 1 编写一个方法，接收head节点，同时接收一个k
     * 2 先把链表从头到尾遍历得到链表的总的长度
     * 3 得到size后，我们从链表的第一个开始遍历size-k个
     * 如果找到，则返回该节点，否则返回null
     */
    public HeroNode findLastKNode(HeroNode head, int k) {
        // 如果链表为空，返回null
        if (head.getNext() == null) {
            return null;
        }
        //  第一次遍历获得链表的长度
        int size = getLength(head);
        // 第二次遍历size-k位置，就是我们倒数的第k个节点
        // 先做一个k校验
        if (k <= 0 || k > size) {
            return null;
        }
        // 定义辅助变量
        HeroNode cur = head.getNext();
        for (int i = 0; i < size - k; i++) {
            cur = cur.getNext();
        }
        return cur;
    }

    /**
     * 将单链表反转
     */
    public void reverseList(HeroNode head) {
        // 如果当前链表为空，或只有一个节点，无需反转，直接返回
        if (head.getNext() == null || head.getNext().getNext() == null) {
            return;
        }
        // 定义一个辅助指针，帮助我们遍历原来的链表
        HeroNode cur = head.getNext();
        // 指向当前节点的下一个节点
        HeroNode next = null;
        // 定义一个新的头节点
        HeroNode reverseHead = new HeroNode(0, null, null);
        // 遍历原来的链表，每遍历一个节点，就将其取出，并放在新链表reverseHead的最新端
        while (cur != null) {
            next = cur.getNext();
            cur.setNext(reverseHead.getNext());
            reverseHead.setNext(cur);
            cur = next;
        }
        // 将head的指针域指向reverseHead的下一个节点
        head.setNext(reverseHead.getNext());
    }

    /**
     * 逆序打印单链表
     * 方式一：先反转后打印，但会破原来单链表结构
     * 方式二：可以利用栈将各个节点压入栈中，然后利用栈的先进后出的特点，就实现了逆序输出
     */
    public void reversePrint(HeroNode heroNode) {
        // 空链表不打印
        if (heroNode.getNext() == null) {
            return;
        }
        // 创建一个栈，将各个节点压入栈中
        Stack<HeroNode> stack = new Stack<>();
        HeroNode cur = head.getNext();
        // 将链表的所有节点压入栈中
        while (cur != null) {
            stack.push(cur);
            cur = cur.getNext();
        }
        // 将栈中的节点进行打印
        while (!stack.isEmpty()) {
            System.out.println(stack.pop());
        }


    }


    // 显示链表
    public void list() {
        if (head.getNext() == null) {
            System.out.println("链表为空");
            return;
        }
        // 因为头节点不能动因此我们需要一个辅助变量来遍历
        HeroNode temp = head.getNext();
        while (true) {
            // 判断是否到链表最后
            if (temp == null) {
                break;
            }
            // 输出节点信息
            System.out.println(temp);
            // 将temp后移
            temp = temp.getNext();
        }
    }

}


/**
 * 定义HeroNode
 */
class HeroNode {

    // 前面三个数据域
    private int no;

    private String name;

    private String nickname;
    // 后面是指针域
    private HeroNode next;

    public HeroNode(int no, String name, String nickname) {
        this.no = no;
        this.name = name;
        this.nickname = nickname;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getNickname() {
        return nickname;
    }

    public void setNickname(String nickname) {
        this.nickname = nickname;
    }

    public HeroNode getNext() {
        return next;
    }

    public void setNext(HeroNode next) {
        this.next = next;
    }

    @Override
    public String toString() {
        return "HeroNode{" +
                "no=" + no +
                ", name='" + name + '\'' +
                ", nickname='" + nickname +
                '}';
    }
}
```

合并两个链表

```java
/**
 * 合并两个链表,并保持有序
 */
public MyNode mergeLinkedList(MyNode firstNode, MyNode secondNode) {
    // a链表的指针
    MyNode aPtr = firstNode;
    // b链表的指针
    MyNode bPtr = secondNode;
    // 创建新的头
    MyNode head = new MyNode();
    // 新的辅助指针
    MyNode cur = head;
    while (aPtr != null && bPtr != null) {
        if (aPtr.value < bPtr.value) {
            cur.next = aPtr;
            aPtr = aPtr.next;
        } else {
            cur.next = bPtr;
            bPtr = bPtr.next;
        }
        cur = cur.next;
    }
    cur.next = aPtr != null ? aPtr : bPtr;
    return head.next;
}
```

### 双向链表

主要任务：

1 尾部新增 append

2 按编号自然排序新增 insert

3 按编号删除 delete

4 按编号修改 update

5 查（遍历/展示）select

```java
public class DoubleLinkedListDemo {
    public static void main(String[] args) {

        // 双向链表测试
        HeroNode2 heroNode1 = new HeroNode2(1, "宋江", "及时雨");
        HeroNode2 heroNode2 = new HeroNode2(2, "卢俊义", "玉麒麟");
        HeroNode2 heroNode3 = new HeroNode2(3, "吴用", "智多星");
        HeroNode2 heroNode4 = new HeroNode2(4, "林冲", "豹子头");
        // 创建一个双向链表
        DoubleLinkedList doubleLinkedList = new DoubleLinkedList();
        // 测试添加
        doubleLinkedList.addByOrder(heroNode1);
        doubleLinkedList.addByOrder(heroNode4);
        doubleLinkedList.addByOrder(heroNode3);
        doubleLinkedList.addByOrder(heroNode2);
        // 测试显示
        doubleLinkedList.list();
        // 测试修改
        HeroNode2 newHeroNode = new HeroNode2(4, "公孙胜", "入云龙");
        doubleLinkedList.update(newHeroNode);
        System.out.println("修改后的链表情况");
        doubleLinkedList.list();
        // 测试删除
        doubleLinkedList.del(4);
        System.out.println("删除后的链表情况");
        doubleLinkedList.list();

    }
}

class DoubleLinkedList {

    // 先初始化一个头节点，头节点不动，不存放具体的数据
    private HeroNode2 head = new HeroNode2();

    // 获取头节点
    public HeroNode2 getHead() {
        return this.head;
    }

    /**
     * 遍历双向链表
     */
    public void list() {
        // 判断链表是否为空
        if (head.getNext() == null) {
            System.out.println("链表为空");
            return;
        }
        HeroNode2 temp = head.getNext();
        while (true) {
            // 如果链表到最后节点末尾，跳出循环
            if (temp == null) {
                break;
            }
            // 输出节点信息
            System.out.println(temp);
            temp = temp.getNext();
        }
    }

    /**
     * 尾部添加节点
     */
    public void add(HeroNode2 heroNode2) {
        HeroNode2 temp = head;
        while (true) {
            if (temp.getNext() == null) {
                break;
            }
            temp = temp.getNext();
        }
        temp.setNext(heroNode2);
        heroNode2.setPre(temp);
    }

    /**
     * 按编号添加，编号自然排序
     */
    public void addByOrder(HeroNode2 heroNode2) {
        HeroNode2 temp = head;
        boolean repeatFlag = false;
        while (true) {
            if (temp.getNext() == null) {
                break;
            }
            if (heroNode2.getNo() < temp.getNext().getNo()) {
                break;
            } else if (heroNode2.getNo() == temp.getNext().getNo()) {
                repeatFlag = true;
                break;
            }
            temp = temp.getNext();
        }
        if (repeatFlag) {
            System.out.println("重复编号");
            return;
        }
        heroNode2.setNext(temp.getNext());
        heroNode2.setPre(temp);
        // 注意，要先设置后一个节点的pre引用
        if (temp.getNext() != null) {
            temp.getNext().setPre(heroNode2);
        }
        // 最后，设置前一个节点的next引用
        temp.setNext(heroNode2);

    }

    /**
     * 修改节点
     */
    public void update(HeroNode2 heroNode2) {
        // 判断是否为空
        if (head.getNext() == null) {
            System.out.println("链表是否为空");
            return;
        }
        // 找到需要修改的节点，根据no编号
        HeroNode2 temp = head.getNext();
        boolean flag = false;
        while (true) {
            if (temp == null) {
                break;
            }
            if (temp.getNo() == heroNode2.getNo()) {
                flag = true;
                break;
            }
            temp = temp.getNext();
        }
        if (flag) {
            temp.setName(heroNode2.getName());
            temp.setNickname(heroNode2.getNickname());
        } else {
            System.out.println("没有找到节点");
        }
    }

    /**
     * 从双向链表中删除节点，对于双向链表我们可以直接指针指向待删除节点（因为有双向的指针可以找到各个节点信息）
     */
    public void del(int no) {
        if (head.getNext() == null) {
            System.out.println("链表为空，不能删除");
            return;
        }
        HeroNode2 temp = head.getNext();
        boolean flag = false;
        while (true) {
            if (temp == null) {
                break;
            }
            if (no == temp.getNo()) {
                flag = true;
                break;
            }
            temp = temp.getNext();
        }
        if (flag) {
            temp.getPre().setNext(temp.getNext());
            if (temp.getNext() != null) {
                temp.getNext().setPre(temp.getPre());
            }
        }
    }


}

class HeroNode2 {

    private int no;

    private String name;

    private String nickname;

    private HeroNode2 next;

    private HeroNode2 pre;

    public HeroNode2() {
    }

    public HeroNode2(int no, String name, String nickname) {
        this.no = no;
        this.name = name;
        this.nickname = nickname;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getNickname() {
        return nickname;
    }

    public void setNickname(String nickname) {
        this.nickname = nickname;
    }

    public HeroNode2 getNext() {
        return next;
    }

    public void setNext(HeroNode2 next) {
        this.next = next;
    }

    public HeroNode2 getPre() {
        return pre;
    }

    public void setPre(HeroNode2 pre) {
        this.pre = pre;
    }

    @Override
    public String toString() {
        return "HeroNode2{" +
                "no=" + no +
                ", name='" + name + '\'' +
                ", nickname='" + nickname + '\'' +
                '}';
    }
}
```

### 单向环形链表

#### 约瑟夫问题 Jossephu

Jossephu问题：设编号为1，2，… n的n个人围坐一圈，约定编号为k（1<=k<=n）的人从1开始报数，数到m 的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。

提示：用一个不带头结点的循环链表来处理Josephu 问题：先构成一个有n个结点的单循环链表，然后由k结点起从1开始计数，计到m时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从1开始计数，直到最后一个结点从链表中删除算法结束。

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226734.png)

构建单向环形链表思路：

1 先创建第一个节点，让first指向该节点，并形成环形。last指针指向最后一个节点

2 后面当我们每创建一个新的节点，就把该节点加入到已有的环形链表

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226735.png)

```java
public class Josephu {
    public static void main(String[] args) {
        // 测试构建
        SingleCircleLinkedList singleCircleLinkedList = new SingleCircleLinkedList();
        singleCircleLinkedList.addBoy(5);
        // 测试展示
        singleCircleLinkedList.showBoy();
        // 测试出圈
        singleCircleLinkedList.countBoy(1, 2, 5);
    }
}

// 创建一个环形的单向链表
class SingleCircleLinkedList {

    // 创建first节点，并置为null
    private Boy first = null;

    /**
     * 添加小孩节点，构成环形的链表
     * num表示数量
     */
    public void addBoy(int num) {
        if (num < 1) {
            System.out.println("num不正确");
            return;
        }
        // 辅助指针
        Boy last = null;
        // 使用for循环创建我们的环形链表
        for (int i = 1; i <= num; i++) {
            // 根据编号创建小孩节点
            Boy boy = new Boy(i);
            // 如果是第一个小孩
            if (i == 1) {
                first = boy;
                first.setNext(first);
                last = first;
            } else {
                boy.setNext(first);
                last.setNext(boy);
                // last指向最后
                last = boy;
            }
        }
    }

    /**
     * 遍历当前环形链表
     */
    public void showBoy() {
        // 判断是否为空
        if (first == null) {
            System.out.println("链表为空");
            return;
        }
        // 因为first不能动
        Boy cur = first;
        while (true) {
            System.out.printf("小孩的编号%d\n", cur.getNo());
            if (cur.getNext() == first) {
                break;
            }
            // cur后移
            cur = cur.getNext();
        }
    }

    /**
     * 根据用户的输入，计算出出圈的顺序
     *
     * @param k   从第k个小孩开始报数
     * @param m   表示数几下
     * @param num 表示最初多少个小孩在圈中
     */
    public void countBoy(int k, int m, int num) {
        // 先对数据进行校验
        if (first == null || k < 1 || k > num) {
            System.out.println("参数有误");
            return;
        }
        // 创建辅助指针，并将移到报数小孩的前面，帮助完成小孩出圈
        Boy helper = first;
        while (true) {
            if (helper.getNext() == first) {
                break;
            }
            helper = helper.getNext();
        }
        // 先让first和helper移动k-1次，相当于first指向第k个小孩，helper位于first之前
        for (int i = 0; i < k - 1; i++) {
            first = first.getNext();
            helper = helper.getNext();
        }
        // 当小孩报数时，让first,helper指针同时移动m-1次，然后出圈
        // 这里是个循环的操作，只到圈中只有一个
        while (true) {
            // 说明圈中只有一个
            if (helper == first) {
                break;
            }
            for (int i = 0; i < m - 1; i++) {
                first = first.getNext();
                helper = helper.getNext();
            }
            // 此时first指向出圈的小孩节点
            System.out.printf("小孩%d出圈\n", first.getNo());
            // 出圈
            first = first.getNext();
            helper.setNext(first);
        }
        // 退出循环时，圈中只有一个小孩
        System.out.printf("最后留在圈中的小孩%d\n", first.getNo());
    }


}

// 创建节点，这里是Boy类
class Boy {
    // 编号
    private int no;
    // 下一个小孩
    private Boy next;

    public Boy(int no) {
        this.no = no;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public Boy getNext() {
        return next;
    }

    public void setNext(Boy next) {
        this.next = next;
    }
}
```

## 栈 Stack

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226736.png)

### 数组模拟栈

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226737.png)

```java
public class MyStackDemo {

    public static void main(String[] args) {
        // 创建栈
        ArrayStack stack = new ArrayStack(4);
        String key = "";
        boolean loop = true; // 是否退出菜单
        Scanner scanner = new Scanner(System.in);
        while (loop) {
            System.out.println("show: 显示栈");
            System.out.println("exit: 退出程序");
            System.out.println("push: 入栈");
            System.out.println("pop: 出栈");
            key = scanner.next();
            switch (key) {
                case "show":
                    stack.list();
                    break;
                case "push":
                    System.out.println("请输入一个数：");
                    int value = scanner.nextInt();
                    stack.push(value);
                    break;
                case "pop":
                    try {
                        int res = stack.pop();
                        System.out.printf("出栈的数据是 %d\n", res);
                    } catch (Exception e) {
                        System.out.println(e.getMessage());
                    }
                    break;
                case "exit":
                    scanner.close();
                    loop = false;
                    break;
                default:
                    break;
            }
        }
        System.out.println("程序退出");
    }
}

class ArrayStack {
    private int maxSize; // 栈的大小
    private int[] stack; // 数组，数组模拟栈，数据放在此数组中
    private int top = -1; // top表示栈顶，初始化为-1

    // 构造器
    public ArrayStack(int maxSize) {
        this.maxSize = maxSize;
        stack = new int[this.maxSize];
    }

    // 栈满
    public boolean isFull() {
        return top == this.maxSize - 1;
    }

    // 栈空
    public boolean isEmpty() {
        return top == -1;
    }

    // 入栈
    public void push(int value) {
        //  判断栈满
        if (isFull()) {
            System.out.println("栈满");
            return;
        }
        top++;
        stack[top] = value;
    }

    // 出栈
    public int pop() {
        // 先判断栈空
        if (isEmpty()) {
            throw new RuntimeException("栈空");
        }
        int value = stack[top];
        top--;
        return value;
    }

    // 显示栈/遍历栈，从栈顶向下遍历
    public void list() {
        if (isEmpty()) {
            System.out.println("栈空");
            return;
        }
        for (int i = top; i >= 0; i--) {
            System.out.printf("stack[%d]=%d\n", i, stack[i]);
        }
    }
}
```

### 用链表模拟栈

```java
public class MyStackDemo2 {
    public static void main(String[] args) {
        // 创建栈
        LinkedListStack stack = new LinkedListStack();
        String key = "";
        boolean loop = true; // 是否退出菜单
        Scanner scanner = new Scanner(System.in);
        while (loop) {
            System.out.println("show: 显示栈");
            System.out.println("exit: 退出程序");
            System.out.println("push: 入栈");
            System.out.println("pop: 出栈");
            key = scanner.next();
            switch (key) {
                case "show":
                    stack.list();
                    break;
                case "push":
                    System.out.println("请输入一个数：");
                    int value = scanner.nextInt();
                    stack.push(value);
                    break;
                case "pop":
                    try {
                        int res = stack.pop();
                        System.out.printf("出栈的数据是 %d\n", res);
                    } catch (Exception e) {
                        System.out.println(e.getMessage());
                    }
                    break;
                case "exit":
                    scanner.close();
                    loop = false;
                    break;
                default:
                    break;
            }
        }
    }


}

class LinkedListStack {


    // 要持有个头节点
    private Node head = new Node();

    // 入栈,在尾部添加的方式
    public void push(int value) {
        Node node = new Node(value);
        Node temp = head;
        while (true) {
            if (temp.getNext() == null) {
                break;
            }
            temp = temp.getNext();
        }
        // 跳出while循环时，temp指向最后一个节点
        temp.setNext(node);
    }

    // 出栈,栈顶元素在尾部
    public int pop() {
        if (isEmpty()) {
            throw new RuntimeException("栈空");
        }
        Node temp = head;
        while (true) {
            if (temp.getNext().getNext() == null) {
                break;
            }
            temp = temp.getNext();
        }
        // 跳出循环，temp指向最后一个节点前一个节点
        int value = temp.getNext().getData();
        temp.setNext(null);
        return value;
    }

    // 栈空
    public boolean isEmpty() {
        if (head.getNext() == null) {
            return true;
        }
        return false;
    }

    // 显示栈,需要倒序输出:这里需要另一个栈
    public void list() {
        if (isEmpty()) {
            System.out.println("栈空");
            return;
        }
        Node temp = head.getNext();
        Stack<Integer> integerStack = new Stack<Integer>();
        while (true) {
            if (temp == null) {
                break;
            }
            integerStack.push(temp.getData());
            temp = temp.getNext();
        }
        while (!integerStack.isEmpty()) {
            System.out.printf("节点值为：%d\n", integerStack.pop());
        }

    }


    public class Node {

        private int data; // 数据域

        private Node next; // 指针域

        public Node() {
        }

        public Node(int data) {
            this.data = data;
        }

        public int getData() {
            return data;
        }

        public void setData(int data) {
            this.data = data;
        }

        public Node getNext() {
            return next;
        }

        public void setNext(Node next) {
            this.next = next;
        }
    }

}
```

## 三种表达式：前缀prefix，中缀infix，后缀suffix

### 表达式简介

中缀表达式即传统的数学表达式：(3+4)×5-6
中缀转前缀(波兰表达式)： (3+4)×5-6 对应的前缀表达式就是 - × + 3 4 5 6
后缀表达式(逆波兰表达式)，就是前缀的逆向 3 4 + 5 * 6 -



前缀表达式的计算机求值：

从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 和 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果

```properties
例如: (3+4)×5-6 对应的前缀表达式就是 - × + 3 4 5 6 , 针对前缀表达式求值步骤如下:

1 从右至左扫描，将6、5、4、3压入堆栈

2 遇到+运算符，因此弹出3和4（3为栈顶元素，4为次顶元素），计算出3+4的值得7，再将7入栈

3 接下来是×运算符，因此弹出7和5，计算出7×5=35，将35入栈

4 最后是-运算符，计算出35-6的值，即29，由此得出最终结果
```



后缀表达式又称逆波兰表达式,与前缀表达式相似，只是运算符位于操作数之后

举例： (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 –

| 中缀表达式（数学表达式） | 前缀表达式 （波兰表达式） | 后缀表达式（逆波兰表达式）|
| - | - | -|
| a+b | + a b | a b + |
| a + (b-c) | + a - b c | a b c - + |
| a + (b-c)\*d | + a \* - b c d | a b c - d \* + |
| a + d \* (b-c) | + a \* d - b c | a d b c - \* + |
| a = 1 + 3 | = a + 1 3 | a 1 3 + = | 

后缀表达式的计算机求值

从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 和 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果

```properties
例如: (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 - , 针对后缀表达式求值步骤如下:

1 从左至右扫描，将3和4压入堆栈；

2 遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值得7，再将7入栈；

3 将5入栈；

4 接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；

5 将6入栈；

6 最后是-运算符，计算出35-6的值，即29，由此得出最终结果
```

### 栈实现计算器 中缀表达式（不考虑括号）

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226739.png)

```java
public class Calculator {
    public static void main(String[] args) {
        String expression = "13+2*6-5";
        // 创建两个栈，数栈与符号栈
        ArrayStack2 numStack = new ArrayStack2(10);
        ArrayStack2 operatorStack = new ArrayStack2(10);
        // 用于扫描的指针
        int index = 0;
        int num1 = 0;
        int num2 = 0;
        int operator = 0;
        int res = 0;
        char ch = ' '; // 将每次扫描得到char保存到ch中
        String keepNum = ""; // 用于拼接数字的
        while (true) {
            // 依次得到expression中每一个字符
            ch = expression.substring(index, index + 1).charAt(0);
            // 判断ch是什么
            if (operatorStack.isOperator(ch)) {
                // 判断当前符号栈是否为空
                if (!operatorStack.isEmpty()) {
                    // 如果符号栈有操作符，就进行比较，
                    // 如果当前的操作符的优先及小于或考等于栈中的操作符
                    // 就从数栈中弹了两个数，再从符号栈中pop出一个符号进行运算，
                    // 得到结果再入数栈，当前操作符入符号栈
                    if (operatorStack.priority(ch) <= operatorStack.priority(operatorStack.peek())) {
                        num1 = numStack.pop();
                        num2 = numStack.pop();
                        operator = operatorStack.pop();
                        res = numStack.cal(num1, num2, operator);
                        // 把运算结果放入数线
                        numStack.push(res);
                        // 将当前符号入符号栈
                        operatorStack.push(ch);
                    } else {
                        // 如果当前的操作符的优先级大于栈中的操作符
                        operatorStack.push(ch);
                    }
                } else {
                    // 如果为空直接入栈
                    operatorStack.push(ch);
                }
            } else {
                // 如果是数字, 处理多位数，需要向expression后再看一位，如果是数字继续，如果是操作符才将前面的入栈
                // 所以需要定义一个变量用于拼接
                // numStack.push(ch - 48);
                keepNum += ch;
                // 如果ch已经是expression的最后一位，就直接入栈
                if (index == expression.length() - 1) {
                    numStack.push(Integer.parseInt(keepNum));
                } else {
                    // 判断下一个字符是否为数字，如果是数字就继续扫描，如果是运算符则入栈
                    if (operatorStack.isOperator(expression.substring(index + 1, index + 2).charAt(0))) {
                        // 如果后一位是操作符，入栈
                        numStack.push(Integer.parseInt(keepNum));
                        // 重要的，要清空keepNum
                        keepNum = "";
                    }
                }
            }
            // 让index+1，并判断是否扫描到expression最后
            index++;
            if (index >= expression.length()) {
                break;
            }
        }

        //  当表达式扫描完毕，就顺序的从数栈和符号栈中pop出相应的数和符号并运行
        while (true) {
            // 如果符号栈为空，则计算到最后的结果，数栈中只有一个数
            if (operatorStack.isEmpty()) {
                break;
            }
            num1 = numStack.pop();
            num2 = numStack.pop();
            operator = operatorStack.pop();
            res = numStack.cal(num1, num2, operator);
            numStack.push(res);
        }
        // 将最后的数pop出来就是结果
        System.out.printf("表达式%s 结果%d", expression, numStack.pop());
    }
}

// 先创建一个栈，并添加一些方法：计算符号的优先级，计算方法，是否为操作符
class ArrayStack2 {
    private int maxSize; // 栈的大小
    private int[] stack; // 数组，数组模拟栈，数据放在此数组中
    private int top = -1; // top表示栈顶，初始化为-1

    // 构造器
    public ArrayStack2(int maxSize) {
        this.maxSize = maxSize;
        stack = new int[this.maxSize];
    }

    // 栈满
    public boolean isFull() {
        return top == this.maxSize - 1;
    }

    // 栈空
    public boolean isEmpty() {
        return top == -1;
    }

    // 入栈
    public void push(int value) {
        //  判断栈满
        if (isFull()) {
            System.out.println("栈满");
            return;
        }
        top++;
        stack[top] = value;
    }

    // 出栈
    public int pop() {
        // 先判断栈空
        if (isEmpty()) {
            throw new RuntimeException("栈空");
        }
        int value = stack[top];
        top--;
        return value;
    }

    // 显示栈/遍历栈，从栈顶向下遍历
    public void list() {
        if (isEmpty()) {
            System.out.println("栈空");
            return;
        }
        for (int i = top; i >= 0; i--) {
            System.out.printf("stack[%d]=%d\n", i, stack[i]);
        }
    }

    // 返回运算符的优先级，优先级使用数字表示，优先级越高，数字越大
    public int priority(int operator) {
        if (operator == '*' || operator == '/') {
            return 1;
        } else if (operator == '+' || operator == '-') {
            return 0;
        } else {
            // 假定目前的表达式只有+，-，*，/
            return -1;
        }
    }

    // 是否为操作符
    public boolean isOperator(char val) {
        return val == '+' || val == '-' || val == '*' || val == '/';
    }

    // 计算方法
    public int cal(int num1, int num2, int operator) {
        // res用于存放计算结果
        int res = 0;
        switch (operator) {
            case '+':
                res = num1 + num2;
                break;
            case '-':
                res = num2 - num1; // 注意顺序
                break;
            case '*':
                res = num1 * num2;
                break;
            case '/':
                res = num2 / num1;
                break;
            default:
                break;
        }
        return res;
    }

    // 查看栈顶
    public int peek() {
        if (isEmpty()) {
            throw new RuntimeException("栈空");
        }
        return stack[top];
    }
}
```

### 逆波兰（后缀表达式）计算器的初步实现

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226740.png)

```java
public class PolandNotation {
    public static void main(String[] args) {
        // 先定义逆波兰表达式 (3+4)*5-6 = 3 4 + 5 * 6 -
        String suffixExpression = "3 4 + 5 * 6 -";
        // 思路
        // 1  先将 "3 4 + 5 * 6 -" 放到 ArrayList中
        // 2  将ArrayList传递给一个方法，遍历ArrayList 配合栈完成计算
        List<String> list = getListString(suffixExpression);

        // 测试
        int res = cal(list);
        System.out.println("计算的结果是="+res);
    }

    // 将逆波兰表达式，依次将数据与运算符放到 ArrayList中
    public static List<String> getListString(String suffixExpression) {
        // 将suffixExpression按空格进行分割
        String[] split = suffixExpression.split(" ");
        List<String> list = new ArrayList<>();
        for (String s : split) {
            list.add(s);
        }
        return list;
    }

    /**
     * 完成逆波兰表达式的运算
     * 从左到右扫描，将3和4压放堆栈
     * 遇到+运算符，因此弹出4和3(4为栈顶元素，3为次顶元素）， 计算出3+4的值，得7，再将7入栈
     * 将5入栈
     * 接下来是*运算符，因此弹出5和7，计算出7*5=35，将35入栈
     * 将6入栈
     * 最后-运算符，计算出35-6的值，即29，由此得出最终结果
     */
    public static int cal(List<String> list) {
        // 创建一个数栈，只需一个
        Stack<String> stack = new Stack<>();
        // 遍历list
        for (String item : list) {
            // 这里使用正则表达式来取出数
            if (item.matches("\\d+")) {
                // 入栈
                stack.push(item);
            } else {
                // pop出两个数，并运算，结果再入栈
                int num2 = Integer.parseInt(stack.pop());
                int num1 = Integer.parseInt(stack.pop());
                int res = 0;
                if (item.equals("+")) {
                    res = num1 + num2;
                } else if (item.equals("-")) {
                    res = num1 - num2;
                } else if (item.equals("*")) {
                    res = num1 * num2;
                } else if (item.equals("/")) {
                    res = num1 / num2;
                } else {
                    throw new RuntimeException("运算符有误");
                }
                // res入栈
                stack.push(res + "");
            }
        }
        // 最后留在stack中的数据是运算结果
        return Integer.parseInt(stack.pop());
    }
}
```

### 中缀表达式转后缀表达式 思路

```properties
思路：1+((2+3)×4)-5 转 "1 2 3 + 4 × + 5 –"

1 初始化两个栈：运算符括号栈s1和储存中间结果的栈s2；

2 从左至右扫描中缀表达式；

3 遇到操作数时，将其压s2

4 遇到运算符时，比较其与s1栈顶运算符的优先级：
 (1)如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；
 (2)否则，若优先级比栈顶运算符的高，也将运算符压入s1；
 (3)否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4、(1)步骤)与s1中新的栈顶运算符相比较；

5 遇到括号时：
 (1) 如果是左括号“(”，则直接压入s1栈

(2) 如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃

6 重复步骤2至5，直到表达式的最右边

7 将s1中剩余的运算符依次弹出并压入s2

8 依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式
```

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226741.png)

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226742.png)

### 逆波兰计算器的实现：不考虑小数点，未兼容处理符号

```java
public class PolandNotation {
    public static void main(String[] args) {
        // 完成将中缀表达式转为后缀表达式
        // 因为直接对字符串操作不方便，先将字符串转成中缀表达式对应的list
        // 1+((2+3)*4)-5 --> [1, +, (, (, 2, +, 3, ), *, 4, ), -, 5]
        String infixExpression = "1+((2+3)*4)-5";
        // 先将中缀表达式字符串转为中缀表达式list
        List<String> infixExpressionList = toInfixExpressionList(infixExpression);
        System.out.println("中缀表达式为：" + infixExpressionList);
        // 中缀表达式list 转为 后缀表达式list [1, 2, 3, +, 4, *, 5, -]
        List<String> suffixExpressionList = parseSuffixExpressionList(infixExpressionList);
        System.out.println("后缀表达式为：" + suffixExpressionList);
        // 测试计算结果
        int cal = cal(suffixExpressionList);
        System.out.println("计算结果为："+cal);

        // 先定义逆波兰表达式 (3+4)*5-6 = 3 4 + 5 * 6 -
        String suffixExpression = "3 4 + 5 * 6 -";
        // 思路
        // 1  先将 "3 4 + 5 * 6 -" 放到 ArrayList中
        // 2  将ArrayList传递给一个方法，遍历ArrayList 配合栈完成计算
        List<String> list = getListString(suffixExpression);

        // 测试
        int res = cal(list);
        System.out.println("计算的结果是=" + res);
    }

    // 中缀表达式list转为后缀表达式list
    public static List<String> parseSuffixExpressionList(List<String> list) {
        // 定义两个栈
        Stack<String> s1 = new Stack<>(); // 操作符与括号栈
        // 中间结果栈因为重来没有弹栈并且还要逆序输出，可以用ArrayList代替
        // Stack<String> s2 = new Stack<>();
        List<String> s2 = new ArrayList<>();

        // 遍因list
        for (String item : list) {
            // 如果是一个数，入s2栈
            if (item.matches("\\d+")) {
                s2.add(item);
            } else {
                // 如果是左括号，直接入s1栈
                if (item.equals("(")) {
                    s1.push(item);
                } else if (item.equals(")")) {
                    // 如果是右括号，弹出相应的符号并入s2栈，直到遇到左括号时
                    while (!s1.peek().equals("(")) {
                        s2.add(s1.pop());
                    }
                    // 退出while循环时，s1栈顶为左括号
                    s1.pop(); // 将对应的左括号弹出
                } else {
                    // 当item的优先级小于或等于栈顶运算符，就应该
                    // 将s1的栈顶运算符弹出并压入s2,再反复比较
                    // 问题：我们缺少优先级比较的方法
                    while (s1.size() != 0 && Operator.getValue(s1.peek()) >= Operator.getValue(item)) {
                        s2.add(s1.pop());
                    }
                    // 退出while循环时，s1栈顶的操作符的优先级小于 遍历的操作符item
                    // item 还要入栈，这里包括几种情况：
                    // 栈为空，栈顶为左括号，s1栈顶的操作符的优先级小于 遍历的操作符item
                    s1.push(item);
                }

            }
        }
        // 完成一轮遍历后，将s1的运算符压入s2中
        if (s1.size() != 0) {
            s2.add(s1.pop());
        }
        // 如果s2是栈，则需要逆序输出
        return s2;
    }

    // 将中缀表达式转为对应的list
    public static List<String> toInfixExpressionList(String s) {
        // 定义一个List,存放中缀表达式对应的内容
        List<String> list = new ArrayList<>();
        int i = 0; // 相当于指针，用于遍历中缀表达式字符串
        String str; // 用于多位数的拼接
        char c; // 每遍历一个字符，就放入c中；
        do {
            // 如果c是非数字，就需要加入到list 48~57对应0~9
            c = s.charAt(i);
            if (c < 48 || c > 57) {
                list.add(c + "");
                i++; // i 要后移
            } else {
                // 如果是一个数，需要考虑多位数的问题
                str = "";  // 先将str置为空串
                while (i < s.length() && (c = s.charAt(i)) >= 48 && (c = s.charAt(i)) <= 57) {
                    str += c;// 拼接
                    i++;
                }
                // 跳出while循环时，i指向数字后的操作符或括号
                list.add(str);
            }
        } while (i < s.length());
        return list;

    }

    // 将逆波兰表达式，依次将数据与运算符放到 ArrayList中
    public static List<String> getListString(String suffixExpression) {
        // 将suffixExpression按空格进行分割
        String[] split = suffixExpression.split(" ");
        List<String> list = new ArrayList<>();
        for (String s : split) {
            list.add(s);
        }
        return list;
    }

    /**
     * 完成逆波兰表达式的运算
     * 从左到右扫描，将3和4压放堆栈
     * 遇到+运算符，因此弹出4和3(4为栈顶元素，3为次顶元素）， 计算出3+4的值，得7，再将7入栈
     * 将5入栈
     * 接下来是*运算符，因此弹出5和7，计算出7*5=35，将35入栈
     * 将6入栈
     * 最后-运算符，计算出35-6的值，即29，由此得出最终结果
     */
    public static int cal(List<String> list) {
        // 创建一个数栈，只需一个
        Stack<String> stack = new Stack<>();
        // 遍历list
        for (String item : list) {
            // 这里使用正则表达式来取出数
            if (item.matches("\\d+")) {
                // 入栈
                stack.push(item);
            } else {
                // pop出两个数，并运算，结果再入栈
                int num2 = Integer.parseInt(stack.pop());
                int num1 = Integer.parseInt(stack.pop());
                int res = 0;
                if (item.equals("+")) {
                    res = num1 + num2;
                } else if (item.equals("-")) {
                    res = num1 - num2;
                } else if (item.equals("*")) {
                    res = num1 * num2;
                } else if (item.equals("/")) {
                    res = num1 / num2;
                } else {
                    throw new RuntimeException("运算符有误");
                }
                // res入栈
                stack.push(res + "");
            }
        }
        // 最后留在stack中的数据是运算结果
        return Integer.parseInt(stack.pop());
    }
}

// 编写一个类Operator，可以返回一个运算符的优先级
class Operator {

    private static final int ADD = 1;
    private static final int SUB = 1;
    private static final int MUL = 2;
    private static final int DIV = 2;

    // 写一个方法，返回对应的优先级数字
    public static int getValue(String operator) {
        int result = 0;
        switch (operator) {
            case "+":
                result = ADD;
                break;
            case "-":
                result = SUB;
                break;
            case "*":
                result = MUL;
                break;
            case "/":
                result = DIV;
                break;
            default:
                System.out.println("操作符不支持"); // 这种情况优先级为0
                break;
        }
        return result;
    }
}
```

### 逆波兰计算器加强版

```properties
1 支持 + - * / ( )
2 多位数，支持小数,
3 兼容处理, 过滤任何空白字符，包括空格、制表符、换页符
```

```Java
public class ReversePolishMultiCalc {

     /**
     * 匹配 + - * / ( ) 运算符
     */
    static final String SYMBOL = "\\+|-|\\*|/|\\(|\\)";

    static final String LEFT = "(";
    static final String RIGHT = ")";
    static final String ADD = "+";
    static final String MINUS= "-";
    static final String TIMES = "*";
    static final String DIVISION = "/";

    /**
     * 加減 + -
     */
    static final int LEVEL_01 = 1;
    /**
     * 乘除 * /
     */
    static final int LEVEL_02 = 2;

    /**
     * 括号
     */
    static final int LEVEL_HIGH = Integer.MAX_VALUE;


    static Stack<String> stack = new Stack<>();
    static List<String> data = Collections.synchronizedList(new ArrayList<String>());

    /**
     * 去除所有空白符
     * @param s
     * @return
     */
    public static String replaceAllBlank(String s ){
        // \\s+ 匹配任何空白字符，包括空格、制表符、换页符等等, 等价于[ \f\n\r\t\v]
        return s.replaceAll("\\s+","");
    }

    /**
     * 判断是不是数字 int double long float
     * @param s
     * @return
     */
    public static boolean isNumber(String s){
        Pattern pattern = Pattern.compile("^[-\\+]?[.\\d]*$");
        return pattern.matcher(s).matches();
    }

    /**
     * 判断是不是运算符
     * @param s
     * @return
     */
    public static boolean isSymbol(String s){
        return s.matches(SYMBOL);
    }

    /**
     * 匹配运算等级
     * @param s
     * @return
     */
    public static int calcLevel(String s){
        if("+".equals(s) || "-".equals(s)){
            return LEVEL_01;
        } else if("*".equals(s) || "/".equals(s)){
            return LEVEL_02;
        }
        return LEVEL_HIGH;
    }

    /**
     * 匹配
     * @param s
     * @throws Exception
     */
    public static List<String> doMatch (String s) throws Exception{
        if(s == null || "".equals(s.trim())) throw new RuntimeException("data is empty");
        if(!isNumber(s.charAt(0)+"")) throw new RuntimeException("data illeagle,start not with a number");

        s = replaceAllBlank(s);

        String each;
        int start = 0;

        for (int i = 0; i < s.length(); i++) {
            if(isSymbol(s.charAt(i)+"")){
                each = s.charAt(i)+"";
                //栈为空，(操作符，或者 操作符优先级大于栈顶优先级 && 操作符优先级不是( )的优先级 及是 ) 不能直接入栈
                if(stack.isEmpty() || LEFT.equals(each)
                        || ((calcLevel(each) > calcLevel(stack.peek())) && calcLevel(each) < LEVEL_HIGH)){
                    stack.push(each);
                }else if( !stack.isEmpty() && calcLevel(each) <= calcLevel(stack.peek())){
                    //栈非空，操作符优先级小于等于栈顶优先级时出栈入列，直到栈为空，或者遇到了(，最后操作符入栈
                    while (!stack.isEmpty() && calcLevel(each) <= calcLevel(stack.peek()) ){
                        if(calcLevel(stack.peek()) == LEVEL_HIGH){
                            break;
                        }
                        data.add(stack.pop());
                    }
                    stack.push(each);
                }else if(RIGHT.equals(each)){
                    // ) 操作符，依次出栈入列直到空栈或者遇到了第一个)操作符，此时)出栈
                    while (!stack.isEmpty() && LEVEL_HIGH >= calcLevel(stack.peek())){
                        if(LEVEL_HIGH == calcLevel(stack.peek())){
                            stack.pop();
                            break;
                        }
                        data.add(stack.pop());
                    }
                }
                start = i ;    //前一个运算符的位置
            }else if( i == s.length()-1 || isSymbol(s.charAt(i+1)+"") ){
                each = start == 0 ? s.substring(start,i+1) : s.substring(start+1,i+1);
                if(isNumber(each)) {
                    data.add(each);
                    continue;
                }
                throw new RuntimeException("data not match number");
            }
        }
        //如果栈里还有元素，此时元素需要依次出栈入列，可以想象栈里剩下栈顶为/，栈底为+，应该依次出栈入列，可以直接翻转整个stack 添加到队列
        Collections.reverse(stack);
        data.addAll(new ArrayList<>(stack));

        System.out.println(data);
        return data;
    }

    /**
     * 算出结果
     * @param list
     * @return
     */
    public static Double doCalc(List<String> list){
        Double d = 0d;
        if(list == null || list.isEmpty()){
            return null;
        }
        if (list.size() == 1){
            System.out.println(list);
            d = Double.valueOf(list.get(0));
            return d;
        }
        ArrayList<String> list1 = new ArrayList<>();
        for (int i = 0; i < list.size(); i++) {
            list1.add(list.get(i));
            if(isSymbol(list.get(i))){
                Double d1 = doTheMath(list.get(i - 2), list.get(i - 1), list.get(i));
                list1.remove(i);
                list1.remove(i-1);
                list1.set(i-2,d1+"");
                list1.addAll(list.subList(i+1,list.size()));
                break;
            }
        }
        doCalc(list1);
        return d;
    }

    /**
     * 运算
     * @param s1
     * @param s2
     * @param symbol
     * @return
     */
    public static Double doTheMath(String s1,String s2,String symbol){
        Double result ;
        switch (symbol){
            case ADD : result = Double.valueOf(s1) + Double.valueOf(s2); break;
            case MINUS : result = Double.valueOf(s1) - Double.valueOf(s2); break;
            case TIMES : result = Double.valueOf(s1) * Double.valueOf(s2); break;
            case DIVISION : result = Double.valueOf(s1) / Double.valueOf(s2); break;
            default : result = null;
        }
        return result;

    }

    public static void main(String[] args) {
        //String math = "9+(3-1)*3+10/2";
        String math = "12.8 + (2 - 3.55)*4+10/5.0";
        try {
            doCalc(doMatch(math));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}
```

##  递归 Recursion

```java
public class Recursion {
    public static void main(String[] args) {


    }

    // 打印问题
    public void test(int n) {
        if (n > 2) {
            test(n - 1);
        }
        System.out.println("n=" + n);
    }

    // 阶乘问题
    public int factorial(int n) {
        if (n == 1 || n == 0) {
            return 1;
        } else {
            return factorial(n - 1) * n;
        }
    }
}
```

### 递归必须遵守的规则

```properties
1 执行一个方法时，就创建一个新的受保护的独立空间(栈空间) --- 默认遵守了(main)
2 方法的局部变量是独立的，不会相互影响, 比如n变量
3 如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据.（上图堆中的）
4 递归必须向退出递归的条件逼近，否则就是无限递归,出现StackOverflowError，栈溢出)
5 当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。
```

### 迷宫Maze问题：回溯recall+递归recursion

8行7列的矩阵

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226743.png)

```java
public class Maze {
    public static void main(String[] args) {
        // 先创建一个二维数组，模拟迷宫
        // 地图
        int[][] map = new int[8][7];
        // 约定1表示墙
        // 上下置为1
        for (int i = 0; i < 7; i++) {
            map[0][i] = 1;
            map[7][i] = 1;
        }
        // 左右全部为1
        for (int i = 0; i < 8; i++) {
            map[i][0] = 1;
            map[i][6] = 1;
        }
        //  设置挡板
        map[3][1] = 1;
        map[3][2] = 1;

        // 输出地图
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 7; j++) {
                System.out.printf(map[i][j] + " ");
            }
            System.out.println();
        }

        // 使用递归回溯给小球找路
        setWay(map, 1, 1);

        // 输出新的地图，小球走过，并标识过的地图
        System.out.println("小球走过，并标识过的地图");
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 7; j++) {
                System.out.printf(map[i][j] + " ");
            }
            System.out.println();
        }

    }

    /**
     * 使用递归回溯来给小球找路
     *
     * @param map 表示地图
     * @param i   出发的行，这里约定为1
     * @param j   出发的列，这里约定为1
     * @return 如果找到通路，就返回true, 否则返回false
     * 如果小球能到map[6][5]，则说明通路找到
     * 约定：当map[i][j] 为0表示未走过，当为1时为墙
     * 2表示通路可以走，3表示该点已经走过，但是走不通
     * 在走迷宫时，需要确定一个策略（方法），下->右->上->左，如果
     * 该点走不通再回溯
     */
    public static boolean setWay(int[][] map, int i, int j) {
        if (map[6][5] == 2) {
            // 通路已经找到
            return true;
        } else {
            if (map[i][j] == 0) {
                // 如果当前这个点还没有走过
                // 按照策略玩一把
                map[i][j] = 2; // 假定该点是可以走通
                if (setWay(map, i + 1, j)) {
                    // 试试：在这个点向下走
                    return true;
                } else if (setWay(map, i, j + 1)) {
                    // 试试： 在这个点向右走
                    return true;
                } else if (setWay(map, i - 1, j)) {
                    // 试试： 在这个点向上走
                    return true;
                } else if (setWay(map, i - 1, j)) {
                    // 试试： 在这个点向左走
                    return true;
                } else {
                    // 说明该点是走不通，是死路
                    map[i][j] = 3;
                    return false;
                }
            } else {
                // 如果map[i][j]不为0,可能是1，2，3
                return false; // 2不要反复走
            }
        }
    }

    // 修改找路策略：改成上->右->下->左,可以看到路径不一样了
    public static boolean setWay2(int[][] map, int i, int j) {
        if (map[6][5] == 2) {
            // 通路已经找到
            return true;
        } else {
            if (map[i][j] == 0) {
                // 如果当前这个点还没有走过
                // 按照策略玩一把
                map[i][j] = 2; // 假定该点是可以走通
                if (setWay2(map, i - 1, j)) {
                    // 试试：在这个点向上走
                    return true;
                } else if (setWay2(map, i, j + 1)) {
                    // 试试： 在这个点向右走
                    return true;
                } else if (setWay2(map, i + 1, j)) {
                    // 试试： 在这个点向下走
                    return true;
                } else if (setWay2(map, i - 1, j)) {
                    // 试试： 在这个点向左走
                    return true;
                } else {
                    // 说明该点是走不通，是死路
                    map[i][j] = 3;
                    return false;
                }
            } else {
                // 如果map[i][j]不为0,可能是1，2，3
                return false; // 2不要反复走
            }
        }
    }
}
```

思考：如何找到最短路径：可以考虑策略穷举，将2的路径保存到集合中

### 八皇后Queen8

求共有多少种解法：不能在同一行，同一列，同一斜线

```java
public class Queen8 {
    // 先定一个max表示共有多少个皇后
    int max = 8;
    // 定义数组array,保存皇后放置位置的结果，比如arr = {0,4,7,5,2,6,1,3}
    int[] array = new int[max];
    int count = 0;

    public static void main(String[] args) {
        Queen8 queen8 = new Queen8();
        queen8.check(0);
        System.out.printf("一共有%d个解法\n", queen8.count);
    }

    /**
     * 编写一个方法，放置第n个皇后
     * check是每一次递归时，进入到check中都会有for循环
     */
    private void check(int n) {
        if (n == max) {
            // n==8，其实8个皇后就已经放好
            print();
            count++;
            return;
        }
        // 依次放入皇后，并判断是否冲突
        for (int i = 0; i < max; i++) {
            // 先把当前这个皇后n,放到该行的第1列
            array[n] = i;
            // 并判断当放置第n个皇后到i列时，是否冲突
            if (judge(n)) {
                // 不冲突，就接着放n+1个皇后
                check(n + 1);
            }
            // 如果冲突，就继续执行array[n] = i;即将第n个皇后，放置在本行的后移一个位置
        }
    }

    /**
     * 查看当我们放置第n个皇后，就去检测该皇后是否和前面民已经摆放的皇后冲突
     * n表示第n个皇后，n为索引
     */
    private boolean judge(int n) {
        for (int i = 0; i < n; i++) {
            // array[i]==array[n]  表示判断第n个皇后是否和前面的第i个皇后是否在同一列
            // Math.abs(n - i) == Math.abs(array[n] - array[i])
            // 表示第n个皇后是否与第i个皇后是否为同一斜线,纵差：横差 ==1
            // 判断是否在同一行，没有必要，n每次都在递增
            if (array[i] == array[n] || Math.abs(n - i) == Math.abs(array[n] - array[i])) {
                return false;
            }
        }
        return true;
    }

    // 写一个方法，可以将皇后摆放的位置输出
    private void print() {
        for (int i = 0; i < array.length; i++) {
            System.out.printf(array[i] + " ");
        }
        System.out.println();
    }

}
```

## 排序算法 sort algorithm

内部排序：只依靠内存完成

外部排序：内存+外部储存完成

### 时间复杂度 time complexity

事后统计法：1 程序要实际运行 2跟计算机硬件，软件相关

事前估算法：通过时间复杂度估算 ，O = omicron

#### 时间频度 

算法花费的时间与算法中语句的执行次数成正比例，语句越多，花费时间越多。

语句执行次数称为`语句频度`或`时间频度`,记为T(n)

```java
// 计算1-100和
public void cal() {
    int total = 0;
    int start = 1
    int end = 100;
    for (int i = start; i <= end; i++) {
        total += i;
    }
}

// 上面的时间频度为T(n)=n+1，n为循环次数，1为最后的判断

public void cal2() {
    int total = 0;
    int start = 1;
    int end = 100;
    total = (start + end) * end / 2;
}
// 这个的时间频度为T(n)=1
```

忽略常数项

T(n)=2n 与 T(n) = 2n+20 ,随n变大，越来越接近

忽略低次项

T(n)=2n^2 + 3n +20 与 T(n)=2n^2, 随n变大，越来越接近

忽略系数

T(n)=2n^2 + 3n +20 与 T(n)=5n^2+3n+20 ,随n变大，越来越固定比例



一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n->无穷大时，T(n)/f(n) 的极限值为不等于零的常数，则称f(n)是T(n)同数量级函数，记T(n)=O(f(n)),称

O(f(n))为算法的渐进时间复杂度，简称时间复杂度。



#### 计算时间复杂度的方法

用常数1代替运行时间中所有的加法常数项 T(n)=3n^2+7n+6 ---> T(n)=3n^2+7n+1

只保留最高阶 T(n)=3n^2+7n+1 ---> T(n)=3n^2

去除最高阶项的系数 T(n)=3n^2 ---> T(n)=n^2 ---> O(n^2)



常见的时间复杂度

常数阶O(1)

对数阶O(log2n) 2为底数，n为真数

线数阶O(n)

线性对数阶O(nlog2n)

平方阶O(n^2)

立方阶O(n^3)

k次方阶O(n^k)

指数阶O(2^n)

n的n次方O(n^n)

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226744.png)

平均时间复杂度

指所有可能的输入实列均以等概率出现的情况下，该算法的运行时间

最坏时间复杂度

最环情况下的时间复杂度，一般讨论的时间复杂度都是最坏时间复杂度

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226745.png)

### 空间复杂度 space complexity

空间复杂度指所耗费的存储空间，也是问题规模n的函数

算法分析时，主要讨论的是时间复杂度，用空间换时间



### 冒泡排序 bubble sorting

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226746.png)

```Java
public class BubbleSort {
    public static void main(String[] args) {
        int arr[] = {3, 9, -1, 10, -2};

        // 为了容易理解，我们把冒泡提成序的演变过程，给大空展示

        //  第一趟排序，就是将最大的数排在最后
        // 第一次相当于arr.length - 1次
        int temp = 0; // 临时变量
        for (int j = 0; j < arr.length - 1; j++) {
            // 如果前面的数比后面的数大，则交换
            if (arr[j] > arr[j + 1]) {
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }

        System.out.println("第一趟排序后的数组");
        System.out.println(Arrays.toString(arr));

        // 第二趟排序，我们将第二大的数排在倒数第二位
        // 第二趟相当于arr.length - 1 - 1次
        for (int j = 0; j < arr.length - 1 - 1; j++) {
            // 如果前面的数比后面的数大，则交换
            if (arr[j] > arr[j + 1]) {
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }

        System.out.println("第二趟排序后的数组");
        System.out.println(Arrays.toString(arr));


        // 第三趟排序，我们将第二大的数排在倒数第二位
        for (int j = 0; j < arr.length - 1 - 2; j++) {
            // 如果前面的数比后面的数大，则交换
            if (arr[j] > arr[j + 1]) {
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }

        System.out.println("第三趟排序后的数组");
        System.out.println(Arrays.toString(arr));

        // 第四趟排序，我们将第二大的数排在倒数第二位
        for (int j = 0; j < arr.length - 1 - 3; j++) {
            // 如果前面的数比后面的数大，则交换
            if (arr[j] > arr[j + 1]) {
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }

        System.out.println("第四趟排序后的数组");
        System.out.println(Arrays.toString(arr));
    }
}
```

根据上面总结成如下：

```java
public class BubbleSort {
    public static void main(String[] args) {
        int arr[] = {3, 9, -1, 10, -2};

        // 为了容易理解，我们把冒泡提成序的演变过程，给大空展示

        for (int i = 0; i < arr.length - 1; i++) {
            int temp = 0; // 临时变量
            for (int j = 0; j < arr.length - 1 - i; j++) {
                // 如果前面的数比后面的数大，则交换
                if (arr[j] > arr[j + 1]) {
                    temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }

            System.out.println("第" + (i + 1) + "趟排序后的数组");
            System.out.println(Arrays.toString(arr));
        }

    }
}
```

加入标志量优化：

```Java
public class BubbleSort {
    public static void main(String[] args) {
        int arr[] = {3, 9, -1, 10, -2};

        // 测试冒泡排序
        bubbleSort(arr);
    }

    // 将冒泡排序封装成一个方法
    public static void bubbleSort(int[] arr) {
        // 为了容易理解，我们把冒泡提成序的演变过程，给大空展示
        boolean flag = false; // 标识变量，表示是否进行过交换
        for (int i = 0; i < arr.length - 1; i++) {
            int temp = 0; // 临时变量
            for (int j = 0; j < arr.length - 1 - i; j++) {
                // 如果前面的数比后面的数大，则交换
                if (arr[j] > arr[j + 1]) {
                    flag = true;
                    temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
            if (flag == false) {
                // 说明在一趟排序中，一次交换都没有发生过，代表排序好了
                break;
            } else {
                flag = false; // 重置flag,进行下趟排序
                // 当然也可以放到第一层for循环内重置flag
            }

            System.out.println("第" + (i + 1) + "趟排序后的数组");
            System.out.println(Arrays.toString(arr));
        }

    }
}
```

## 查找算法

### 线性查找

```java
public class SequenceSearch {

    public static void main(String[] args) {
        // 数组不要求有序
        int[] arr = {1, 9, 11, -1, 34, 89};

        int index = seqSearch(arr, 11);
        if (index == -1) {
            System.out.println("没有查找到");
        } else {
            System.out.println("找到，下标为=" + index);
        }

    }

    public static int seqSearch(int[] arr, int value) {
        // 线性查找是一个个比对，发现有相同值，就返回下标
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == value) {
                return i;
            }
        }
        return -1;
    }
}
```

### 二分查找/折半查找  递归方式 Binary Search Recursion

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226747.png)

```java
public class BinarySearch {

    public static void main(String[] args) {
        // 注意二分查找的前提是该数组是有序的
        int arr[] = {1, 8, 10, 89, 1000, 1234};
        // 测试
        int resIndex = binarySearch(arr, 0, arr.length - 1, 88);
        System.out.println("resIndex = " + resIndex);
    }

    /**
     * 二分查找
     *
     * @param arr       数组
     * @param left      左边的索引
     * @param right     右边的索引
     * @param findValue 查找的值
     * @return 如果找到就返回下标，如果没有就返回-1
     */
    public static int binarySearch(int[] arr, int left, int right, int findValue) {
        if (left > right) {
            // 说明递归整个数组，但是没有找到
            return -1;
        }
        int mid = (left + right) / 2;
        int midValue = arr[mid];
        if (findValue > midValue) {
            return binarySearch(arr, left + 1, right, findValue);
        } else if (findValue < midValue) {
            return binarySearch(arr, left, right - 1, findValue);
        } else {
            return mid;
        }
    }
}
```

课后思考题： {1,8,10,89,1000,1000,1000,1234}，1000为查找值,当一个有序数组存在多个相同值时，返回所有相同查找值的下标

```java
public class BinarySearch {

    public static void main(String[] args) {
        // 注意二分查找的前提是该数组是有序的
        int arr[] = {1, 8, 10, 89, 1000, 1234};
        // 测试
        int resIndex = binarySearch(arr, 0, arr.length - 1, 88);
        System.out.println("resIndex = " + resIndex);
    }

    /**
     * 完成一个课后思考题
     * 课后思考题： {1,8,10,89,1000,1000,1000,1234}，1000为查找值
     * 当一个有序数组存在多个相同值时，返回所有相同查找值的下标
     * <p>
     * 思路：
     * 1。在找到mid值时，不要马上返回
     * 2。向mid索引值的左边扫描，将所有满足1000的元素的下标，加入到集合中
     * 3。向mid索引值的右边扫描，将所有满足1000的元素的下标，加入到集合中
     */
    public static List<Integer> binarySearch2(int[] arr, int left, int right, int findValue) {
        if (left > right) {
            // 说明递归整个数组，但是没有找到
            return new ArrayList<>();
        }
        int mid = (left + right) / 2;
        int midValue = arr[mid];
        if (findValue > midValue) {
            return binarySearch2(arr, left + 1, right, findValue);
        } else if (findValue < midValue) {
            return binarySearch2(arr, left, right - 1, findValue);
        } else {
            List<Integer> list = new ArrayList<>();
            // 放入左边的值
            int temp = mid - 1;
            while (true) {
                if (temp < 0 || arr[temp] != findValue) {
                    break;
                }
                // 否则，就temp放到集合中
                list.add(temp);
                temp -= 1;
            }
            // 放入右过的值
            temp = mid + 1;
            while (true) {
                if (temp > arr.length - 1 || arr[temp] != findValue) {
                    break;
                }
                // 否则，将temp加入集合中
                list.add(temp);
                temp += 1;
            }
            //  返回最终记录的索引
            return list;
        }
    }
}
```



### 二分查找非递归 Binary Search No Recursion

```java
public class BinarySearchNoRecursion {

    public static void main(String[] args) {
        int[] arr = {1, 3, 8, 10, 11, 67, 100};
        int index = binarySearch(arr, 1);
        System.out.println("index = " + index);
    }

    /**
     * 二分查找的非递归实现
     *
     * @param arr    待查找的数组,arr是升序排序
     * @param target 需要查找的数
     * @return 返回对应的下标，-1表示没有找到
     */
    public static int binarySearch(int[] arr, int target) {
        int left = 0;
        int right = arr.length - 1;
        // 注意：这里是<=100
        while (left <= right) {
            int mid = (left + right) / 2;
            if (arr[mid] == target) {
                return mid;
            } else if (arr[mid] > target) {
                // 向左边查找
                right = mid - 1;
            } else {
                // 向右边查找
                left = mid + 1;
            }
        }
        return -1;
    }
}
```



## 哈希表(散列表) HashTable

哈希表的任务

1 尾部新增

2 根据id删除

3 显示

4 HashTable的散列函数

```java
public class MyHashTableDemo {

    public static void main(String[] args) {
        // 创建哈希表
        MyHashTable myHashTable = new MyHashTable(7);

        // 写一个简单的菜单
        String key = "";
        Scanner scanner = new Scanner(System.in);
        while (true) {
            System.out.println("add: 添加雇员");
            System.out.println("list: 显示雇员");
            System.out.println("find: 查找雇员");
            System.out.println("exit: 退出系统");

            key = scanner.next();

            switch (key) {
                case "add":
                    System.out.println("输入id:");
                    int id = scanner.nextInt();
                    System.out.println("输入名字");
                    String name = scanner.next();
                    //  创建一个雇员
                    Employee employee = new Employee(id, name);
                    myHashTable.add(employee);
                    break;
                case "list":
                    myHashTable.list();
                    break;
                case "find":
                    System.out.println("请输入id: ");
                    id = scanner.nextInt();
                    myHashTable.findEmployeeById(id);
                    break;
                case "exit":
                    scanner.close();
                    System.exit(-1);
                default:
                    break;
            }
        }
    }
}

// 创建哈希表管理多条链表
class MyHashTable {

    private EmpLinkedList[] empLinkedListArray;

    private int size;

    public MyHashTable(int size) {
        // 初始化数组
        this.size = size;
        empLinkedListArray = new EmpLinkedList[size];
        // 不要忘记，这时要分别初始化每一个链表
        for (int i = 0; i < size; i++) {
            empLinkedListArray[i] = new EmpLinkedList();
        }
    }

    // 添加雇员
    public void add(Employee employee) {
        // 根据员工的id，得到该员工应当添加到哪条链表
        int index = hashFun(employee.getId());
        // 将employee加入到对应的链表中
        empLinkedListArray[index].add(employee);
    }

    // 遍历所有的链表，就是遍历hashTable
    public void list() {
        for (int i = 0; i < size; i++) {
            empLinkedListArray[i].list(i);
        }
    }

    // 编写散列函数,使用取模法
    public int hashFun(int id) {
        return id % size;
    }

    // 根据id查找
    public void findEmployeeById(int id) {
        // 使用散列函数确定到哪条链表查找
        int index = hashFun(id);
        Employee employee = empLinkedListArray[index].findEmployee(id);
        if (employee != null) {
            // 找到
            System.out.printf("在第%d条找到雇员，id=%d\n", index, id);
        } else {
            System.out.println("哈希表中没有找到");
        }
    }

    // 根据id删除雇员
    public void deleteById(int id) {
        int index = hashFun(id);
        boolean b = empLinkedListArray[index].deleteById(id);
        if (b) {
            System.out.println("删除成功");
        } else {
            System.out.println("删除失败");
        }
    }
}

// 表示有一个雇员
@Data
@NoArgsConstructor
@AllArgsConstructor
class Employee {

    private int id;

    private String name;

    private Employee next;

    public Employee(int id, String name) {
        this.id = id;
        this.name = name;
    }

}

// 创建EmpLinkedList，表示链表
class EmpLinkedList {

    // 头指针，指向第一个Emp，因此我们这个链表的head是直接指向第一个Emp
    private Employee head; // 默认为null

    // 添加雇员
    // 1 假定雇员，id是自增长，即id的分配总是从小到大
    // 因此我们直接将新雇员直接加入到本链表的最后即可
    public void add(Employee employee) {
        // 如查是添加第一个雇员
        if (head == null) {
            head = employee;
            return;
        }
        // 如果不是第一个雇员，则使用一个辅助的指针，帮助定位到最后
        Employee curEmp = head;
        while (true) {
            if (curEmp.getNext() == null) {
                break;
            }
            curEmp = curEmp.getNext();
        }
        // 退出时直接将emp加入链表
        curEmp.setNext(employee);
    }

    // 遍历链表雇员的信息
    public void list(int index) {
        if (head == null) {
            System.out.println("第" + index + "链表为空");
            return;
        }
        System.out.println("第" + index + "链表的信息为：");
        Employee curEmp = head;
        while (true) {
            System.out.printf("=> id=%d name=%s\t", curEmp.getId(), curEmp.getName());
            if (curEmp.getNext() == null) {
                break;
            }
            curEmp = curEmp.getNext();
        }
        System.out.println();
    }

    // 根据id查找雇员
    public Employee findEmployee(int id) {
        // 判断链表是否为空
        if (head == null) {
            System.out.println("链表为空");
            return null;
        }
        // 辅助指针
        Employee curEmp = head;
        while (true) {
            if (curEmp.getId() == id) {
                break;
            }
            // 说明当前链表没有找到
            if (curEmp.getNext() == null) {
                curEmp = null;
                break;// 要退出
            }
            curEmp = curEmp.getNext();
        }
        return curEmp;
    }

    // 根据id删除雇员
    public boolean deleteById(int id) {
        if (head == null) {
            System.out.println("链表为空");
            return false;
        }
        Employee curEmp = head;
        // 单独判断头节点
        if (head.getId() == id) {
            head = (head.getNext());
            return true;
        }
        while (curEmp.getNext() != null) {
            if (curEmp.getNext().getId() == id) {
                // 找到
                curEmp.setNext(curEmp.getNext().getNext());
                return true;
            }
        }
        return false;
    }


}
```

## 树 Tree 基础部分

数组：根据索引访问快，根据二分查找快，但删除、新增效率差

链表：查找慢，但删除、新增效率好

树：查找快，删除、新增效率好

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226748.png)

### 二叉树 binary tree

#### 基本概念

二叉树：每个节点最多只能有两个子节点，子节点分为左子节点，右子节点

满二叉树：所有的子节点都在最后一层，并且节点总数为2^n  -1, n为层数，从1开始。

参考[ 等比数列知识](https://baike.baidu.com/item/%E7%AD%89%E6%AF%94%E6%95%B0%E5%88%97%E6%B1%82%E5%92%8C%E5%85%AC%E5%BC%8F/7527367?fr=aladdin) 这里根据等比数列前n项求和可得2^n - 1;

完全二叉树：如果二叉树的所有的叶子节点都在最后一层或倒数第二层，而且最后一层的叶子节点在左边边续，倒数第二层的叶子节点在右边连续。

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226749.png)

#### 遍历方式 : preorder,infix order,postorder

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226750.png)

1. 前序遍历: 先输出父节点，再遍历左子树和右子树
2. 中序遍历: 先遍历左子树，再输出父节点，再遍历右子树
3. 后序遍历: 先遍历左子树，再遍历右子树，最后输出父节点

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226751.png)

```java
public class BinaryTreeDemo {
    public static void main(String[] args) {
        // 先需要创建一颗二叉树
        MyBinaryTree myBinaryTree = new MyBinaryTree();
        // 创建所需的节点
        HeroNode root = new HeroNode(1, "宋江");
        HeroNode node2 = new HeroNode(2, "吴用");
        HeroNode node3 = new HeroNode(3, "卢俊义");
        HeroNode node4 = new HeroNode(4, "林冲");

        // 说明，我们先手动创建该二叉树，后面我们学习递归的方式创建二叉树
        root.setLeft(node2);
        root.setRight(node3);
        node3.setRight(node4);
        myBinaryTree.setRoot(root);

        // 测试前序
        System.out.println("前序遍历为：");
        myBinaryTree.preOrder(); // 1,2,3,4

        // 测试中序
        System.out.println("中序遍历为：");
        myBinaryTree.infixOrder(); // 2,1,3,4

        // 测试后序
        System.out.println("后序遍历为：");
        myBinaryTree.postOrder(); // 2,4,3,1
    }
}

// 定义一个BinaryTree

class MyBinaryTree {

    private HeroNode root;

    public void setRoot(HeroNode root) {
        this.root = root;
    }

    // 前序遍历
    public void preOrder() {
        if (this.root != null) {
            this.root.preOrder();
        } else {
            System.out.println("二叉树为空不能遍历");
        }
    }

    // 中序遍历
    public void infixOrder() {
        if (this.root != null) {
            this.root.infixOrder();
        } else {
            System.out.println("二叉树为空不能遍历");
        }
    }

    // 后序遍历
    public void postOrder() {
        if (this.root != null) {
            this.root.postOrder();
        } else {
            System.out.println("二叉树为空不能遍历");
        }
    }
}

// 先创建英雄节点
@Data
@AllArgsConstructor
@NoArgsConstructor
class HeroNode {

    private int no;

    private String name;

    private HeroNode left;

    private HeroNode right;

    public HeroNode(int no, String name) {
        this.no = no;
        this.name = name;
    }

    @Override
    public String toString() {
        return "HeroNode [no=" + no + ", name=" + name + "]";
    }

    // 编写前序遍历的方法
    public void preOrder() {
        System.out.println(this); // 先输出父节点
        // 递归向左子树前序遍历
        if (this.left != null) {
            this.left.preOrder();
        }
        // 递归向右子树前序遍历
        if (this.right != null) {
            this.right.preOrder();
        }
    }

    //  中序遍历
    public void infixOrder() {
        // 递归向左子树中序遍历
        if (this.left != null) {
            this.left.infixOrder();
        }
        // 输入父结点
        System.out.println(this);
        // 递归向右子树中序遍历
        if (this.right != null) {
            this.right.infixOrder();
        }
    }

    // 后序遍历
    public void postOrder() {
        // 递归向左子树后序遍历
        if (this.left != null) {
            this.left.postOrder();
        }
        // 递归向右子树后序遍历
        if (this.right != null) {
            this.right.postOrder();
        }
        // 输入父结点
        System.out.println(this);
    }
}
```

#### 查找方式：preorder,inorder,postorder

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226752.png)

```java
public class BinaryTreeDemo {
    public static void main(String[] args) {
        // 先需要创建一颗二叉树
        MyBinaryTree myBinaryTree = new MyBinaryTree();
        // 创建所需的节点
        HeroNode root = new HeroNode(1, "宋江");
        HeroNode node2 = new HeroNode(2, "吴用");
        HeroNode node3 = new HeroNode(3, "卢俊义");
        HeroNode node4 = new HeroNode(4, "林冲");

        // 说明，我们先手动创建该二叉树，后面我们学习递归的方式创建二叉树
        root.setLeft(node2);
        root.setRight(node3);
        node3.setRight(node4);
        myBinaryTree.setRoot(root);

        // 测试前序
        System.out.println("前序遍历为：");
        myBinaryTree.preOrder(); // 1,2,3,4

        // 测试中序
        System.out.println("中序遍历为：");
        myBinaryTree.infixOrder(); // 2,1,3,4

        // 测试后序
        System.out.println("后序遍历为：");
        myBinaryTree.postOrder(); // 2,4,3,1

        // 前序遍历查找
        System.out.println("前序遍历查找");
        HeroNode resNode = myBinaryTree.preorderSearch(4);
        if (resNode != null) {
            System.out.println("前序遍历查找 找到了" + resNode);
        } else {
            System.out.println("没有找到");
        }
    }
}

// 定义一个BinaryTree

class MyBinaryTree {

    private HeroNode root;

    public void setRoot(HeroNode root) {
        this.root = root;
    }

    // 前序遍历
    public void preOrder() {
        if (this.root != null) {
            this.root.preOrder();
        } else {
            System.out.println("二叉树为空不能遍历");
        }
    }

    // 中序遍历
    public void infixOrder() {
        if (this.root != null) {
            this.root.infixOrder();
        } else {
            System.out.println("二叉树为空不能遍历");
        }
    }

    // 后序遍历
    public void postOrder() {
        if (this.root != null) {
            this.root.postOrder();
        } else {
            System.out.println("二叉树为空不能遍历");
        }
    }

    // 前序遍历查找
    public HeroNode preorderSearch(int no) {
        if (root != null) {
            return root.preorderSearch(no);
        }
        return null;
    }

    // 中序遍历查找
    public HeroNode inorderSearch(int no) {
        if (root != null) {
            return root.inorderSearch(no);
        }
        return null;
    }

    // 后序遍历查找
    public HeroNode postorderSearch(int no) {
        if (root != null) {
            return root.postorderSearch(no);
        }
        return null;
    }
}

// 先创建英雄节点
@Data
@AllArgsConstructor
@NoArgsConstructor
class HeroNode {

    private int no;

    private String name;

    private HeroNode left;

    private HeroNode right;

    public HeroNode(int no, String name) {
        this.no = no;
        this.name = name;
    }

    @Override
    public String toString() {
        return "HeroNode [no=" + no + ", name=" + name + "]";
    }

    // 编写前序遍历的方法
    public void preOrder() {
        System.out.println(this); // 先输出父节点
        // 递归向左子树前序遍历
        if (this.left != null) {
            this.left.preOrder();
        }
        // 递归向右子树前序遍历
        if (this.right != null) {
            this.right.preOrder();
        }
    }

    //  中序遍历
    public void infixOrder() {
        // 递归向左子树中序遍历
        if (this.left != null) {
            this.left.infixOrder();
        }
        // 输入父结点
        System.out.println(this);
        // 递归向右子树中序遍历
        if (this.right != null) {
            this.right.infixOrder();
        }
    }

    // 后序遍历
    public void postOrder() {
        // 递归向左子树后序遍历
        if (this.left != null) {
            this.left.postOrder();
        }
        // 递归向右子树后序遍历
        if (this.right != null) {
            this.right.postOrder();
        }
        // 输入父结点
        System.out.println(this);
    }


    /**
     * 前序遍历查找
     *
     * @param no 查找编号
     * @return 如果找到返回对应的引用，没有找到返回null
     */
    public HeroNode preorderSearch(int no) {
        // 比较当前结点是不是
        if (this.no == no) {
            return this;
        }
        // 左递归
        HeroNode resNode = null;
        if (this.left != null) {
            resNode = this.left.preorderSearch(no);
        }
        if (resNode != null) {
            // 说明我们左子树查找到
            return resNode;
        }
        // 右递归
        if (this.right != null) {
            resNode = this.right.preorderSearch(no);
        }
        return resNode;
    }

    // 中序遍历查找
    public HeroNode inorderSearch(int no) {
        HeroNode resNode = null;
        // 左递归
        if (this.left != null) {
            resNode = this.left.inorderSearch(no);
        }
        if (resNode != null) {
            return resNode;
        }
        // 判断当前
        if (this.no == no) {
            return this;
        }
        //  右递归
        if (this.right != null) {
            resNode = this.right.inorderSearch(no);
        }
        return resNode;
    }

    // 后序遍历查找
    public HeroNode postorderSearch(int no) {
        // 左递归
        HeroNode resNode = null;
        if (this.left != null) {
            resNode = this.left.postorderSearch(no);
        }
        if (resNode != null) {
            return resNode;
        }
        // 右递归
        if (this.right != null) {
            resNode = this.right.postorderSearch(no);
        }
        if (resNode != null) {
            return resNode;
        }
        // 判断当前
        if (this.no == no) {
            return this;
        }
        return null;
    }
}
```

删除节点

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226753.png)

```java
public class BinaryTreeDemo {
    public static void main(String[] args) {
        // 先需要创建一颗二叉树
        MyBinaryTree myBinaryTree = new MyBinaryTree();
        // 创建所需的节点
        HeroNode root = new HeroNode(1, "宋江");
        HeroNode node2 = new HeroNode(2, "吴用");
        HeroNode node3 = new HeroNode(3, "卢俊义");
        HeroNode node4 = new HeroNode(4, "林冲");

        // 说明，我们先手动创建该二叉树，后面我们学习递归的方式创建二叉树
        root.setLeft(node2);
        root.setRight(node3);
        node3.setRight(node4);
        myBinaryTree.setRoot(root);

        // 测试前序
        System.out.println("前序遍历为：");
        myBinaryTree.preOrder(); // 1,2,3,4

        // 测试中序
        System.out.println("中序遍历为：");
        myBinaryTree.infixOrder(); // 2,1,3,4

        // 测试后序
        System.out.println("后序遍历为：");
        myBinaryTree.postOrder(); // 2,4,3,1

        // 前序遍历查找
        System.out.println("前序遍历查找");
        HeroNode resNode = myBinaryTree.preorderSearch(4);
        if (resNode != null) {
            System.out.println("前序遍历查找 找到了" + resNode);
        } else {
            System.out.println("没有找到");
        }

        // 测试删除
        System.out.println("删除前：前序遍历");
        myBinaryTree.preOrder(); // 1,2,3,4

        // 删除4号
        myBinaryTree.deleteNo(4);

        System.out.println("删除后：前序遍历");
        myBinaryTree.preOrder(); // 1,2,3
    }
}

// 定义一个BinaryTree
class MyBinaryTree {

    private HeroNode root;

    public void setRoot(HeroNode root) {
        this.root = root;
    }

    // 前序遍历
    public void preOrder() {
        if (this.root != null) {
            this.root.preOrder();
        } else {
            System.out.println("二叉树为空不能遍历");
        }
    }

    // 中序遍历
    public void infixOrder() {
        if (this.root != null) {
            this.root.infixOrder();
        } else {
            System.out.println("二叉树为空不能遍历");
        }
    }

    // 后序遍历
    public void postOrder() {
        if (this.root != null) {
            this.root.postOrder();
        } else {
            System.out.println("二叉树为空不能遍历");
        }
    }

    // 前序遍历查找
    public HeroNode preorderSearch(int no) {
        if (root != null) {
            return root.preorderSearch(no);
        }
        return null;
    }

    // 中序遍历查找
    public HeroNode inorderSearch(int no) {
        if (root != null) {
            return root.inorderSearch(no);
        }
        return null;
    }

    // 后序遍历查找
    public HeroNode postorderSearch(int no) {
        if (root != null) {
            return root.postorderSearch(no);
        }
        return null;
    }

    // 删除节点
    public void deleteNo(int no) {
        // 如果root 不为null
        if (root != null) {
            // 如果只有一个root节点，判断是不是就要删除的节点
            if (root.getNo() == no) {
                root = null;
            } else {
                this.root.deleteNode(no);
            }
        } else {
            System.out.println("空树，不能删除");
        }
    }
}

// 先创建英雄节点
@Data
@AllArgsConstructor
@NoArgsConstructor
class HeroNode {

    private int no;

    private String name;

    private HeroNode left;

    private HeroNode right;

    public HeroNode(int no, String name) {
        this.no = no;
        this.name = name;
    }

    @Override
    public String toString() {
        return "HeroNode [no=" + no + ", name=" + name + "]";
    }

    // 编写前序遍历的方法
    public void preOrder() {
        System.out.println(this); // 先输出父节点
        // 递归向左子树前序遍历
        if (this.left != null) {
            this.left.preOrder();
        }
        // 递归向右子树前序遍历
        if (this.right != null) {
            this.right.preOrder();
        }
    }

    //  中序遍历
    public void infixOrder() {
        // 递归向左子树中序遍历
        if (this.left != null) {
            this.left.infixOrder();
        }
        // 输入父结点
        System.out.println(this);
        // 递归向右子树中序遍历
        if (this.right != null) {
            this.right.infixOrder();
        }
    }

    // 后序遍历
    public void postOrder() {
        // 递归向左子树后序遍历
        if (this.left != null) {
            this.left.postOrder();
        }
        // 递归向右子树后序遍历
        if (this.right != null) {
            this.right.postOrder();
        }
        // 输入父结点
        System.out.println(this);
    }


    /**
     * 前序遍历查找
     *
     * @param no 查找编号
     * @return 如果找到返回对应的引用，没有找到返回null
     */
    public HeroNode preorderSearch(int no) {
        // 比较当前结点是不是
        if (this.no == no) {
            return this;
        }
        // 左递归
        HeroNode resNode = null;
        if (this.left != null) {
            resNode = this.left.preorderSearch(no);
        }
        if (resNode != null) {
            // 说明我们左子树查找到
            return resNode;
        }
        // 右递归
        if (this.right != null) {
            resNode = this.right.preorderSearch(no);
        }
        return resNode;
    }

    // 中序遍历查找
    public HeroNode inorderSearch(int no) {
        HeroNode resNode = null;
        // 左递归
        if (this.left != null) {
            resNode = this.left.inorderSearch(no);
        }
        if (resNode != null) {
            return resNode;
        }
        // 判断当前
        if (this.no == no) {
            return this;
        }
        //  右递归
        if (this.right != null) {
            resNode = this.right.inorderSearch(no);
        }
        return resNode;
    }

    // 后序遍历查找
    public HeroNode postorderSearch(int no) {
        // 左递归
        HeroNode resNode = null;
        if (this.left != null) {
            resNode = this.left.postorderSearch(no);
        }
        if (resNode != null) {
            return resNode;
        }
        // 右递归
        if (this.right != null) {
            resNode = this.right.postorderSearch(no);
        }
        if (resNode != null) {
            return resNode;
        }
        // 判断当前
        if (this.no == no) {
            return this;
        }
        return null;
    }

    /**
     * 递归删除节点
     * 如果是叶子节点，就删除节点
     * 如果非叶子节点，则删除子树
     */
    public void deleteNode(int no) {
        // 这里进入，root不为null
        // 先看左边的，符合就删除
        if (this.left != null && this.left.getNo() == no) {
            this.left = null;
            return;
        }
        // 再看右边的，符合就删除
        if (this.right != null && this.right.getNo() == no) {
            this.right = null;
            return;
        }
        //  这时，我们就需要向左子树进行递归删除
        if (this.left != null) {
            this.left.deleteNode(no);
        }
        // 再向右子树进行递归删除
        if (this.right != null) {
            this.right.deleteNode(no);
        }
    }
}
```

思考题：如果要删除的节点是非叶子节点，现在我们不希望将该非叶子节点为根节点的子树删除，需要指定规则，假定规则如下：

1 如果该非叶子节点A只有一个子节点B，则子节点B替代节点A

2 如果该非叶子节点A 有左子节点B和右子节点C, 则让左子节点B替代节点A

#### 顺序存储二叉树

数组存储方式与树的存储的方式转换

要求：在遍历数组arr时，仍然可以以前序遍历，中序遍历和后序遍历的方式完成结点的遍历

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226754.png)



```java
public class ArrayBinaryTreeDemo {
    public static void main(String[] args) {
        // 完全二叉树对应的数组
        int[] arr = {1, 2, 3, 4, 5, 6, 7};
        // 创建一个ArrayBinaryTree
        ArrayBinaryTree arrayBinaryTree = new ArrayBinaryTree(arr);
        // 根节点对应的下标为0
        arrayBinaryTree.preOrder(0); // 1,2,4,5,3,6,7
        // 调用重载方法
        arrayBinaryTree.preorder();
    }


}

// 编写一个ArrayBinaryTree,实现顺序存储二叉树遍历
class ArrayBinaryTree {

    private int[] arr; // 存储数据结点的数组

    public ArrayBinaryTree(int[] arr) {
        this.arr = arr;
    }

    // 重载preorder
    public void preorder() {
        this.preOrder(0);
    }

    // 编写一个方法，完成顺序存储二叉树的前序遍历
    public void preOrder(int index) {
        // 如果数组为空，或者arr.length == 0
        if (arr == null || arr.length == 0) {
            System.out.println("数组为空,不能遍历");
        }
        // 处理当前
        System.out.println(arr[index]);
        // 向左递归
        if (index * 2 + 1 < arr.length) {
            preOrder(index * 2 + 1);
        }
        // 向右递归
        if (index * 2 + 2 < arr.length) {
            preOrder(index * 2 + 2);
        }
    }
}
```

思考：中序遍历，后序遍历？

```java
public class ArrayBinaryTreeDemo {
    public static void main(String[] args) {
        // 完全二叉树对应的数组
        int[] arr = {1, 2, 3, 4, 5, 6, 7};
        // 创建一个ArrayBinaryTree
        ArrayBinaryTree arrayBinaryTree = new ArrayBinaryTree(arr);
        // 根节点对应的下标为0
        arrayBinaryTree.preorder(); // 1,2,4,5,3,6,7
    }


}

// 编写一个ArrayBinaryTree,实现顺序存储二叉树遍历
class ArrayBinaryTree {

    private int[] arr; // 存储数据结点的数组

    public ArrayBinaryTree(int[] arr) {
        this.arr = arr;
    }

    // 重载preorder
    public void preorder() {
        this.preOrder(0);
    }

    // 编写一个方法，完成顺序存储二叉树的前序遍历
    public void preOrder(int index) {
        // 如果数组为空，或者arr.length == 0
        if (arr == null || arr.length == 0) {
            System.out.println("数组为空,不能遍历");
        }
        // 处理当前
        System.out.println(arr[index]);
        // 向左递归
        if (index * 2 + 1 < arr.length) {
            preOrder(index * 2 + 1);
        }
        // 向右递归
        if (index * 2 + 2 < arr.length) {
            preOrder(index * 2 + 2);
        }
    }

    // 中序遍历
    public void inorder(int index) {
        // 先判断成员变量数组
        if (arr == null || arr.length == 0) {
            return;
        }
        // 递归左子树
        if (index * 2 + 1 < arr.length) {
            inorder(index * 2 + 1);
        }
        // 当前节点
        System.out.println(arr[index]);
        // 递归右子树
        if (index * 2 + 2 < arr.length) {
            inorder(index * 2 + 2);
        }
    }

    // 后序遍历
    public void postorder(int index) {
        // 判断数组
        if (arr == null || arr.length == 0) {
            return;
        }
        // 先左递归
        if (index * 2 + 1 < arr.length) {
            postorder(index * 2 + 1);
        }
        // 右递归
        if (index * 2 + 2 < arr.length) {
            postorder(index * 2 + 2);
        }
        // 最后处理当前节点
        System.out.println(arr[index]);
    }
}
```

#### 线索化二叉树 threaded binary tree

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226755.png)

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226756.png)

```java
public class ThreadedBinaryTreeDemo {
    public static void main(String[] args) {
        // 测试一把中序线索二叉树的功能
        HeroNode root = new HeroNode(1, "tom");
        HeroNode node2 = new HeroNode(3, "jack");
        HeroNode node3 = new HeroNode(6, "smith");
        HeroNode node4 = new HeroNode(8, "marry");
        HeroNode node5 = new HeroNode(10, "king");
        HeroNode node6 = new HeroNode(14, "dim");

        // 二叉树，后面学递归创建，现在手动创建
        root.setLeft(node2);
        root.setRight(node3);
        node2.setLeft(node4);
        node2.setRight(node5);
        node3.setLeft(node6);

        // 测试线索化
        ThreadedBinaryTree threadedBinaryTree = new ThreadedBinaryTree();
        threadedBinaryTree.setRoot(root);

        threadedBinaryTree.threadedNodes();

        // 测试，以10号节点测试
        HeroNode lefNode = node5.getLeft();
        HeroNode rightNode = node5.getRight();
        System.out.println("10号节点的前驱节点：" + lefNode);
        System.out.println("10号节点的后驱节点：" + rightNode);

    }
}

// 定义一个ThreadedBinaryTree
class ThreadedBinaryTree {

    private HeroNode root;

    // 为了实现线索化，需要创建指向当前节点的前驱结点的指针
    // 在递归进行线索化时，pre总是保留前一个节点
    private HeroNode pre = null;

    public void setRoot(HeroNode root) {
        this.root = root;
    }

    // 重载threadedNodes方法
    public void threadedNodes() {
        this.threadedNodes(root);
    }

    /**
     * 编写对二叉树进行中序线索化的方法
     *
     * @param node 就是当前需要进行线索化的节点
     */
    public void threadedNodes(HeroNode node) {
        // 如果node == null,不能线索化
        if (node == null) {
            return;
        }
        // 先线索化左子树
        threadedNodes(node.getLeft());
        // 再线索化当前节点
        // 先处理当前节点的前驱节点
        if (node.getLeft() == null) {
            // 让当前节点的左指针指向前驱节点
            node.setLeft(pre);
            // 修改当前节点的左指针类型，指向前驱节点
            node.setLeftType(1);
        }
        // 处理后继节点
        if (pre != null && pre.getRight() == null) {
            // 让前驱节点的右指针指向当前节点
            pre.setRight(node);
            // 修改前驱节点的右指针类型
            pre.setRightType(1);
        }
        // 每处理一个节点，让当前节点是下一个节点的前驱节点
        pre = node;
        // 最后线索化右子树
        threadedNodes(node.getRight());
    }

    // 前序遍历
    public void preOrder() {
        if (this.root != null) {
            this.root.preOrder();
        } else {
            System.out.println("二叉树为空不能遍历");
        }
    }

    // 中序遍历
    public void infixOrder() {
        if (this.root != null) {
            this.root.infixOrder();
        } else {
            System.out.println("二叉树为空不能遍历");
        }
    }

    // 后序遍历
    public void postOrder() {
        if (this.root != null) {
            this.root.postOrder();
        } else {
            System.out.println("二叉树为空不能遍历");
        }
    }

    // 前序遍历查找
    public HeroNode preorderSearch(int no) {
        if (root != null) {
            return root.preorderSearch(no);
        }
        return null;
    }

    // 中序遍历查找
    public HeroNode inorderSearch(int no) {
        if (root != null) {
            return root.inorderSearch(no);
        }
        return null;
    }

    // 后序遍历查找
    public HeroNode postorderSearch(int no) {
        if (root != null) {
            return root.postorderSearch(no);
        }
        return null;
    }

    // 删除节点
    public void deleteNo(int no) {
        // 如果root 不为null
        if (root != null) {
            // 如果只有一个root节点，判断是不是就要删除的节点
            if (root.getNo() == no) {
                root = null;
            } else {
                this.root.deleteNode(no);
            }
        } else {
            System.out.println("空树，不能删除");
        }
    }
}

@Data
@AllArgsConstructor
@NoArgsConstructor
class HeroNode {

    private int no;

    private String name;

    private HeroNode left;

    private HeroNode right;

    // 如果leftType == 0,表示指向的是左子树
    // 如果1则表示前驱节点
    private int leftType;

    // 如果leftType == 0,表示指向的是右子树
    // 如果1则表示后继节点
    private int rightType;

    public HeroNode(int no, String name) {
        this.no = no;
        this.name = name;
    }

    @Override
    public String toString() {
        return "HeroNode [no=" + no + ", name=" + name + "]";
    }

    // 编写前序遍历的方法
    public void preOrder() {
        System.out.println(this); // 先输出父节点
        // 递归向左子树前序遍历
        if (this.left != null) {
            this.left.preOrder();
        }
        // 递归向右子树前序遍历
        if (this.right != null) {
            this.right.preOrder();
        }
    }

    //  中序遍历
    public void infixOrder() {
        // 递归向左子树中序遍历
        if (this.left != null) {
            this.left.infixOrder();
        }
        // 输入父结点
        System.out.println(this);
        // 递归向右子树中序遍历
        if (this.right != null) {
            this.right.infixOrder();
        }
    }

    // 后序遍历
    public void postOrder() {
        // 递归向左子树后序遍历
        if (this.left != null) {
            this.left.postOrder();
        }
        // 递归向右子树后序遍历
        if (this.right != null) {
            this.right.postOrder();
        }
        // 输入父结点
        System.out.println(this);
    }


    /**
     * 前序遍历查找
     *
     * @param no 查找编号
     * @return 如果找到返回对应的引用，没有找到返回null
     */
    public HeroNode preorderSearch(int no) {
        // 比较当前结点是不是
        if (this.no == no) {
            return this;
        }
        // 左递归
        HeroNode resNode = null;
        if (this.left != null) {
            resNode = this.left.preorderSearch(no);
        }
        if (resNode != null) {
            // 说明我们左子树查找到
            return resNode;
        }
        // 右递归
        if (this.right != null) {
            resNode = this.right.preorderSearch(no);
        }
        return resNode;
    }

    // 中序遍历查找
    public HeroNode inorderSearch(int no) {
        HeroNode resNode = null;
        // 左递归
        if (this.left != null) {
            resNode = this.left.inorderSearch(no);
        }
        if (resNode != null) {
            return resNode;
        }
        // 判断当前
        if (this.no == no) {
            return this;
        }
        //  右递归
        if (this.right != null) {
            resNode = this.right.inorderSearch(no);
        }
        return resNode;
    }

    // 后序遍历查找
    public HeroNode postorderSearch(int no) {
        // 左递归
        HeroNode resNode = null;
        if (this.left != null) {
            resNode = this.left.postorderSearch(no);
        }
        if (resNode != null) {
            return resNode;
        }
        // 右递归
        if (this.right != null) {
            resNode = this.right.postorderSearch(no);
        }
        if (resNode != null) {
            return resNode;
        }
        // 判断当前
        if (this.no == no) {
            return this;
        }
        return null;
    }

    /**
     * 递归删除节点
     * 如果是叶子节点，就删除节点
     * 如果非叶子节点，则删除子树
     */
    public void deleteNode(int no) {
        // 这里进入，root不为null
        // 先看左边的，符合就删除
        if (this.left != null && this.left.getNo() == no) {
            this.left = null;
            return;
        }
        // 再看右边的，符合就删除
        if (this.right != null && this.right.getNo() == no) {
            this.right = null;
            return;
        }
        //  这时，我们就需要向左子树进行递归删除
        if (this.left != null) {
            this.left.deleteNode(no);
        }
        // 再向右子树进行递归删除
        if (this.right != null) {
            this.right.deleteNode(no);
        }
    }
}
```

#### 遍历线索化二叉树

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226757.png)

```java
public class ThreadedBinaryTreeDemo {
    public static void main(String[] args) {
        // 测试一把中序线索二叉树的功能
        HeroNode root = new HeroNode(1, "tom");
        HeroNode node2 = new HeroNode(3, "jack");
        HeroNode node3 = new HeroNode(6, "smith");
        HeroNode node4 = new HeroNode(8, "marry");
        HeroNode node5 = new HeroNode(10, "king");
        HeroNode node6 = new HeroNode(14, "dim");

        // 二叉树，后面学递归创建，现在手动创建
        root.setLeft(node2);
        root.setRight(node3);
        node2.setLeft(node4);
        node2.setRight(node5);
        node3.setLeft(node6);

        // 测试线索化
        ThreadedBinaryTree threadedBinaryTree = new ThreadedBinaryTree();
        threadedBinaryTree.setRoot(root);

        threadedBinaryTree.threadedNodes();

        // 测试，以10号节点测试
        HeroNode lefNode = node5.getLeft();
        HeroNode rightNode = node5.getRight();
        System.out.println("10号节点的前驱节点：" + lefNode);
        System.out.println("10号节点的后驱节点：" + rightNode);

        // 当线索化二叉树后，不能再使用原来的遍历的方法，
        // 因为原来左右指针为null不递归的，现在递归了
        System.out.println("线索化的方式遍历 线索化的二叉树");
        threadedBinaryTree.threadedList(); // 8,3,10,1,14,6

    }
}

// 定义一个ThreadedBinaryTree
class ThreadedBinaryTree {

    private HeroNode root;

    // 为了实现线索化，需要创建指向当前节点的前驱结点的指针
    // 在递归进行线索化时，pre总是保留前一个节点
    private HeroNode pre = null;

    public void setRoot(HeroNode root) {
        this.root = root;
    }

    // 遍历线索化二叉树的方法
    public void threadedList() {
        // 定义一个变量，存储当前遍历的节点，从root开始
        HeroNode node = root;
        while (node != null) {
            // 循环找到leftType==1的节点，第一个找到就是8节点
            // 后面随着遍历的变化，因为当leftType==1时，
            // 说明该节点是按照线索化处理后的节点
            while (node.getLeftType() == 0) {
                node = node.getLeft();
            }
            // 跳出循环时，node指向遍历的第一个元素，就是leftType==1
            // 打印当前这个节点
            System.out.println(node);
            // 如果当前结点右指针指向的是后继节点，就一直输出
            while (node.getRightType() == 1) {
                // 获取到当前节点的后继节点
                node = node.getRight();
                System.out.println(node);
            }
            // 替换这个的节点
            node = node.getRight();
        }
    }

    // 重载threadedNodes方法
    public void threadedNodes() {
        this.threadedNodes(root);
    }

    /**
     * 编写对二叉树进行中序线索化的方法
     *
     * @param node 就是当前需要进行线索化的节点
     */
    public void threadedNodes(HeroNode node) {
        // 如果node == null,不能线索化
        if (node == null) {
            return;
        }
        // 先线索化左子树
        threadedNodes(node.getLeft());
        // 再线索化当前节点
        // 先处理当前节点的前驱节点
        if (node.getLeft() == null) {
            // 让当前节点的左指针指向前驱节点
            node.setLeft(pre);
            // 修改当前节点的左指针类型，指向前驱节点
            node.setLeftType(1);
        }
        // 处理后继节点
        if (pre != null && pre.getRight() == null) {
            // 让前驱节点的右指针指向当前节点
            pre.setRight(node);
            // 修改前驱节点的右指针类型
            pre.setRightType(1);
        }
        // 每处理一个节点，让当前节点是下一个节点的前驱节点
        pre = node;
        // 最后线索化右子树
        threadedNodes(node.getRight());
    }

    // 前序遍历
    public void preOrder() {
        if (this.root != null) {
            this.root.preOrder();
        } else {
            System.out.println("二叉树为空不能遍历");
        }
    }

    // 中序遍历
    public void infixOrder() {
        if (this.root != null) {
            this.root.infixOrder();
        } else {
            System.out.println("二叉树为空不能遍历");
        }
    }

    // 后序遍历
    public void postOrder() {
        if (this.root != null) {
            this.root.postOrder();
        } else {
            System.out.println("二叉树为空不能遍历");
        }
    }

    // 前序遍历查找
    public HeroNode preorderSearch(int no) {
        if (root != null) {
            return root.preorderSearch(no);
        }
        return null;
    }

    // 中序遍历查找
    public HeroNode inorderSearch(int no) {
        if (root != null) {
            return root.inorderSearch(no);
        }
        return null;
    }

    // 后序遍历查找
    public HeroNode postorderSearch(int no) {
        if (root != null) {
            return root.postorderSearch(no);
        }
        return null;
    }

    // 删除节点
    public void deleteNo(int no) {
        // 如果root 不为null
        if (root != null) {
            // 如果只有一个root节点，判断是不是就要删除的节点
            if (root.getNo() == no) {
                root = null;
            } else {
                this.root.deleteNode(no);
            }
        } else {
            System.out.println("空树，不能删除");
        }
    }
}

@Data
@AllArgsConstructor
@NoArgsConstructor
class HeroNode {

    private int no;

    private String name;

    private HeroNode left;

    private HeroNode right;

    // 如果leftType == 0,表示指向的是左子树
    // 如果1则表示前驱节点
    private int leftType;

    // 如果leftType == 0,表示指向的是右子树
    // 如果1则表示后继节点
    private int rightType;

    public HeroNode(int no, String name) {
        this.no = no;
        this.name = name;
    }

    @Override
    public String toString() {
        return "HeroNode [no=" + no + ", name=" + name + "]";
    }

    // 编写前序遍历的方法
    public void preOrder() {
        System.out.println(this); // 先输出父节点
        // 递归向左子树前序遍历
        if (this.left != null) {
            this.left.preOrder();
        }
        // 递归向右子树前序遍历
        if (this.right != null) {
            this.right.preOrder();
        }
    }

    //  中序遍历
    public void infixOrder() {
        // 递归向左子树中序遍历
        if (this.left != null) {
            this.left.infixOrder();
        }
        // 输入父结点
        System.out.println(this);
        // 递归向右子树中序遍历
        if (this.right != null) {
            this.right.infixOrder();
        }
    }

    // 后序遍历
    public void postOrder() {
        // 递归向左子树后序遍历
        if (this.left != null) {
            this.left.postOrder();
        }
        // 递归向右子树后序遍历
        if (this.right != null) {
            this.right.postOrder();
        }
        // 输入父结点
        System.out.println(this);
    }


    /**
     * 前序遍历查找
     *
     * @param no 查找编号
     * @return 如果找到返回对应的引用，没有找到返回null
     */
    public HeroNode preorderSearch(int no) {
        // 比较当前结点是不是
        if (this.no == no) {
            return this;
        }
        // 左递归
        HeroNode resNode = null;
        if (this.left != null) {
            resNode = this.left.preorderSearch(no);
        }
        if (resNode != null) {
            // 说明我们左子树查找到
            return resNode;
        }
        // 右递归
        if (this.right != null) {
            resNode = this.right.preorderSearch(no);
        }
        return resNode;
    }

    // 中序遍历查找
    public HeroNode inorderSearch(int no) {
        HeroNode resNode = null;
        // 左递归
        if (this.left != null) {
            resNode = this.left.inorderSearch(no);
        }
        if (resNode != null) {
            return resNode;
        }
        // 判断当前
        if (this.no == no) {
            return this;
        }
        //  右递归
        if (this.right != null) {
            resNode = this.right.inorderSearch(no);
        }
        return resNode;
    }

    // 后序遍历查找
    public HeroNode postorderSearch(int no) {
        // 左递归
        HeroNode resNode = null;
        if (this.left != null) {
            resNode = this.left.postorderSearch(no);
        }
        if (resNode != null) {
            return resNode;
        }
        // 右递归
        if (this.right != null) {
            resNode = this.right.postorderSearch(no);
        }
        if (resNode != null) {
            return resNode;
        }
        // 判断当前
        if (this.no == no) {
            return this;
        }
        return null;
    }

    /**
     * 递归删除节点
     * 如果是叶子节点，就删除节点
     * 如果非叶子节点，则删除子树
     */
    public void deleteNode(int no) {
        // 这里进入，root不为null
        // 先看左边的，符合就删除
        if (this.left != null && this.left.getNo() == no) {
            this.left = null;
            return;
        }
        // 再看右边的，符合就删除
        if (this.right != null && this.right.getNo() == no) {
            this.right = null;
            return;
        }
        //  这时，我们就需要向左子树进行递归删除
        if (this.left != null) {
            this.left.deleteNode(no);
        }
        // 再向右子树进行递归删除
        if (this.right != null) {
            this.right.deleteNode(no);
        }
    }
}
```

课后题：

已完成中序线索化及其遍历，现在能完成前序线索化及其遍历？后序线索化及其遍历？

#### 堆排序 Heap Sort

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226758.png)

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226759.png)

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226760.png)

堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。

堆是具有以下性质的`完全二叉树`：
 1、每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆。
 2、每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆
 3、注意 : 没有要求结点的左孩子的值和右孩子的值的大小关系。



堆排序的基本思想

将待排序序列构造成一个大顶堆

构造完后的整个序列的最大值就是堆顶的根节点

将其与末尾元素进行交换，此时末尾就为最大值

然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了

可以看到在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到一个有序序列了

大顶堆和小顶堆的代码本质区别的公式 ：这边案例写的是大顶堆(升序)
 大顶堆：arr[i] >= arr[2i+1] && arr[i] >= arr[2i+2]
 小顶堆：arr[i] <= arr[2i+1] && arr[i] <= arr[2i+2]



详细案例分解：

数组：{4,6,8,5,9}

步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)
（1）假设给定无序序列结构如下：

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226761.png)

（2）此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length/2-1=5/2-1=1，也就是下面的数值为6的结点），从左至右，从下至上进行调整

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226762.png)

（3）找到第二个非叶节点4，由于[4,9,8]中9元素最大，4和9交换

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226763.png)

（4）这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中6最大，交换4和6

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226764.png)

（5）此时，我们就将一个无序序列构造成了一个大顶堆

步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换
 （1）将堆顶元素9和末尾元素4进行交换

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226765.png)

（2）重新调整结构，使其继续满足堆定义

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226766.png)

（3）再将堆顶元素 8 与末尾元素 5 进行交换，得到第二大元素 8

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226767.png)

（4）后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226768.png)

步骤总结：
 1).将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆
 2).将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端
 3).重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序



```java
public class HeapSort {
    public static void main(String[] args) {
        // 要求将数组进行升序排列
        // 升序->大顶堆
        // 降序->小顶堆
        int[] arr = {4, 6, 8, 5, 9};
        heapSort(arr);
    }

    // 编写一个堆排序的方法
    public static void heapSort(int[] arr) {
        System.out.println("堆排序!");

        // 分步完成
//        adjustHeap(arr, 1, arr.length);
//        System.out.println("第1次" + Arrays.toString(arr)); // 4,9,8,5,6
//
//        adjustHeap(arr,0,arr.length);
//        System.out.println("第2次" + Arrays.toString(arr)); // 9.6,8,5,4

        // 完成我们最终代码
        // 1 将无序序列构建成一个堆，根据升序降序序列选择大顶堆或小顶堆
        for (int i = arr.length / 2 - 1; i >= 0; i--) {
            adjustHeap(arr, i, arr.length);
        }


        // 2 将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端
        // 3 重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，
        // 反复执行调整+交换步骤，直到整个序列有序
        int temp;
        for (int j = arr.length - 1; j > 0; j--) {
            // 交换
            temp = arr[j];
            arr[j] = arr[0];
            arr[0] = temp;
            adjustHeap(arr, 0, j);
        }

        System.out.println("数组：" + Arrays.toString(arr));

    }


    /**
     * 将一个数组(二叉树),调整成一个大顶堆
     * 完成将以i指向的非叶子节点的树调整成大顶堆
     * 举例，{4,6,8,5,9} => i=5/2-1=>i=1=>{4,9,8,5,6}
     * 如果我们再次调用，i=0 得到{9,6,8,5,4}
     *
     * @param arr    待调整的数组
     * @param i      表示非叶子节点在数组的索引
     * @param length 表示对多少个元素进行调整，length是在逐渐减少
     */
    public static void adjustHeap(int[] arr, int i, int length) {
        int temp = arr[i];// 先取出当前无素的值，保存到temp
        // 开始调整
        // 说明: k = i*2+1，表示k是i的左子节点
        // k = k*2+1，表示k的左子节点
        for (int k = (i * 2 + 1); k < length; k = k * 2 + 1) {
            if (k + 1 < length && arr[k] < arr[k + 1]) {
                // 说明左子节点值小于右子节点值
                k++;// k指向右子节点
            }
            if (arr[k] > temp) {
                // 如果子节点的最大值 > 父节点的值
                arr[i] = arr[k]; // 将较大的值赋给当前结点
                i = k; // i指向k,继续循环比较
            } else {
                break; // !
            }
        }
        // 当for循环结束后，我们已经将以i为父结点的树的最大值，放在了最顶上(局部)
        arr[i] = temp;// 将temp值放到调整后的位置

    }
}
```

思考：如何用堆排序实现降序排列

只要修改adjustHeap中的左右比较与父子比较的大于小于号就可以。

```java
public class HeapSort {
    public static void main(String[] args) {
        int[] arr = {4, 6, 8, 5, 9};

        // 调整成小顶堆
        for (int i = arr.length / 2 - 1; i >= 0; i--) {
            adjustHeap(arr, i, arr.length);
        }

        // 交换+调整
        for (int j = arr.length - 1; j > 0; j--) {
            int temp = arr[j];
            arr[j] = arr[0];
            arr[0] = temp;
            adjustHeap(arr, 0, j);
        }

        System.out.println(Arrays.toString(arr));

    }


    public static void adjustHeap(int[] arr, int i, int length) {
        int temp = arr[i];
        for (int k = i * 2 + 1; k < length; k = k * 2 + 1) {
            if (k + 1 < length && arr[k] > arr[k + 1]) {
                k++; // k指向最小的节点
            }
            if (arr[k] < temp) {
                arr[i] = arr[k];
                i = k; // i指向需调整的子树的根节点
            } else {
                break;
            }
        }
        arr[i] = temp;
    }
}
```

#### 赫夫曼树 Huffman Tree



基本介绍：

1、给定n个权值作为n个`叶子结点`，构造一棵二叉树，若该树的带权路径长度(wpl)达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree), 还有的书翻译为霍夫曼树。
 2、赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近。



路径和路径长度：

 （1）在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。
 （2）一个路径通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为 L-1

结点的权及带权路径长度：

 （1）若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。
 （2）结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226769.png)





树的带权路径长度：

 树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL(weighted path length) ,权值越大的结点离根结点越近的二叉树才是最优二叉树。

WPL最小的就是赫夫曼树

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226770.png)



赫夫曼树创建思路分解:

从小到大进行排序, 将每一个数据(每个数据都是一个节点) ， 每个节点可以看成是一颗最简单的二叉树。

取出根节点权值最小的两颗二叉树

组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和

再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复  1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树



以{13, 7, 8, 3, 29, 6, 1}这个为例：

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226771.png)

```java
public class HuffmanTree {

    public static void main(String[] args) {
        int[] arr = {13, 7, 8, 3, 29, 6, 1};
        Node huffmanTree = createHuffmanTree(arr);
        preorder(huffmanTree);
    }

    // 创建Huffman树的方法
    public static Node createHuffmanTree(int[] arr) {
        // 第一步为了操作方便，arr->list
        List<Node> nodes = new ArrayList<>();
        for (int value : arr) {
            nodes.add(new Node(value));
        }

        // 我们处理的过程是个循环的过程

        while (nodes.size() > 1) {
            // 排序,从小到大
            Collections.sort(nodes);

            // 取出根节点权值最小的两棵树
            Node leftNode = nodes.get(0);
            Node rightNode = nodes.get(1);

            // 构建一棵新的二叉树
            Node parent = new Node(leftNode.value + rightNode.value);
            parent.left = leftNode;
            parent.right = rightNode;

            // 从ArrayList中删除处理过的二叉树
            nodes.remove(leftNode);
            nodes.remove(rightNode);

            // 将parent加入nodes
            nodes.add(parent);
        }

        // 返回Huffman树
        return nodes.get(0);
    }

    // 前序遍历
    public static void preorder(Node root) {
        if (root != null) {
            root.preorder();
        } else {
            System.out.println("树空");
        }
    }
}

// 创建节点类
// 为了让Node对象支持排序，让实现Comparable接口
@Data
class Node implements Comparable<Node> {

    int value; // 权值

    Node left; // 指向左子节点

    Node right; // 指向右子节点

    public Node(int value) {
        this.value = value;
    }

    public String toString() {
        return "Node[value=" + value + "]";
    }

    @Override
    public int compareTo(Node o) {
        // 自然排序
        return this.value - o.value;
    }

    // 前序遍历
    public void preorder() {
        // 根，左，右
        System.out.println(this);
        if (this.left != null) {
            this.left.preorder();
        }
        if (this.right != null) {
            this.right.preorder();
        }
    }
}
```

#### 二叉排序树 Binary Sort Tree

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226772.png)

##### 创建(添加)与遍历

```java
public class BinarySortTreeDemo {

    public static void main(String[] args) {
        int[] arr = {7, 3, 10, 12, 5, 1, 9};

        BinarySortTree binarySortTree = new BinarySortTree();
        // 循环添加节点到二叉排序树
        for (int i = 0; i < arr.length; i++) {
            binarySortTree.add(new Node(arr[i]));
        }
        // 中序遍历,可以看到二叉排序树中序输出刚好是排好序的
        binarySortTree.inorder(); // 1,3,5,7,9,10,12
    }

}

// 创建二叉排序树
class BinarySortTree {

    private Node root;

    public void add(Node node) {
        if (root == null) {
            // 如果node为空，直接node作为root
            root = node;
        } else {
            root.add(node);
        }
    }

    public void inorder() {
        if (root != null) {
            root.inorder();
        } else {
            System.out.println("树空");
        }
    }
}


// 创建Node节点
class Node {

    int value;

    Node left;

    Node right;

    public Node(int value) {
        this.value = value;
    }

    // 添加节点的方法
    // 递归添加，满足二叉排序树的要求
    public void add(Node node) {
        if (node == null) {
            return;
        }
        // 判断传入结点的值与当前节点的关系
        if (node.value < this.value) {
            // 如果当前节点的左子节点为null
            if (this.left == null) {
                this.left = node;
            } else {
                this.left.add(node);
            }
        } else {
            // 添加的结点的值大于或等于当前结点的值
            if (this.right == null) {
                this.right = node;
            } else {
                this.right.add(node);
            }
        }
    }

    // 中序遍历
    public void inorder() {
        if (this.left != null) {
            this.left.inorder();
        }
        System.out.println(this);
        if (this.right != null) {
            this.right.inorder();
        }
    }
}
```

##### 二叉排序树的删除

> 1. 主要分为三种情况：
>    1、删除叶子节点(既无根)
>    2、删除只有一颗子树的节点
>    3、删除两个子树的节点



![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226773.png)

 删除叶子节点
 (1) 需先去找到要删除的结点  targetNode
 (2)  找到targetNode 的 父结点 parent
 (3)  确定 targetNode 是 parent的左子结点 还是右子结点
 (4)  根据前面的情况来对应删除
 左子结点 parent.left = null
 右子结点 parent.right = null



删除只有一颗子树的节点
 (1) 需先去找到要删除的结点  targetNode
 (2)  找到targetNode 的 父结点 parent
 (3) 确定targetNode 的子结点是左子结点还是右子结点
 (4) targetNode 是 parent 的左子结点还是右子结点
 (5) 如果targetNode 有左子结点
 5-1 如果 targetNode 是 parent 的左子结点
 parent.left = targetNode.left;
 5-2  如果 targetNode 是 parent 的右子结点
 parent.right = targetNode.left;
 (6) 如果targetNode 有右子结点
 6-1 如果 targetNode 是 parent 的左子结点
 parent.left = targetNode.right;
 6-2 如果 targetNode 是 parent 的右子结点
 parent.right = targetNode.right



删除两个子树节点
 (1) 需先去找到要删除的结点  targetNode
 (2)  找到targetNode 的 父结点 parent
 (3)  从targetNode 的右子树找到最小的结点
 注：若处理的是左子树，则找到最大的节点
 (4) 用一个临时变量，将 最小结点的值保存 temp = 11
 (5)  删除该最小结点
 (6)  targetNode.value = temp



```java
public class BinarySortTreeDemo {

    public static void main(String[] args) {
        int[] arr = {7, 3, 10, 12, 5, 1, 9};

        BinarySortTree binarySortTree = new BinarySortTree();
        // 循环添加节点到二叉排序树
        for (int i = 0; i < arr.length; i++) {
            binarySortTree.add(new Node(arr[i]));
        }
        // 中序遍历,可以看到二叉排序树中序输出刚好是排好序的
        binarySortTree.inorder(); // 1,3,5,7,9,10,12

        // 测试删除结点(叶子结点，一棵子树的结点，两棵子树的结点)
        binarySortTree.delNode(12);
        binarySortTree.inorder();
    }

}

// 创建二叉排序树
class BinarySortTree {

    private Node root;

    // 查找要删除的节点
    public Node search(int value) {
        if (root == null) {
            return null;
        } else {
            return root.search(value);
        }
    }

    // 查找要删除的节点的父节点
    public Node searchParent(int value) {
        if (root == null) {
            return null;
        } else {
            return root.searchParent(value);
        }
    }

    /**
     * 返回以node为根节点的二叉排序树的最小结值
     * 删除node为根结点的二叉排序树的最小结点
     *
     * @param node 传入的结点，当做二叉排序树的根节点
     * @return 返回以node为根节点的二叉排序树的最小结值
     */
    public int delRightTreeMin(Node node) {
        Node target = node;
        // 循环的查找左节点，就会找到最小值
        while (target.left != null) {
            target = target.left;
        }
        // 跳出循环时，target指向最小结点
        delNode(target.value);
        return target.value;
    }

    // 删除节点
    public void delNode(int value) {
        if (root == null) {
            return;
        } else {
            // 需要先找到要删除的节点
            Node targetNode = search(value);
            // 如果没有找到要删除的节点
            if (targetNode == null) {
                return;
            }
            // 如果我们发现当前这棵二叉排序树只有一个结点
            if (root.left == null && root.right == null) {
                root = null;
                return;
            }
            //  查找父节点
            Node parent = searchParent(value);
            // 如果要删除的结点是叶子结点
            if (targetNode.left == null && targetNode.right == null) {
                // 判断targetNode 是父结点的左子结点还是 右子结点
                if (parent.left != null && parent.left.value == value) {
                    parent.left = null;
                } else if (parent.right != null && parent.right.value == value) {
                    parent.right = null;
                }
            } else if (targetNode.left != null && targetNode.right != null) {
                int minValue = delRightTreeMin(targetNode.right);
                targetNode.value = minValue;
            } else {
                // 删除只有一棵子树的节点
                // 如果要删除的结点有左子结点
                if (targetNode.left != null) {
                    if (parent != null) {
                        // 如果targetNode 是 parent 的左子结点
                        if (parent.left.value == value) {
                            parent.left = targetNode.left;
                        } else {
                            // 如果targetNode 是 parent 的右子结点
                            parent.right = targetNode.left;
                        }
                    } else {
                        root = targetNode.left;
                    }
                } else {
                    // 如果要删除的结点有右子结点
                    if (parent != null) {
                        // 如果targetNode 是 parent 的左子结点
                        if (parent.left.value == value) {
                            parent.left = targetNode.right;
                        } else {
                            // 如果targetNode 是 parent 的右子结点
                            parent.right = targetNode.right;
                        }
                    } else {
                        root = targetNode.right;
                    }
                }
            }

        }
    }

    public void add(Node node) {
        if (root == null) {
            // 如果node为空，直接node作为root
            root = node;
        } else {
            root.add(node);
        }
    }

    public void inorder() {
        if (root != null) {
            root.inorder();
        } else {
            System.out.println("树空");
        }
    }
}


// 创建Node节点
class Node {

    int value;

    Node left;

    Node right;

    public Node(int value) {
        this.value = value;
    }

    /**
     * 查找要删除的节点
     *
     * @param value 希望删除结点的值
     * @return 如果找到返回该结点，否则返回null
     */
    public Node search(int value) {
        if (value == this.value) {
            return this;
        } else if (value < this.value) {
            if (this.left == null) {
                return null;
            }
            return this.left.search(value);
        } else {
            // 如果查找的值不小于当彰的结点值，向右子树递归查找
            if (this.right == null) {
                return null;
            }
            return this.right.search(value);
        }
    }

    /**
     * 查找要删除节点的父结点
     *
     * @param value 要找到的值
     * @return 返回的要删除的结点的父结点，如果没有就返回null
     */
    public Node searchParent(int value) {
        // 如果当前结点就是要删除的结点的父结点
        if ((this.left != null && this.left.value == value)
                || (this.right != null && this.right.value == value)) {
            return this;
        } else {
            // 如果查找的值小于当前结点的值，并且当前结点的左子结点不为空
            if (value < this.value && this.left != null) {
                return this.left.searchParent(value);
            } else if (value >= this.value && this.right != null) {
                return this.right.searchParent(value); // 向右子树递归查找
            } else {
                return null; // 没有找到父结点
            }
        }
    }

    // 添加节点的方法
    // 递归添加，满足二叉排序树的要求
    public void add(Node node) {
        if (node == null) {
            return;
        }
        // 判断传入结点的值与当前节点的关系
        if (node.value < this.value) {
            // 如果当前节点的左子节点为null
            if (this.left == null) {
                this.left = node;
            } else {
                this.left.add(node);
            }
        } else {
            // 添加的结点的值大于或等于当前结点的值
            if (this.right == null) {
                this.right = node;
            } else {
                this.right.add(node);
            }
        }
    }

    // 中序遍历
    public void inorder() {
        if (this.left != null) {
            this.left.inorder();
        }
        System.out.println(this);
        if (this.right != null) {
            this.right.inorder();
        }
    }


    public String toString() {
        return "Node[value=" + this.value + "]";
    }
}
```



思考：当前，删除有两棵子树的节点，查找了右子树的最小值。请考虑查找左子树的最大值并完成



## 图 graph

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226774.png)

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226775.png)

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226776.png)

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226777.png)



### 图的快速入门

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226778.png)

### 图的遍历

### 深度优先搜索 Depth First Search

深度优先遍历，从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点， 可以这样理解：每次都在访问完当前结点后首先访问当前结点的第一个邻接结点。

我们可以看到，这样的访问策略是优先往纵向挖掘深入，而不是对一个结点的所有邻接结点进行横向访问。

显然，深度优先搜索是一个递归的过程



算法步骤:

1. 访问初始结点v，并标记结点v为已访问。
2. 查找结点v的第一个邻接结点w。
3. 若w存在，则继续执行第4步，如果w不存在，则回到第1步，将从v的下一个结点继续。
4. 若w未被访问，对w进行深度优先遍历递归（即把w当做另一个v【后移】，然后进行步骤123）。
5. 若w已被访问，查找结点v的w邻接结点的下一个邻接结点，转到步骤3。



```java
public class Graph {

    // 存储顶点的集合
    private List<String> vertexList;

    // 存储图对应的邻接矩阵
    private int[][] edges;

    // 表示边的数目
    private int numOfEdges;

    // 定义一个数组boolean[],记录某个结点是否被访问
    private boolean[] isVisited;


    public static void main(String[] args) {
        // 测试一把图是否创建ok
        int n = 5; // 结点的个数
        String vertexValue[] = {"A", "B", "C", "D", "E"};
        // 创建图对象
        Graph graph = new Graph(n);
        for (String value : vertexValue) {
            graph.insertVertex(value);
        }

        // 添加边
        // A-B A-C B-C B-D B-E
        graph.insertEdge(0, 1, 1);
        graph.insertEdge(0, 2, 1);
        graph.insertEdge(1, 2, 1);
        graph.insertEdge(1, 3, 1);
        graph.insertEdge(1, 4, 1);

        // 展示图
        graph.showGraph();

        // 测试dfs
        graph.dfs();
    }

    /**
     * 得到第一个邻接结点的下标
     */
    public int getFirstNeighbor(int index) {
        for (int i = 0; i < vertexList.size(); i++) {
            if (edges[index][i] > 0) {
                return i;
            }
        }
        return -1;
    }

    /**
     * 根据前一个邻接结点的下标来获取下一个邻接节点
     */
    public int getNextNeighbor(int v1, int v2) {
        for (int i = v2 + 1; i < vertexList.size(); i++) {
            if (edges[v1][i] > 0) {
                return i;
            }
        }
        return -1;
    }

    /**
     * 深度优先遍历算法
     *
     * @param isVisited
     * @param i
     */
    private void dfs(boolean[] isVisited, int i) {
        // 首先访问该节点
        System.out.print(getValueByIndex(i) + "->");
        // 将该节点设置为已访问
        isVisited[i] = true;
        // 查找节点的第一个邻接节点
        int w = getFirstNeighbor(i);
        while (w != -1) {
            // 说明有邻接节点
            if (!isVisited[w]) {
                dfs(isVisited, w);
            }
            // 如果w已经被访问过
            w = getNextNeighbor(i, w);
        }
    }

    // 对dfs进行一个重载,遍历所有的结点并进行dfs
    public void dfs() {
        // 遍历所有的结点并进行dfs
        for (int i = 0; i < getNumOfVertex(); i++) {
            if (!isVisited[i]) {
                dfs(isVisited, i);
            }
        }
    }

    // 构造器
    public Graph(int n) {
        // 初始化邻接矩阵与顶点集合
        edges = new int[n][n];
        vertexList = new ArrayList<>(n);
        numOfEdges = 0; //  边不清楚多少条
        isVisited = new boolean[n];
    }

    /**
     * 插入顶点vertex
     */
    public void insertVertex(String vertex) {
        vertexList.add(vertex);
    }

    /**
     * 添加边
     *
     * @param v1     v1表示点的下标，即第几个顶点
     * @param v2     v2表示点的下标，即第几个顶点
     * @param weight 1表示直接连通，0表示不能直接连通
     */
    public void insertEdge(int v1, int v2, int weight) {
        edges[v1][v2] = weight;
        edges[v2][v1] = weight;
        numOfEdges++;
    }

    /**
     * 返回顶点的数目
     */
    public int getNumOfVertex() {
        return vertexList.size();
    }

    /**
     * 得到边的数目
     */
    public int getNumOfEdges() {
        return this.numOfEdges;
    }

    /**
     * 返回顶点i对应的数据
     */
    public String getValueByIndex(int i) {
        return vertexList.get(i);
    }

    /**
     * 返回v1,v2的权值
     */
    public int getWeight(int v1, int v2) {
        return edges[v1][v2];
    }

    /**
     * 显示图的邻接矩阵
     */
    public void showGraph() {
        for (int[] link : edges) {
            System.out.println(Arrays.toString(link));
        }
    }
}
```



### 广度优先搜索 Broad First Search

基本思想:

1. 图的广度优先搜索(Broad First Search) 。
2. 类似于一个分层搜索的过程，广度优先遍历需要使用一个队列以保持访问过的结点的顺序，以便按这个顺序来访问这些结点的邻接结点



算法步骤:

1. 访问初始结点v并标记结点v为已访问。
2. 结点v入队列
3. 当队列非空时，继续执行，否则算法结束。
4. 出队列，取得队头结点u。
5. 查找结点u的第一个邻接结点w。
6. 若结点u的邻接结点w不存在，则转到步骤3；否则循环执行以下三个步骤：
    6.1 若结点w尚未被访问，则访问结点w并标记为已访问。
    6.2 结点w入队列
    6.3 查找结点u的继w邻接结点后的下一个邻接结点w，转到步骤6。



```java
public class Graph {

    // 存储顶点的集合
    private List<String> vertexList;

    // 存储图对应的邻接矩阵
    private int[][] edges;

    // 表示边的数目
    private int numOfEdges;

    // 定义一个数组boolean[],记录某个结点是否被访问
    private boolean[] isVisited;


    public static void main(String[] args) {
        // 测试一把图是否创建ok
        int n = 5; // 结点的个数
        String vertexValue[] = {"A", "B", "C", "D", "E"};
        // 创建图对象
        Graph graph = new Graph(n);
        for (String value : vertexValue) {
            graph.insertVertex(value);
        }

        // 添加边
        // A-B A-C B-C B-D B-E
        graph.insertEdge(0, 1, 1);
        graph.insertEdge(0, 2, 1);
        graph.insertEdge(1, 2, 1);
        graph.insertEdge(1, 3, 1);
        graph.insertEdge(1, 4, 1);

        // 展示图
        graph.showGraph();

        // 测试dfs
        // graph.dfs();

        // 测试bfs
        graph.bfs();
    }

    /**
     * 得到第一个邻接结点的下标
     */
    public int getFirstNeighbor(int index) {
        for (int i = 0; i < vertexList.size(); i++) {
            if (edges[index][i] > 0) {
                return i;
            }
        }
        return -1;
    }

    /**
     * 根据前一个邻接结点的下标来获取下一个邻接节点
     */
    public int getNextNeighbor(int v1, int v2) {
        for (int i = v2 + 1; i < vertexList.size(); i++) {
            if (edges[v1][i] > 0) {
                return i;
            }
        }
        return -1;
    }

    /**
     * 深度优先遍历算法
     *
     * @param isVisited
     * @param i
     */
    private void dfs(boolean[] isVisited, int i) {
        // 首先访问该节点
        System.out.print(getValueByIndex(i) + "->");
        // 将该节点设置为已访问
        isVisited[i] = true;
        // 查找节点的第一个邻接节点
        int w = getFirstNeighbor(i);
        while (w != -1) {
            // 说明有邻接节点
            if (!isVisited[w]) {
                dfs(isVisited, w);
            }
            // 如果w已经被访问过
            w = getNextNeighbor(i, w);
        }
    }


    // 对dfs进行一个重载,遍历所有的结点并进行dfs
    public void dfs() {
        // 遍历所有的结点并进行dfs
        for (int i = 0; i < getNumOfVertex(); i++) {
            if (!isVisited[i]) {
                dfs(isVisited, i);
            }
        }
    }

    // 对一个结点进行广度优先遍历的方法
    private void bfs(boolean[] isVisited, int i) {
        int u; // 表示队列头对应结点的下标
        int w;  // 邻接结点w
        // 队列，记录结点访问的顺序
        LinkedList<Integer> queue = new LinkedList<>();
        // 访问结点
        System.out.print(getValueByIndex(i) + "->");
        // 标记为已访问
        isVisited[i] = true;
        // 将结点加入队列
        queue.addLast(i);
        while (!queue.isEmpty()) {
            // 取出队列的头
            u = queue.removeFirst();
            // 取出第一个邻接结点的下标w
            w = getFirstNeighbor(u);
            while (w != -1) {
                // 找到
                // 是否访问过
                if (!isVisited[w]) {
                    System.out.print(getValueByIndex(w) + "->");
                    // 标记已访问
                    isVisited[w] = true;
                    // 入队
                    queue.addLast(w);
                }
                // 以u为行，找w后面的下一个邻接点
                w = getNextNeighbor(u, w);
            }
        }
    }

    // 遍历所有的结点，都进行广度优先搜索
    public void bfs() {
        for (int i = 0; i < vertexList.size(); i++) {
            if (!isVisited[i]) {
                bfs(isVisited, i);
            }
        }
    }

    // 构造器
    public Graph(int n) {
        // 初始化邻接矩阵与顶点集合
        edges = new int[n][n];
        vertexList = new ArrayList<>(n);
        numOfEdges = 0; //  边不清楚多少条
        isVisited = new boolean[n];
    }

    /**
     * 插入顶点vertex
     */
    public void insertVertex(String vertex) {
        vertexList.add(vertex);
    }

    /**
     * 添加边
     *
     * @param v1     v1表示点的下标，即第几个顶点
     * @param v2     v2表示点的下标，即第几个顶点
     * @param weight 1表示直接连通，0表示不能直接连通
     */
    public void insertEdge(int v1, int v2, int weight) {
        edges[v1][v2] = weight;
        edges[v2][v1] = weight;
        numOfEdges++;
    }

    /**
     * 返回顶点的数目
     */
    public int getNumOfVertex() {
        return vertexList.size();
    }

    /**
     * 得到边的数目
     */
    public int getNumOfEdges() {
        return this.numOfEdges;
    }

    /**
     * 返回顶点i对应的数据
     */
    public String getValueByIndex(int i) {
        return vertexList.get(i);
    }

    /**
     * 返回v1,v2的权值
     */
    public int getWeight(int v1, int v2) {
        return edges[v1][v2];
    }

    /**
     * 显示图的邻接矩阵
     */
    public void showGraph() {
        for (int[] link : edges) {
            System.out.println(Arrays.toString(link));
        }
    }
}
```

## 常用的十大算法 Algorithm

### 字符串匹配算法-暴力匹配 Brute Force Match

问题：现在要判断 str1 是否含有 str2, 如果存在，就返回第一次出现的位置, 如果没有，则返回-1

```java
public class ViolenceMatch {
    public static void main(String[] args) {
        // 测试暴力匹配算法
        String str1 = "硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你沿硅谷你好";
        String str2 = "尚硅谷你尚硅谷你";
        int index = violenceMatch(str1, str2);
        System.out.println("index = " + index);
    }

    // 暴力匹配算法实现
    public static int violenceMatch(String str1, String str2) {
        char[] s1 = str1.toCharArray();
        char[] s2 = str2.toCharArray();

        int s1Len = s1.length;
        int s2Len = s2.length;

        int i = 0; // i索引指向s1
        int j = 0; //  j索引指向s2

        while (i < s1Len && j < s2Len) {
            // 保证匹配时不越界
            if (s1[i] == s2[j]) {
                // 相等时，相当于i,j同时向后移动一位
                i++;
                j++;
            } else {
                // 如果没有匹配成功 i = i -(j-1); j = 0;
                // 这里的意思是，j回到原位置0，i 相对起始位置向后移动一位
                i = i - (j - 1);
                j = 0;
            }
        }

        if (j == s2Len) {
            return i - j;
        } else {
            return -1;
        }
    }
}
```

### 字符串匹配算法- KMP算法

KMP是一个解决模式串在文本串是否出现过，如果出现过，最早出现的位置的经典算法



KMP方法算法就利用之前判断过信息，通过一个next数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过next数组找到，前面匹配过的位置，省去了大量的计算时间



参考资料：[https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.cnblogs.com%2FZuoAndFutureGirl%2Fp%2F9028287.html) 【建议有数学功底再做阅读】

上面链接有问题可以参考备份：https://blog.csdn.net/v_july_v/article/details/7041827





```java
public class KMPAlgorithm {
    public static void main(String[] args) {
        String str1 = "BBC ABCDAB ABCDABCDABDE";
        String str2 = "ABCDABD";

        int[] next = kmpNext(str2);
        int i = kmpSearch(str1, str2, next);
        System.out.println("i = " + i);
    }

    /**
     * 第二步：写出kmp搜索算法
     *
     * @param str1 文本串text
     * @param str2 模式串pattern
     * @param next 模式串对应的部分匹配表
     * @return 如果-1就是没有匹配到，否则返回第一个匹配的位置
     */
    public static int kmpSearch(String str1, String str2, int[] next) {
        // 遍历,i指向str1,j指响str2
        for (int i = 0, j = 0; i < str1.length(); i++) {
            // 需要处理str1.charAt(i) != str2.charAt(j)
            // 调整j的大小
            while (j > 0 && str1.charAt(i) != str2.charAt(j)) {
                j = next[j - 1];
            }
            if (str1.charAt(i) == str2.charAt(j)) {
                j++;
            }
            if (j == str2.length()) {
                return i - j + 1;
            }
        }
        return -1;
    }

    // 第一步，获取子串(模式串)的部分匹配值表
    public static int[] kmpNext(String dest) {
        // 创建一个next数组保存部分匹配值
        int[] next = new int[dest.length()];
        next[0] = 0; // 如果字符串长度为1,部分匹配值就是0
        for (int i = 1, j = 0; i < dest.length(); i++) {
            // 当dest.charAt(i) !=dest.charAt(j)，则需要 next[j-1] 得到新的 j
            // 直到满足 dest.charAt(i) ==dest.charAt(j) 才退出循环
            while (j > 0 && dest.charAt(i) != dest.charAt(j)) {
                j = next[j - 1];// 回溯（回退 1）
            }
            //  当dest.charAt(i) == dest.charAt(j)满足时，部分匹配值+1
            if (dest.charAt(i) == dest.charAt(j)) {
                j++;
            }
            next[i] = j;
        }
        return next;
    }

}
```



### 分治算法 Divide and Conquer 

分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)



分治法在每一层递归上都有三个步骤：

1. 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题
2. 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题
3. 合并：将各个子问题的解合并为原问题的解。



分治(Divide-and-Conquer(P))算法设计模式如下：

> if |P|≤n0
>  then return(ADHOC(P))
>  //将P分解为较小的子问题 P1 ,P2 ,…,Pk
>  for i←1 to k
>  do yi ← Divide-and-Conquer(Pi)   递归解决Pi
>  T ← MERGE(y1,y2,…,yk)   合并子问题
>  return(T)
>
> Adhoc 拉丁语，专门的意思



其中|P|表示问题P的规模；n0为一阈值，表示当问题P的规模不超过n0时，问题已容易直接解出，不必再继续分解。ADHOC(P)是该分治法中的基本子算法，用于直接解小规模的问题P。因此，当P的规模不超过n0时直接用算法ADHOC(P)求解。算法MERGE(y1,y2,…,yk)是该分治法中的合并子算法，用于将P的子问题P1 ,P2 ,…,Pk的相应的解y1,y2,…,yk合并为P的解。



汉诺塔的传说：

 1、汉诺塔：汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。



如果是有一个盘， A->C (就一步骤， A 移动到 C)

如果我们有 n >= 2 情况，我们总是可以看做是两部分盘 【1.最下边的一个盘 ，2. 上面的所有盘】
 1、先把 最上面的盘 A->B
 2、把最下边的盘 A->C
 3、把B塔的所有盘 从 B->C



```java
public class HanoiTower {

    public static void main(String[] args) {
        hanoiTower(2, 'A', 'B', 'C');
    }

    /**
     * 汉诺塔的移动方法：分治算法
     *
     * @param num 盘数
     * @param a   初始盘
     * @param b   中转盘
     * @param c   目标盘
     */
    public static void hanoiTower(int num, char a, char b, char c) {
        // 如果只有一个盘
        if (num == 1) {
            System.out.println("第1个盘从" + a + "->" + c);
        } else {
            //  如果我们有n>=2情况，我们总是可以看做是两个盘：1 最下边的一个盘 2 上面的其他盘
            // 1 先把上面的其他盘A->B,移动过程会用到C
            hanoiTower(num - 1, a, c, b);
            // 2 把最下面的盘A->C
            System.out.println("第" + num + "个盘从" + a + "->" + c);
            // 3 把B塔的所有盘从B->C，移动过程会用到A
            hanoiTower(num - 1, b, a, c);
        }

    }

}
```



### 动态规划算法 Dynamic Programming

1、动态规划(Dynamic Programming)算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法

2、动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。

3、与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。 ( 即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解 )

4、动态规划可以通过 填表 的方式来逐步推进，得到最优解



背包问题：

有一个背包，容量为4磅 ， 现有如下物品

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226779.png)

要求：
1、要求达到的目标为装入的背包的总价值最大，并且重量不超出
2、要求装入的物品不能重复



思路分析（文字说明）:

1、背包问题主要是指一个给定容量的背包、若干具有一定价值和重量的物品，如何选择物品放入背包使物品的价值最大。
 2、其中问题分两种，01背包 和 完全背包(完全背包指的是：每种物品都有无限件可用)
 3、这里的问题属于01背包，即每种类物品最多放一个。而无限背包可以转化为01背包。
 4、算法的主要思想，利用动态规划来解决。每次遍历到的第i个物品，根据  w[i]  和  v[i]  来确定是否需要将该物品放入背包中。v[i][j]  表示在前  i  个物品中能够装入容量为  j  的背包中的最大价值，公式和解释如下：
 （1） w[i] 表示 第 i 个商品的重量， v[i] 表示 第 i 个商品的价值(价格) ，j 表示 当前背包的容量
 （2） v[i][0] = v[0][j] =0;  //表示 填入表 第一行和第一列是0
 （3） 当w[i]> j 时：v[i][j] = v[i-1][j] ;  // 当准备加入新增的商品的容量大于 当前背包的容量时，就直接使用上一个单元格的装入策略 (阿K解释：就是现在月薪很低的你买不起贵的，你只能买得起和上个月月薪一样的东西...)
 （4） 当 j>=w[i] 时： v[i][j] = max{v[i-1][j], v[i]+v[i-1][j-w[i]]} ; // 当 准备加入的新增的商品的容量小于等于当前背包的容量（其中max 内的参数分两个 ，比较出最大的一个 ，赋值 给 v[i][j]）,具体解释：
 v[i-1][ j ] ： 既上一个单元格的装入的最大值（已有的值）
 v[ i - 1 ] [ j - w[ i ] ] ： 装入i-1商品，到剩余空间为  j-w[i] 的最大值
 注：此二位数组可以看成 x轴和 y 轴， v[y] [x]  或者 v[i] [j]，以后表格对应，x轴对应的是 重量(容量)，y轴则是 物品编号

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226780.png)



```java
/**
 * 背包问题
 */
public class Knapsack {

    public static void main(String[] args) {
        // 物品的重量
        int[] w = {1, 4, 3};
        int[] val = {1500, 3000, 2000};
        int m = 4;// 背包的容量
        int n = val.length;// 物品的个数

        // 为了记录放入商品的情况，我们定一个二维数组
        int[][] path = new int[n + 1][m + 1];

        // 创建二维数组
        // 表示前i个物品中能够装入容量为j的背包中的最大价值
        int[][] v = new int[n + 1][m + 1];

        // 初始化第一行和第一列，这里可以不用处理，因为默认为0
        for (int i = 0; i < v.length; i++) {
            v[i][0] = 0;// 第一列设置为0
        }
        for (int i = 0; i < v[0].length; i++) {
            v[0][i] = 0; // 第一行设置为0
        }

        // 根据前面的公式来动态规划处理
        // 不处理第1行
        for (int i = 1; i < v.length; i++) {
            // 不处理第1列
            for (int j = 1; j < v[0].length; j++) {
                // 公式,因为我们程序的i是从1开始的，因此原公式的w[i],修改成w[i-1]
                if (w[i - 1] > j) {
                    v[i][j] = v[i - 1][j];
                } else {
                    // 因为i是从1开始的,因此公式val[i],w[i]，需要调整 val[i-1],w[i-1]
                    // v[i][j] = Math.max(v[i - 1][j], val[i - 1] + v[i - 1][j - w[i - 1]]);
                    // 为了记录商品放入到背包的情况，我们不能简单的使用上面的公式，
                    // 需要使用if-else来体现
                    if (v[i - 1][j] < val[i - 1] + v[i - 1][j - w[i - 1]]) {
                        v[i][j] = val[i - 1] + v[i - 1][j - w[i - 1]];
                        // 把当前的情况记录到path,只有新放物品才记录
                        path[i][j] = 1;
                    } else {
                        v[i][j] = v[i - 1][j];
                    }
                }
            }
        }

        // 输入一下看v,看看目前的情况
        for (int i = 0; i < v.length; i++) {
            for (int j = 0; j < v[i].length; j++) {
                System.out.print(v[i][j] + " ");
            }
            System.out.println();
        }

        // 输出最后我们是放入的是哪此商品
        // 遍历path, 这样的输出会把所有的情况都得到，其实我们只需要最后的放入
        // for (int i = 0; i < path.length; i++) {
        //    for (int j = 0; j < path[i].length; j++) {
        //        if (path[i][j] == 1) {
        //            System.out.printf("第%d个商品放入到背包\n", i);
        //        }
        //    }
        //}

        // 动脑筋，输出最优放入方法
        int i = path.length - 1; // 行的最大下标
        int j = path[0].length - 1; // 列的最大下标
        // 从path数组的最后开始找
        while (i > 0 && j > 0) {
            if (path[i][j] == 1) {
                System.out.printf("第%d个商品放入到背包\n", i);
                j -= w[i - 1];
            }
            i--;
        }
    }
}

```



### 贪心算法 Greedy Algorithm



应用场景-集合覆盖问题:

假设存在下面需要付费的广播台，以及广播台信号可以覆盖的地区。 如何选择最少的广播台，让所有的地区都可以接收到信号

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226781.png)



贪心算法介绍：

（1）贪婪算法(贪心算法)是指在对问题进行求解时，在每一步选择中都采取最好或者最优(即最有利)的选择，从而希望能够导致结果是最好或者最优的算法

（2）贪婪算法所得到的最后结果不一定是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果

解决方案（举例两类：穷举法，贪心算法）

（1）穷举法：
 如何找出覆盖所有地区的广播台的集合呢，使用穷举法实现,列出每个可能的广播台的集合，这被称为幂集。假设总的有n个广播台，则广播台的组合总共有2ⁿ -1 个,假设每秒可以计算10个子集， 如图: (思考：这里为什么是2ⁿ -1，可以这样想，有n个占位，每个占位可以选与不选，则有2ⁿ个选择可能，再减去全为空的情况则为2ⁿ -1)

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226782.png)



2）贪心算法最佳应用-集合覆盖的思路分析：

目前并没有算法可以快速计算得到准备的值， 使用贪婪算法，则可以得到非常接近的解，并且效率高。选择策略上，因为需要覆盖全部地区的最小集合，具体步骤如下：

<1>遍历所有的广播电台, 找到一个覆盖了最多未覆盖的地区的电台(此电台可能包含一些已覆盖的地区，但没有关系）--- 此集合大多时候是一个 或者 多个组合的 集合 ，这里的 "个" 指的是广播台 K1,K2....

<2>将这个电台加入到一个集合中(比如ArrayList), 想办法把该电台覆盖的地区在下次比较时去掉

<3>重复第1步直到覆盖了全部的地区



```java
public class GreedyAlgorithm {

    public static void main(String[] args) {
        // 创建广播电台,放入到Map中管理
        Map<String, Set<String>> broadcasts = new HashMap<>();
        // 将各个电台放入到broadcasts中
        broadcasts.put("k1", new HashSet<String>() {{
            add("北京");
            add("上海");
            add("天津");
        }});
        broadcasts.put("k2", new HashSet<String>() {{
            add("广州");
            add("北京");
            add("深圳");
        }});
        broadcasts.put("k3", new HashSet<String>() {{
            add("成都");
            add("上海");
            add("杭州");
        }});
        broadcasts.put("k4", new HashSet<String>() {{
            add("上海");
            add("天津");
        }});
        broadcasts.put("k5", new HashSet<String>() {{
            add("杭州");
            add("大连");
        }});

        // 存入所有地区，代表所有未覆盖地区
        Set<String> allAreas = new HashSet<>();
        broadcasts.values().stream().flatMap(Collection::stream)
                .forEach(allAreas::add);

        // 创建ArrayList，存入选择的电台集合
        List<String> selects = new ArrayList<>();

        // 定义一个临时集合，在遍历的过程中，
        // 存放遍历过程中的电台覆盖的地区和当前没有覆盖的地区
        Set<String> tempSet = new HashSet<>();

        // 定义maxKey,保存在一次遍历过程中，
        // 能够覆盖最大未覆盖的地区对的应的电台key
        // 如果maxKey不为null,则会加入到selects
        String maxKey = null;
        int maxNum = 0;
        while (allAreas.size() > 0) {
            // 每进行一次进行while，需要maxKey置为null
            maxKey = null;
            maxNum = 0;
            // 如果allAreas不为0,则表示还没有覆盖到所有的地区
            // 遍历broadcasts，取出对应key
            for (String key : broadcasts.keySet()) {
                // 每进行一次for,tempSet清空
                tempSet.clear();
                // 当前key覆盖的地区
                Set<String> areas = broadcasts.get(key);
                tempSet.addAll(areas);
                // 取交集
                tempSet.retainAll(allAreas);
                // 如果当前这个集合包含的未覆盖地区的数量，
                // 比maxKey指向的集合未覆盖的地区还多,
                // 就需要重置maxKey,
                // 每次选最优的，体现出贪心算法的特点
                if (tempSet.size() > 0
                        && (maxKey == null
                        || tempSet.size() > maxNum)) {
                    maxKey = key;
                    maxNum = tempSet.size();
                }
            }
            // maxKey不为null,就应该将maxKey加入selects
            if (maxKey != null) {
                selects.add(maxKey);
                // 将maxKey指向的广播电台覆盖的地区，从allAreas去掉
                allAreas.removeAll(broadcasts.get(maxKey));
            }
        }
        System.out.println("得到的选择结果是" + selects);

    }

}

```



贪心算法注意事项和细节:

（1）贪心算法所得到的结果不一定是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果
 （2）比如上题的算法选出的是K1, K2, K3, K5，符合覆盖了全部的地区
 （3）但是我们发现 K2, K3,K4,K5 也可以覆盖全部地区，如果K2 的使用成本低于K1,那么我们上题的 K1, K2, K3, K5 虽然是满足条件，但是并不是最优的



### 最小生成树MST-普利姆算法 Prim Algorithm

应用场景-修路问题:

（1）有胜利乡有7个村庄(A, B, C, D, E, F, G) ，现在需要修路把7个村庄连通
 （2）各个村庄的距离用边线表示(权) ，比如 A – B 距离 5公里
 （3）问：如何修路保证各个村庄都能连通，并且总的修建公路总里程最短?
 常规思路: 将10条边，连接即可，但是总的里程数不是最小
 正确思路：尽可能的选择少的路线，并且每条路线最小，保证总里程数最少



![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226783.png)

最小生成树:

修路问题本质就是就是最小生成树问题， 最小生成树(Minimum Cost Spanning Tree)，简称MST

（1）给定一个带权的无向连通图,如何选取一棵生成树,使树上所有边上权的总和为最小,这叫最小生成树
 （2）N个顶点，一定有N-1条边(即最少有N-1条边)
 （3）包含全部顶点
 （4）N-1条边都在图中
 （5）求最小生成树的算法主要是普里姆算法和克鲁斯卡尔算法

普利姆算法:

（1）普利姆(Prim)算法求最小生成树，也就是在包含n个顶点的连通图中，找出只有(n-1)条边包含所有n个顶点的连通子图，也就是所谓的极小连通子图

（2）文字思路：看不懂也无所谓，概述而已，详细看图解

 ①设G=(V,E)是连通网，T=(U,D)是最小生成树，V,U是顶点集合，E,D是边的集合
 ②若从顶点u开始构造最小生成树，则从集合V中取出顶点u放入集合U中，标记顶点v的visited[u]=1（既被访问过了）
 ③若集合U中顶点ui与集合V-U中的顶点vj之间存在边，则寻找这些边中权值最小的边，但不能构成回路，将顶点vj加入集合U中，将边（ui,vj）加入集合D中，标记visited[vj]=1
 ④重复步骤②，直到U与V相等，即所有顶点都被标记为访问过，此时D中有n-1条边



![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226784.png)



```java
public class PrimAlgorithm {

    public static void main(String[] args) {

        // 测试看看图是否创建ok
        char[] vertexList = {'A', 'B', 'C', 'D', 'E', 'F', 'G'};
        // 顶点数目
        int numOfVertex = vertexList.length;
        // 邻接矩阵，10000这个大数表示不连通,本身之间的连通也用大数表示不连
        int[][] edges = new int[][]{
                {10000, 5, 7, 10000, 10000, 10000, 2},
                {5, 10000, 10000, 9, 10000, 10000, 3},
                {7, 10000, 10000, 10000, 8, 10000, 10000},
                {10000, 9, 10000, 10000, 10000, 4, 10000},
                {10000, 10000, 8, 10000, 10000, 5, 4},
                {10000, 10000, 10000, 4, 5, 10000, 6},
                {2, 3, 10000, 10000, 4, 6, 10000},};
        // 创建Graph对象
        Graph graph = new Graph(numOfVertex);
        MinTree minTree = new MinTree();
        minTree.createGraph(graph, numOfVertex, vertexList, edges);
        // 输出
        minTree.showGraph(graph);
        // 测试prim
        minTree.prim(graph, 0);

    }
}

/**
 * 创建最小生成树
 */
class MinTree {

    /**
     * prim算法,得到最小生成树
     *
     * @param graph 图
     * @param v     表示从图的第几个顶点开始生成
     */
    public void prim(Graph graph, int v) {
        // 表示已访问的顶点，默认0表示没有访问过
        int[] visited = new int[graph.numOfVertex];

        // 处理

        // 当前节点标记为已访问
        visited[v] = 1;
        // 记录两个顶点的下标
        int h1 = -1;
        int h2 = -1;
        // 最小权值
        int miniWeight = 10000;
        // prim算法有graph.numOfVertex-1条边，所有k=1开始
        // 外层k表示生成的边数
        for (int k = 1; k < graph.numOfVertex; k++) {
            // 这里双层for循环确定每次生成的子图和哪个结点的距离最短
            // i结点被访问过的结点，j结点表示未访问过的结点
            for (int i = 0; i < graph.numOfVertex; i++) {
                for (int j = 0; j < graph.numOfVertex; j++) {
                    if (visited[i] == 1 && visited[j] == 0
                            && graph.edges[i][j] < miniWeight) {
                        // 替换miniWeight,即记录最小的权
                        miniWeight = graph.edges[i][j];
                        h1 = i;
                        h2 = j;
                    }
                }
            }
            // 找到一条边是最小
            System.out.println("边<" + graph.vertexList[h1] + ","
                    + graph.vertexList[h2] + ">权值为：" + miniWeight);
            // 将当前这个结点标记为已访问
            visited[h2] = 1;
            // miniWeight重置为10000
            miniWeight = 10000;
        }
    }

    /**
     * 创建图的邻接矩阵
     *
     * @param graph       图对象
     * @param numOfVertex 图对应的顶点个数
     * @param vertexList  图的各个顶点的值
     * @param edges       图的邻接矩阵
     */
    public void createGraph(Graph graph, int numOfVertex, char[] vertexList, int[][] edges) {
        for (int i = 0; i < numOfVertex; i++) {
            graph.vertexList[i] = vertexList[i];
            for (int j = 0; j < numOfVertex; j++) {
                graph.edges[i][j] = edges[i][j];
            }
        }
    }

    /**
     * 显示图的方法,这里显示邻接矩阵
     */
    public void showGraph(Graph graph) {
        for (int[] link : graph.edges) {
            System.out.println(Arrays.toString(link));
        }
    }
}

class Graph {
    // 表示图顶点的数目
    int numOfVertex;
    // 存入结点数据
    char[] vertexList;
    // 邻接矩阵
    int[][] edges;

    public Graph(int numOfVertex) {
        this.numOfVertex = numOfVertex;
        vertexList = new char[numOfVertex];
        edges = new int[numOfVertex][numOfVertex];
    }

}
```



###  最小生成树MST-克鲁斯卡尔算法 Kruskal Algorithm



应用场景-公交站问题:

（1）某城市新增7个站点(A, B, C, D, E, F, G) ，现在需要修路把7个站点连通

 （2）各个站点的距离用边线表示(权) ，比如 A – B 距离 12公里

 （*）问题：如何修路保证各个站点都能连通，并且总的修建公路总里程最短?



![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226785.png)

 

克鲁斯卡尔算法介绍:

（1）克鲁斯卡尔(Kruskal)算法，是用来求加权连通图的最小生成树的算法。

 （2）基本思想：按照权值从小到大的顺序选择n-1条边，并保证这n-1条边不构成回路

 （3）具体做法：首先构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止



克鲁斯卡尔算法存在的两个问题：
 （1）问题一：对图的所有边按照权值大小进行排序（简单，十大排序随便选择）

 （2）问题二：将边添加到最小生成树中时，怎么样判断是否形成了回路



对于问题二，处理方式是：记录顶点在"最小生成树"中的终点，顶点的终点是"在最小生成树中与它连通的"最大顶点"。然后每次需要将一条边添加到最小生成树时，判断该边的两个顶点的终点是否重合，重合的话则会构成回路



什么情况会构成回路？

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226786.png)

（1）在将<E,F> <C,D> <D,E>加入到最小生成树R中之后，这几条边的顶点就都有了终点：
 <1> C的终点是F。
 <2> D的终点是F。
 <3> E的终点是F。
 <4> F的终点是F。

（2）关于终点的说明：
 <1>就是将所有顶点按照从小到大的顺序排列好之后；某个顶点的终点就是"与它连通的最大顶点"（就是在编码表中 F 比 C,D,E 都大，即终点）
 <2>因此，接下来，虽然<C,E>是权值最小的边。但是C和E的终点都是F，即它们的终点相同，因此，将<C,E>加入最小生成树的话，会形成回路。这就是判断回路的方式。也就是说，我们加入的边的两个顶点不能都指向同一个终点，否则将构成回路。



```java
/**
 * Kruskal算法解决公交站连通问题
 */
public class KruskalAlgorithm {

    // 边的个数
    private int edgeNum;

    // 顶点数组
    private char[] vertexList;

    // 邻接矩阵
    private int[][] matrix;

    private static final int INF = Integer.MAX_VALUE;


    public static void main(String[] args) {
        char[] vertexList = {'A', 'B', 'C', 'D', 'E', 'F', 'G'};
        int[][] matrix = {
                // 说明： 0 是自己，INF 是不能连通
                /*A*//*B*//*C*//*D*//*E*//*F*//*G*/
                /*A*/ {0, 12, INF, INF, INF, 16, 14},
                /*B*/ {12, 0, 10, INF, INF, 7, INF},
                /*C*/ {INF, 10, 0, 3, 5, 6, INF},
                /*D*/ {INF, INF, 3, 0, 4, INF, INF},
                /*E*/ {INF, INF, 5, 4, 0, 2, 8},
                /*F*/ {16, 7, 6, INF, 2, 0, 9},
                /*G*/ {14, INF, INF, INF, 8, 9, 0}};
        // 创建对象
        KruskalAlgorithm kruskal = new KruskalAlgorithm(vertexList, matrix);
        // 打印
        kruskal.print();
        // 看下EData数组,未排序
        EData[] edges = kruskal.getEdges();
        // 排序前：
        System.out.println(Arrays.toString(edges));
        // 排序
        kruskal.sortEdge(edges);
        // 排序后
        System.out.println(Arrays.toString(edges));
        kruskal.kruskal();


    }

    public void kruskal() {
        // 表示最后结果数组的索引
        int index = 0;
        // 用于保存已有最小生成树中的每个顶点在最小生成树中的终点
        int[] ends = new int[edgeNum];
        // 创建结果数组,保存最后的最小生成树
        EData[] results = new EData[edgeNum];
        // 获取图中所有的边的集合，这里是12条
        EData[] edges = getEdges();
        // 看下边数
        System.out.println(edges.length);
        // 按照边的权值大小进行排序,从小到大
        sortEdge(edges);
        // 遍历edges数组，将边添加到最小生成树中时，
        // 判断是否形成回路，如果没有就加入results
        for (int i = 0; i < edgeNum; i++) {
            // 获取第i条边的第一个顶点
            int p1 = getPosition(edges[i].start);
            // 获取第i条边的第一个终点
            int p2 = getPosition(edges[i].end);
            // 获取p1这个顶点在已有最小生成树中的终点是哪个
            int m = getEnd(ends, p1);
            // 获取p2这个顶点在已有最小生成树中的终点是哪个
            int n = getEnd(ends, p2);
            // 是否构成回路
            if (m != n) { // 不构成回路
                ends[m] = n; // 设置m在已有最小生成树中的终点
                // n不用设终点因为getEnds()方法会返回自身
                results[index++] = edges[i]; // 有一条边加入到results
            }
        }
        // 统计并打印最小生成树，输出results
        System.out.println("最小生成树为");
        for (int i = 0; i < index; i++) {
            System.out.println(results[i]);
        }
    }


    /**
     * 获取下标为i的顶点的终点，
     * 用于后面判断两个顶点的终点是否相同
     *
     * @param ends 记录了各个顶点对应的终点是哪个，ends是遍历过程中，逐步形成
     * @param i    表示传入的顶点对应的下标
     * @return 返回的就是下标为i的这个顶点对应的终点的下标
     */
    private int getEnd(int[] ends, int i) {
        while (ends[i] != 0) {
            i = ends[i];
        }
        return i;
    }

    /**
     * 1 首先对边进行排序处理,采用bubble sort
     *
     * @param edges 边的集合
     */
    private void sortEdge(EData[] edges) {
        for (int i = 0; i < edges.length - 1; i++) {
            for (int j = 0; j < edges.length - 1 - i; j++) {
                if (edges[j].weight > edges[j + 1].weight) {
                    EData temp = edges[j];
                    edges[j] = edges[j + 1];
                    edges[j + 1] = temp;
                }
            }
        }
    }

    /**
     * 获取图中边，放到EData[]中，后面需要遍历该数组
     * 通过邻接矩阵来获取
     *
     * @return
     */
    private EData[] getEdges() {
        int index = 0;
        // 根据边数创建EData数组
        EData[] eData = new EData[edgeNum];
        for (int i = 0; i < vertexList.length; i++) {
            // 跳过自己，j = i+1
            for (int j = i + 1; j < vertexList.length; j++) {
                if (matrix[i][j] != INF) {
                    eData[index++] = new EData(vertexList[i], vertexList[j], matrix[i][j]);
                }
            }
        }
        return eData;
    }

    /**
     * 查找数组元素的下标
     *
     * @param ch 顶点的值，比如'A'
     * @return 顶点对应的下标, 找不到返回-1
     */
    private int getPosition(char ch) {
        for (int i = 0; i < vertexList.length; i++) {
            if (vertexList[i] == ch) {
                return i;
            }
        }
        return -1;
    }

    /**
     * 构造器
     */
    public KruskalAlgorithm(char[] vertexList, int[][] matrix) {
        // 初始化顶点数和边的个数
        int vLen = vertexList.length;
        // 初始化顶点,复制拷贝
        this.vertexList = new char[vLen];
        for (int i = 0; i < vLen; i++) {
            this.vertexList[i] = vertexList[i];
        }
        // 初始化边
        this.matrix = new int[vLen][vLen];
        for (int i = 0; i < vLen; i++) {
            for (int j = 0; j < vLen; j++) {
                this.matrix[i][j] = matrix[i][j];
            }
        }
        // 统计边数
        for (int i = 0; i < vLen; i++) {
            // 排除自身连通情况，j = i+1
            for (int j = i + 1; j < vLen; j++) {
                if (this.matrix[i][j] != INF) {
                    this.edgeNum++;
                }
            }
        }
    }

    // 打印邻接矩阵
    public void print() {
        System.out.println("邻接矩阵为：");
        for (int i = 0; i < this.vertexList.length; i++) {
            for (int j = 0; j < this.vertexList.length; j++) {
                System.out.printf("%12d\t", matrix[i][j]);
            }
            System.out.println();
        }
    }

}

/**
 * 创建EData代表一条边
 */
class EData {
    char start; // 边的起点
    char end; // 边的终点
    int weight; // 边的权值

    /**
     * 构造器
     */
    public EData(char start, char end, int weight) {
        this.start = start;
        this.end = end;
        this.weight = weight;
    }

    /**
     * 重写toString()方法，输出边的信息
     */
    @Override
    public String toString() {
        return "EData{" +
                "start=" + start +
                ", end=" + end +
                ", weight=" + weight +
                '}';
    }
}
```



思考：kruskal算法的结果与prim算法的得到的最小生成树结果是否一样？ 答案：一样。



### 最短路径MP-迪杰斯特拉算法 Dijkstra Algorithm



1、应用场景-最短路径问题

史莱村乡有7个村庄(A, B, C, D, E, F, G) ，现在有六个邮差，从G点出发，需要分别把邮件分别送到 A, B, C , D, E, F 六个村庄，各个村庄的距离用边线表示(权) ，比如 A – B 距离 5公里
 问：
 1、如何计算出G村庄到 其它各个村庄的最短距离?
 2、如果从其它点出发到各个点的最短距离又是多少?



![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226788.png)

2、迪杰斯特拉(Dijkstra)算法介绍

迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个结点到其他结点的最短路径。 它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。



3、迪杰斯特拉(Dijkstra)算法过程

设置出发顶点为v，顶点集合V{v1,v2,vi...}，v到V中各顶点的距离构成距离集合Dis，Dis{d1,d2,di...}，Dis集合记录着v到图中各顶点的距离(到自身可以看作0，v到vi距离对应为di)
 （1）从Dis中选择值最小的di并移出Dis集合，同时移出V集合中对应的顶点vi，此时的v到vi即为最短路径
 （2）更新Dis集合，更新规则为：比较v到V集合中顶点的距离值，与v通过vi到V集合中顶点的距离值，保留值较小的一个(同时也应该更新顶点的前驱节点为vi，表明是通过vi到达的)
 （3）重复执行两步骤，直到最短路径顶点为目标顶点即可结束





```java
public class DijkstraAlgorithm {

    public static void main(String[] args) {
        char[] vertex = {'A', 'B', 'C', 'D', 'E', 'F', 'G'};
        // 邻接矩阵
        int[][] matrix = new int[vertex.length][vertex.length];
        final int N = 65535;// 表示不可以连接
        matrix[0] = new int[]{N, 5, 7, N, N, N, 2};
        matrix[1] = new int[]{5, N, N, 9, N, N, 3};
        matrix[2] = new int[]{7, N, N, N, 8, N, N};
        matrix[3] = new int[]{N, 9, N, N, N, 4, N};
        matrix[4] = new int[]{N, N, 8, N, N, 5, 4};
        matrix[5] = new int[]{N, N, N, 4, 5, N, 6};
        matrix[6] = new int[]{2, 3, N, N, 4, 6, N};

        // 创建图对象
        Graph graph = new Graph(vertex, matrix);
        // 看看图的邻接矩阵
        graph.showGraph();
        // 测试dijkstra算法
        graph.dij(6);
        // 显示结果
        graph.showDijkstra();

    }
}

class VisitedVertex {

    // 记录各个顶点是否访问过 1表示访问过,0未访问,会动态更新
    public int[] already_arr;
    // 每个下标对应的值为前一个顶点下标, 会动态更新，'0'->'A','6'->'G'
    public int[] pre_visited;
    // 记录出发顶点到其他所有顶点的距离,比如G为出发顶点，就会记录G到其它顶点的距离，会动态更新，求的最短距离就会存放到dis
    public int[] dis;

    /**
     * 构造器
     *
     * @param length 顶点的个数
     * @param index  出发顶点
     */
    public VisitedVertex(int length, int index) {
        this.already_arr = new int[length];
        this.pre_visited = new int[length];
        this.dis = new int[length];
        // 初始化dis数组
        Arrays.fill(dis, 65535);
        // 设置出发节点访问自己的距离为0
        this.dis[index] = 0;
        // 设置出发顶点的已访问
        this.already_arr[index] = 1;
    }

    /**
     * 判断index顶点是否被访问过
     *
     * @param index
     * @return 如果访问过，就返回true,否则false
     */
    public boolean in(int index) {
        return already_arr[index] == 1;
    }

    /**
     * 更新出发顶点到index顶点的距离
     *
     * @param index
     * @param len
     */
    public void updateDis(int index, int len) {
        dis[index] = len;
    }

    /**
     * 更新pre顶点的前驱为index的结点
     *
     * @param index
     * @param pre
     */
    public void updatePre(int index, int pre) {
        pre_visited[index] = pre;
    }

    /**
     * 返回出发顶点到index顶点的距离
     *
     * @param index
     */
    public int getDis(int index) {
        return dis[index];
    }

    /**
     * 继续选择并返回新的访问顶点
     * 比如这里的 G节点走完之后，就是A 节点作为新节点开始访问顶点
     * （注意不是作为出发顶点，而是继续，出发顶点仍是G）
     *
     * @return
     */
    public int updateArr() {
        int min = 65535, index = 0;
        for (int i = 0; i < already_arr.length; i++) {
            if (already_arr[i] == 0 && dis[i] < min) {// 如果未访问过，并且可以连通
                min = dis[i];
                index = i;
            }
        }
        // 更新 index顶点被访问过，并返回
        already_arr[index] = 1;
        return index;
    }

    /**
     * 显示最终结果（即 三个数组的遍历）
     */
    public void show() {
        System.out.println("--------------------美丽的分割线----------------------------");
        // 输出already_arr 被访问情况
        for (int i : already_arr) {
            System.out.print(i + " ");
        }
        System.out.println();
        // 输出pre_visited 节点的前驱节点
        for (int i : pre_visited) {
            System.out.print(i + " ");
        }
        System.out.println();
        // 输出dis    节点间距离
        for (int di : dis) {
            System.out.print(di + " ");
        }
        System.out.println();
        // 为了更好的看到效果，处理输出
        char[] vertex = {'A', 'B', 'C', 'D', 'E', 'F', 'G'};
        int count = 0;
        for (int i : dis) {
            if (i != 65535) {
                System.out.print(vertex[count] + "【" + i + "】");
            } else {
                System.out.println("N ");
            }
            count++;
        }
        System.out.println();
    }

}

class Graph {

    // 顶点数组
    private char[] vertexArray;
    // 邻接矩阵
    private int[][] matrix;

    private VisitedVertex visitedVertex;

    public Graph(char[] vertexArray, int[][] matrix) {
        this.vertexArray = vertexArray;
        this.matrix = matrix;
    }

    /**
     * 显示结果
     */
    public void showDijkstra() {
        visitedVertex.show();
    }

    // 显示图的方法
    public void showGraph() {
        for (int[] link : matrix) {
            System.out.println(Arrays.toString(link));
        }
    }

    /**
     * dijkstra算法
     */
    public void dij(int index) {
        // index 表示出发顶点的下标
        visitedVertex = new VisitedVertex(vertexArray.length, index);
        // 更新index顶点到周围顶点的距离
        update(index);
        for (int j = 0; j < vertexArray.length; j++) {
            //  选择并返回新的访问节点
            index = visitedVertex.updateArr();
            // 更新index顶点到周围顶点的距离
            update(index);
        }
    }

    // 更新index下标顶点到周围顶点的前驱顶点
    private void update(int index) {
        int len = 0;
        // 遍历我们的邻接矩阵的matrix[index]
        for (int j = 0; j < matrix[index].length; j++) {
            // len是指：出发顶点到index顶点的距离+ 从index顶点到j顶点的距离的和
            len = visitedVertex.getDis(index) + matrix[index][j];
            // 如果j顶点没有被访问过，并且len小于出发顶点到j顶点的距离，就需要更新
            if (!visitedVertex.in(j) && len < visitedVertex.getDis(j)) {
                visitedVertex.updatePre(j, index); // 更新j顶点的前驱为index顶点
                visitedVertex.updateDis(j, len); // 更新出发顶点到j顶点的距离
            }
        }
    }
}
```



### 最短路径MP-弗洛伊德算法 Floyd Algorithm

1、应用场景-最短路径问题

史莱村乡有7个村庄(A, B, C, D, E, F, G) ，现在有六个邮差，从G点出发，需要分别把邮件分别送到 A, B, C , D, E, F 六个村庄，各个村庄的距离用边线表示(权) ，比如 A – B 距离 5公里
 问：
 1、如何计算出G村庄到 其它各个村庄的最短距离?
 2、如果从其它点出发到各个点的最短距离又是多少?

Floyd算法就是解决问题2

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226789.png)



2、弗洛伊德(Floyd)算法介绍

（1）和Dijkstra算法一样，弗洛伊德(Floyd)算法也是一种用于寻找给定的加权图中顶点间最短路径的算法。
 弗洛伊德算法(Floyd)计算图中各个顶点之间的最短路径
 （2）迪杰斯特拉算法用于计算图中某一个顶点到其他顶点的最短路径。
 （3）弗洛伊德算法 VS 迪杰斯特拉算法：迪杰斯特拉算法通过选定的被访问顶点，求出从出发访问顶点到其他顶点的最短路径；弗洛伊德算法中每一个顶点都是出发访问点，所以需要将每一个顶点看做被访问顶点，求出从每一个顶点到其他顶点的最短路径。



3、弗洛伊德算法思路

1、说明：
 （1）设置顶点vi到顶点vk的最短路径已知为Lik，顶点vk到vj的最短路径已知为Lkj，顶点vi到vj的路径为Lij，则vi到vj的最短路径为：min((Lik+Lkj),Lij)，vk的取值为图中所有顶点，则可获得vi到vj的最短路径
 （2）至于vi到vk的最短路径Lik或者vk到vj的最短路径Lkj，是以同样的方式获得

![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226790.png)





![](https://raw.githubusercontent.com/pvisanhash/PicSiteRepo1/main/note/img/202210042226791.png)



```java
public class FloydAlgorithm {
    public static void main(String[] args) {
        // 测试图是否创建成功
        char[] vertex = {'A', 'B', 'C', 'D', 'E', 'F', 'G'};
        // 创建邻接矩阵
        int[][] matrix = new int[vertex.length][vertex.length];
        final int N = 65535;
        matrix[0] = new int[]{0, 5, 7, N, N, N, 2};
        matrix[1] = new int[]{5, 0, N, 9, N, N, 3};
        matrix[2] = new int[]{7, N, 0, N, 8, N, N};
        matrix[3] = new int[]{N, 9, N, 0, N, 4, N};
        matrix[4] = new int[]{N, N, 8, N, 0, 5, 4};
        matrix[5] = new int[]{N, N, N, 4, 5, 0, 6};
        matrix[6] = new int[]{2, 3, N, N, 4, 6, 0};
        // 创建图对象
        Graph graph = new Graph(vertex.length, matrix, vertex);
        // 显示
        graph.show(vertex);
        // 调用Floyd算法
        graph.floyd();
        // 显示
        System.out.println("------------------------------------------------------");
        graph.show(vertex);
    }
}

// 创建图
class Graph {
    // 存放顶点的数组
    private char[] vertex;
    // 保存从各个顶点出发到其他顶点的距离，最后的结果也何存在该数组
    private int[][] dis;
    // 保存到达目标顶点的前驱顶点
    private int[][] pre;

    /**
     * 构造器
     *
     * @param length 顶点的个数
     * @param matrix 邻接矩阵
     * @param vertex 顶点的数组
     */
    public Graph(int length, int[][] matrix, char[] vertex) {
        this.vertex = vertex;
        this.dis = matrix;
        this.pre = new int[length][length];
        // 初始化pre，注意存放的是前驱顶点的下标
        for (int i = 0; i < length; i++) {
            for (int j = 0; j < length; j++) {
                Arrays.fill(pre[i], i);
            }
        }
    }

    // 显示pre数组和dis数组
    public void show(char[] vertex) {
        // o
        for (int i = 0; i < dis.length; i++) {

            // 输出pre数组的一行
            for (int j = 0; j < dis[i].length; j++) {
                System.out.print(vertex[pre[i][j]] + " ");
            }
            System.out.println();

            // 输出dis数组的一行
            for (int j = 0; j < dis[i].length; j++) {
                System.out.print("(" + vertex[i] + "到" +
                        vertex[j] + "的最短路径" + dis[i][j] + ") ");
            }
            System.out.println();
        }
    }

    /**
     * 弗洛伊德算法
     */
    public void floyd() {
        int len = 0; // 变量保存距离
        // 从中间顶点遍历，k就是中间顶点的下标
        for (int k = 0; k < dis.length; k++) {
            // 从i顶点开始出发
            for (int i = 0; i < dis.length; i++) {
                // j顶点结束
                for (int j = 0; j < dis.length; j++) {
                    // 求出从i顶点出发，经过k中间顶点，到达j顶点的距离
                    len = dis[i][k] + dis[k][j];
                    // len < dis[i][j]，就更新距离
                    if (len < dis[i][j]) {
                        // 更新距离
                        dis[i][j] = len;
                        // 更新前驱顶点?
                        // 因为前驱节点的意思代表到达j点的前驱节点，这里就是pre[k][j]就是经过k到达j点的前驱顶点
                        // 比如A-G-F-D，则k是G的索引，pre[i][j] = F的索引
                        pre[i][j] = pre[k][j];
                    }
                }
            }
        }

    }
}

```

