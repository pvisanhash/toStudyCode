

---

author: aitx

title: 系统性算法学习

time: 2023-12-17 周六

tags: 
  - 算法
  - 学习
  - 编程

---

## 基础入门


### 二进制与位运算

```
二进制：用0、1表示，逢二进一

位运算：与&，或｜，非！，异或^

```

### 阶乘和

```java
package com.aitx.study.base;  
  
/**  
 * 阶乘和 * 给定一个参数N， 
 * 返回：  1! + 2! + 3! + 4! + … + N!   的结果 
 * <p>  
 * 思路： * 一、求每部分后再加和 * 二、后一个跟前一个有关系，直接求和 
 * */
 public class Code001_Factorial {  
  
  
    /**  
     * 思路一：求每部分后再加和     
     * */    
    public static int factorialSum(int N) {  
        int sum = 0;  
        for (int i = 1; i <= N; i++) {  
            sum += factorial(i);  
        }  
        return sum;  
    }  
  
    // 求每部分的值  
    private static int factorial(int N) {  
        int result = 1;  
        for (int i = 1; i <= N; i++) {  
            result *= i;  
        }  
        return result;  
    }  
  
    /**  
     * 思路二：后一个跟前一个有关系，直接求和     
     * */
	public static int factorialSumNew(int N) {  
        int sum = 0;  
        int fac = 1;  
        for (int i = 1; i <= N; i++) {  
            fac *= i;  
            sum += fac;  
        }  
        return sum;  
    }  
  
}
```



### 打印int类型的二进制数表示

```
打印一个int型数的二进制表示， 比如5的二进制表示为00000000000000000000000000000101 
```

```java
package com.aitx.study.base;  
  
/**  
 * 打印一个int型数的二进制表示， 
 * 比如5的二进制表示为00000000000000000000000000000101 
 * 
 * */
 public class PrintInteger2RadixNum {  
  
  
    public static void main(String[] args) {  
        int num = 5;  
        print(5);  
        System.out.println();  
        System.out.println("=======");  
        test();  
    }  
  
    /**  
     * 打印一个int型数的二进制表示   
     * @param num int类型的数  
     */    
     private static void print(int num) {  
        // int的二进制位数为4个字节，共32位数据，由于二进制的索引是从0开始，所以为0-31  
        // 那么我们想要打印出某位的数，只需要将数字与某位上的1进行与运算即可        
        int max = 31;  
        for (int i = max; i >= 0; i--) {  
            // 这里如果某位上是0，则位与后的数等于0，如果某位是1，则位与后的数肯定不等于0  
            char c = (num & (1 << i)) == 0 ? '0' : '1';  
            System.out.print(c);  
        }  
    }  
  
    /**  
     * 延伸：原码，反码，补码     
     * 1)最高位0表示正数，1表示负数；     
     * 2)由于Java中的int为有符号整型，且0归为非负范围，所以int类型的数值范围为-2^31 - 2^31-1    
     * 3)
     * 正数最高位为0，其他0-30位表示数值，原码     
     * 负数最高位为1，其他0-30位需要取反+1（可以进位到31位），补码     
     * 0的最高位为0，其他0-30位都为0     
     * 4)一个数的相反数 等于其取反+1，即：-N == (~N + 1)     
     * 由于正数范围比负数范围小1，所以最小负数的相反数还是其自身
     * 5)常用的位运算：
     * &位与
     * |位或
     * ^异或
     * ～取反
     * 
     * */    
     private static void test() {  
        // 先看下最大正数的二进制表示  
		// 最大正数，31位符号位为0，0-31位是1        
		System.out.println(Integer.MAX_VALUE); // 2147483647  
        print(Integer.MAX_VALUE); // 01111111111111111111111111111111  
  
        System.out.println();  
        System.out.println("=======");  
  
        // 再看下最小负数的二进制表示  
        // 最小负数，31位符号为1，0-31位是0        
        // ? 为什么有反直觉，我们认为最小的负数，除符号位之外其他位不应该是数值越大，就是越小吗？   
        // 其实，这里就是补码的原因：取反加一        
        // 10000000000000000000000000000000        
        // 最高位是1，代表是负数        
        // 其他位取反+1，是10000000000000000000000000000000，也就是2^31        
        // 所以是-2^31        
        System.out.println(Integer.MIN_VALUE);// -2147483648  
        print(Integer.MIN_VALUE);// 10000000000000000000000000000000  
  
        System.out.println();  
        System.out.println("=======");  
  
        // 最后看下怎么求一个数的相反数  
        // 最简单的方式加个负号        
        int N = 5; 
        // 00000000000000000000000000000101  
        print(N);   
        System.out.println();  
        int reverseN = -N;  
        // 11111111111111111111111111111011  
        print(reverseN);  
        System.out.println();  
        // 11111111111111111111111111111011  
        int reverseN2 = (~N + 1);  
        print(reverseN2);  
        System.out.println();  
    }  
  
}
```

	注：>>> 不带符号右移，>> 带符号右移；
	无符号右移：正负数在最高位均补0
	有符号右移：正数的最高位补0，负数的最高位补1

### 时间复杂度

```
常数时间操作：固定时间操作，与数据量N无关的操作。

常见的常数时间操作：

1）算术运算

2）位移运算

3）比较运算

4）赋值运算

5）寻址运算

6）自增自减运算
```

```
Big O(n)：时间复杂度是与数据量N相关的估算函数，N->无穷大时，忽略常数项与低阶项。
```



### 时间复杂度：冒泡排序




```java
import java.util.Arrays;

public class TimeComplexity4BubbleSort {

    public static void main(String[] args) {
        int[] arr = {43, 12, 3, 78, 90, 45};
        bubbleSort(arr);
        System.out.println("arr = " + Arrays.toString(arr));
    }


    /**
     * 那么冒泡排序的时间复杂度为多少，我们可以看下内层的循环计算出总的次数
     * 1~end=>1~N-1=>N-1
     * 1~end=>1~N-2=>N-2
     * ...
     * 1~end=>1~1=>1
     * 1~end=>1~0=>0
     * 构成等差数列 1,2,...,N-1
     * 根据等差数列求和公式可得
     * S=N(N-1)/2 ==> O(n)=O(n power 2)
     *
     * 那再看下稳定度：
     * bubbleSort,用>号比较时，是稳定的
     */
    public static void bubbleSort(int[] arr) {
        // 边界条件
        if (arr == null || arr.length < 2) {
            return;
        }
        // bubbleSort
        // 0~N-1 两两比较 大值向后移
        // 0~N-2
        // 0~i
        // 0~0
        // 左端点不变，右端点递减
        int N = arr.length;
        for (int end = N - 1; end >= 0; end--) {
            // 两两比较交换
            // 0,1;1,2;2,3;...;end-1,end
            // 可以看到右端点从1递增到end
            for (int right = 1; right <= end; right++) {
                // left > right => swap
                if (arr[right - 1] > arr[right]) {
                    swap(arr, right - 1, right);
                }
            }
        }
    }

    private static void swap(int[] arr, int left, int right) {
        int temp = arr[left];
        arr[left] = arr[right];
        arr[right] = temp;
    }
}
```



### 时间复杂度：选择排序



```java
import java.util.Arrays;

public class TimeComplexity4SelectSort {

    public static void main(String[] args) {
        int[] arr = {43, 12, 3, 78, 90, 45};
        selectSort(arr);
        System.out.println("arr = " + Arrays.toString(arr));
    }

    /**
     * 看下选择排序的时间复杂度：
     * 看下内层的循环
     * 1~N-1 => N-1
     * 2~N-1 => N-2
     * N-1~N-1 => 1
     * 构成等差数列：所以
     * O(n) = O(n power 2)
     * <p>
     * 再看下稳定度
     * 有如下的数组：33,45,33,12
     * 则33,12换换后，原两个33相对位置改变，不稳定
     */
    public static void selectSort(int[] arr) {
        //  边界条件
        if (arr == null || arr.length < 2) {
            return;
        }
        // selectSort
        // 0~N-1 找到最小值 与 0 位置交换
        // 1~N-1
        // 2~N-1
        // i~N-1
        // N-1~N-1
        // 可以看到左端点依次递增，右端点不变
        int N = arr.length;
        for (int i = 0; i < N; i++) {
            // i 默认为最小值的索引
            int minNumIndex = i;
            // 如果 后面的数 有比 最小值索引代表的数 小，则记录
            for (int j = i + 1; j < N; j++) {
                if (arr[j] < arr[minNumIndex]) {
                    minNumIndex = j;
                }
            }
            // 交换i,minNumIndex
            swap(arr, i, minNumIndex);
        }
    }

    private static void swap(int[] arr, int left, int right) {
        int temp = arr[left];
        arr[left] = arr[right];
        arr[right] = temp;
    }
}

```



### 时间复杂度：插入排序



```java
import java.util.Arrays;

public class TimeComplexity4InsertSort {

    public static void main(String[] args) {
        int[] arr = {43, 12, 3, 78, 90, 45};
        insertSort(arr);
        System.out.println("arr = " + Arrays.toString(arr));
    }

    /**
     * 插入排序insertSort
     * 类似于打扑克牌
     * <p>
     * 首先看下时间复杂度
     * 我们想像一个最差的情况
     * 有个逆序的数组
     * 5,4,3,2,1
     * 现在要将此数组从小到大排序
     * 0~1=>1
     * 0~2=>2
     * 0~i=>i
     * 0~N-1=>N-1
     * 构成等差数列，时间复杂度O(n) = O(n power 2)
     * <p>
     * 再看下稳定度，当比较符号为>号时
     * 是稳定的
     */
    public static void insertSort(int[] arr) {
        // 边界条件
        if (arr == null || arr.length < 2) {
            return;
        }
        // insertSort
        // 0~0 有序
        // 0~1
        // 0~2
        // 0~i
        // 0~N-1
        // 左端点不变，右端点依次递增
        int N = arr.length;
        for (int i = 1; i < N; i++) {
            // i位置作为新加入的数，要与前面有序的数进行比较
            int newNumIndex = i;
            while ((newNumIndex - 1) >= 0 && arr[newNumIndex - 1] > arr[newNumIndex]) {
                swap(arr, newNumIndex - 1, newNumIndex);
                newNumIndex--;
            }
        }
    }

    private static void swap(int[] arr, int left, int right) {
        // 用eor(exclusive or)进行交换两数时，左右指针不能相同
        // 如果相同时，则两数相等，异或的值为0
        // 异或 == 无进位的位运算相加
        if (left == right) {
            return;
        }
        arr[left] = arr[left] ^ arr[right];
        arr[right] = arr[left] ^ arr[right];
        arr[left] = arr[left] ^ arr[right];
    }
}


```



### 额外空间复杂度



```
额外空间复杂度：关键是额外两字，就是入参、出参所需的空间不算额外，在算法过程中需要支持你算法运行的其他空间是额外空间复杂度。

如果只是有限几个变量，额外空间复杂度为O(1)
```



### 时间复杂度中的常数项



```
这里所说的常数项，准确说是时间复杂度函数前的常数系数。

如果我们的时间复杂度一样，就到比拼常数项阶段，一般都是实测来确定谁的常数项更好，更省时。
```



### 算法的最优解



```
时间复杂度>额外空间复杂度>常数项
```



### 对数器



```java
package com.aitx.study.base;

public class NumComparer {

    /**
     * 生成随机数组
     *
     * @param maxLength 数组最大长度，[0,maxLength]
     * @param maxValue  数组元素最大值，[-maxValue,maxValue]
     * @return 随机数组
     */
    private static int[] generateRandomArr(int maxLength, int maxValue) {
      	// [0,maxLength]
        int length = (int) (Math.random() * (maxLength + 1));
        int[] result = new int[length];
        for (int i = 0; i < length; i++) {
            result[i] = generateRandomValue(maxValue);
        }
        return result;
    }

    /**
     * 生成随机整数
     *
     * @param maxValue 最大值 [-maxValue,maxValue]
     * @return 生成随机的整数
     */
    private static int generateRandomValue(int maxValue) {
        // [0,maxValue] - [0,maxValue] ==> [-maxValue,maxValue]
        return ((int) (Math.random() * (maxValue + 1))) - ((int) (Math.random() * (maxValue + 1)));
    }
}

```



### 通过二分法判断数是否存在于数组中



```java
import java.util.Arrays;

public class BinarySearchExist {

    public static void main(String[] args) {
        int loopTimes = 100000;
        for (int i = 0; i < loopTimes; i++) {
            int[] randomArray = generateRandomArray(10, 100);
            // 注意，必须是有序数组
            Arrays.sort(randomArray);
            int target = ((int) (Math.random() * (100 + 1))) - ((int) (Math.random() * 100));
            boolean b1 = sequenceSearch(randomArray, target);
            boolean b2 = binarySearchExist(randomArray, target);
            if (b1 != b2) {
                System.out.println("randomArray=" + Arrays.toString(randomArray) + ", target=" + target);
            }
        }
    }

    /**
     * 通过二分查找来查看目标值是否存在数组中
     */
    public static boolean binarySearchExist(int[] arr, int target) {
        // 边界条件
        if (arr == null || arr.length == 0) {
            return false;
        }
        int L = 0;
        int R = arr.length - 1; 
      	// 注意，这里R是有效值，所以是闭区间
        // 所以我们这里可以用<=,当我们用<时，代表数组至少有2个数
        // 如下的写法就是代表至少有2个数，用<号
        while (L < R) {
            int mid = L + ((R - L) >> 1);
            if (arr[mid] == target) {
                return true;
            } else if (target < arr[mid]) {
                R = mid - 1;
            } else {
                L = mid + 1;
            }
        }
        // 因为上面用啊L<R，只覆盖了至少2个元素的数组
        // 这里要覆盖下只有1个数的场景
        return arr[L] == target;
    }

    // 对数器，产生随机数组
    public static int[] generateRandomArray(int maxLength, int maxValue) {
        int length = (int) (Math.random() * (maxLength + 1));
        int[] result = new int[length];
        for (int i = 0; i < length; i++) {
            int value = ((int) (Math.random() * (maxValue + 1))) - ((int) (Math.random() * maxValue));
            result[i] = value;
        }
        return result;
    }

    // 线性搜索
    public static boolean sequenceSearch(int[] arr, int target) {
        // 边界条件
        if (arr == null || arr.length == 0) {
            return false;
        }
        for (int i = 0; i < arr.length; i++) {
            if (target == arr[i]) {
                return true;
            }
        }
        return false;
    }


}

```



### 在数组中找到>=target最左边的值的索引



```java
public class BinaryNearLeft {

    // 在数组中，找到>=target 最左边的值的索引
    // 分析：原来二分查找是查找=target值，现在查找>=target也可以用二分法
    public static int binarySearchNearLeft(int[] arr, int target) {
        // 边界条件
        if (arr == null || arr.length == 0) {
            return -1;
        }
        int L = 0;
        int R = arr.length - 1;
        // 闭区间，可以取到R
        int targetIndex = -1;
        while (L <= R) {
            int mid = L + ((R - L) >> 1);
            if (arr[mid] >= target) {
                // 如果mid满足条件，将看看左边
                targetIndex = mid;
                R = mid - 1;
            } else {
                // 看下右边有没有
                L = mid + 1;
            }
        }
        return targetIndex;
    }
}

```



### 在数组上找满足<=value的最右位置



```java
public class BinaryNearRight {

    // 在arr上，找满足<=value的最右位置
    public static int binarySearchNearRight(int[] arr, int target) {
        // 边界条界
        if (arr == null || arr.length == 0) {
            return -1;
        }
        int L = 0;
        int R = arr.length - 1;
        int targetIndex = -1;
        while (L <= R) {
            int mid = L + ((R - L) >> 1);
            if (arr[mid] <= target) {
                targetIndex = mid;
                L = mid + 1;
            } else {
                R = mid - 1;
            }
        }
        return targetIndex;
    }
}

```



### 求数组的局部最小值



```java
import java.util.Arrays;

public class BinarySearchLocalMinValue {


    public static void main(String[] args) {
        int loopTimes = 100000;
        for (int i = 0; i < loopTimes; i++) {
            int[] randomArr = generateRandomArrayLeftNotEqualRight(10, 100);
            int index = localMin(randomArr);
            if (!isRightLocalMinValue(randomArr, index)) {
                System.out.println("fault, arr=" + Arrays.toString(randomArr) + ", index=" + index);
                break;
            }
        }
    }

    // 一个数组，左右元素各不相等，求此数组的局部极小值的索引位置
    public static int localMin(int[] arr) {
        // 边界条件
        if (arr == null || arr.length == 0) {
            return -1;
        }
        // 如果只有一个元素，则认为就是局部最小值
        if (arr.length == 1) {
            return 0;
        }
        // 走到这，代表至少2个元素
        // 看下左端点
        if (arr[0] < arr[1]) {
            return 0;
        }
        // 看下右端点
        if (arr[arr.length - 1] < arr[arr.length - 2]) {
            return arr.length - 1;
        }
        // 走到这，代表左端点处是 下降，右端点处是 上升，所以在[1,arr.length-2]区间内必有局部最小值
        int L = 1;
        int R = arr.length - 2;
        // 这里保证3个不相等的数
        while (L <= R) {
            int mid = L + ((R - L) >> 1);
            if ((arr[mid] < arr[mid - 1]) && (arr[mid] < arr[mid + 1])) {
                return mid;
            } else if (arr[mid] > arr[mid - 1]) {
                R = mid - 1;
            } else {
                L = mid + 1;
            }
        }
        // 走到这，代表只有2个数,但前面已判断2个数的情况，所以直接返回-1
        return -1;
    }

    // 判断是否为正确的局部最小值
    public static boolean isRightLocalMinValue(int[] arr, int index) {
        if (arr == null || arr.length == 0) {
            return index == -1;
        }
        if (arr.length == 1) {
            return index == 0;
        }
        // 走到这，代表长度至少为2
        if (index == 0) {
            return arr[0] < arr[1];
        }
        if (index == (arr.length - 1)) {
            return arr[arr.length - 1] < arr[arr.length - 2];
        }
        // 不是左右端点，代表至少3个数
        return (arr[index] < arr[index - 1]) && (arr[index] < arr[index + 1]);
    }

    // 生成左右不值不相等的数组
    private static int[] generateRandomArrayLeftNotEqualRight(int maxLength, int maxValue) {
        int length = (int) (Math.random() * (maxLength + 1));
        int[] arr = new int[length];
        if (length == 0) {
            return arr;
        }
        // 走到这，代表数组长度至少为1
        arr[0] = ((int) (Math.random() * (maxValue + 1))) - ((int) (Math.random() * (maxValue)));
        for (int i = 1; i < length; i++) {
            int value;
            do {
                value = ((int) (Math.random() * (maxValue + 1))) - ((int) (Math.random() * (maxValue)));
            } while (value == arr[i - 1]);
            arr[i] = value;
        }
        return arr;
    }

}

```





### 异或运算



```
异或运算：相同为0，不同为1

同或运算：相同为1，不同为0

异或运算 就相当于 无进位的相加

0 ^ N = N

N ^ N = 0

异或运算 满足交换律、结合律
```



### 不用额外空间实现两数交换



```java
public class SwapTwoNum {

    public static void main(String[] args) {

        int a = 3;
        int b = 4;

        a = a ^ b;
        b = a ^ b; // 原a ^ 原b ^ 原b == 原a ^ 0 = 原a
        a = a ^ b; // 原a ^ 原b ^ 原a == 0 ^ 原b = 原b

        // 用异或实现 交换两数
        System.out.println("a = " + a);
        System.out.println("b = " + b);


    }

    private static void swap(int[] arr, int left, int right) {
        // 如果left == right
        // 则
        // arr[left] = arr[left] ^ arr[left] = 0
        // arr[right] = 0 ^ 0 = 0
        // arr[left] = 0 ^ 0 = 0
        // 会将两数直接变成0，所以如果索引相同时，不能用异或eor来运算
      	// eor == exlusive or
      	// 也就是用异或两个数在内存中不能是同一内存空间
        //
        // 再考虑如果left != right,但arr[left] == arr[right]
        // arr[left] = 0
        // arr[right] = 0 ^ o-arr[right] = o-arr[right]
        // arr[left] = 0 ^ arr[right] = o-arr[right] = o-arr[left]
        // 所以两数相等，但索引不同，可以用异或进行交换
        if (left == right) {
            return;
        }
        arr[left] = arr[left] ^ arr[right];
        arr[right] = arr[left] ^ arr[right];
        arr[left] = arr[left] ^ arr[right];
    }
}
```



### 数组中只有一个数是奇数次个，求这个数



```java
public class OnlyOneIsOddNumArray {

    public static void main(String[] args) {
        int[] arr = {3, 3, 3, 4, 4, 5, 5, 5, 5};
        int num = onlyOneIsOddNum(arr);
        System.out.println("num = " + num); // num = 3
    }

  	// 解法二：用异或解决
    // 数组中只有一个数是奇数次个，求这个数
    private static int onlyOneIsOddNum(int[] arr) {
        // N ^ N = 0
        // 0 ^ N = N
        int eor = 0;
        for (int i = 0; i < arr.length; i++) {
            eor ^= arr[i];
        }
        return eor;
    }
  
  	// 解法一：用HashMap装词频，暴力解法
}
```



### 将int类型的数提取出最右侧的1(位运算视角)



```java
package com.aitx.study.base;

/**
 * 将int类型的数提取出最右侧的1,比如13，二进制数为1101，最右侧的1就是0001（十进制为1）
 */
public class getIntegerRightOne {

    public static void main(String[] args) {
        int testTimes = 10000;
        int maxValue = Integer.MAX_VALUE;
        for (int i = 0; i < testTimes; i++) {
            int num = getRandomValue(maxValue);
            if (getIntegerRightOne1(num) != getIntegerRightOne2(num)) {
                System.out.println("error" + num);
            }
        }
    }

    /**
     * 解法二：位与处理，
     * N & (-N) == N & (~N + 1)
     * 这里有个知识点就是 相反数 == 原数取反+1
     * 比如1101 0000 ^ (0010 1111 再加1,也就是0011 0000 )
     * 1101 0000 & 0011 0000
     * 也就求出最右侧的1了
     */
    private static int getIntegerRightOne2(int num) {
        return num & (-num);
    }


    /**
     * 解法一：找出int的二进制展示，并求出最右侧1的索引
     */
    private static int getIntegerRightOne1(int num) {
        String integerBinaryBitShow = getIntegerBinaryBitShow(num);
        String reverse = new StringBuilder(integerBinaryBitShow).reverse().toString();
        int index = reverse.indexOf('1');
        if (index == 31) {
            return Integer.MIN_VALUE;
        } else if (index == -1) {
            return 0;
        } else {
            return (1 << (index));
        }
    }


    private static String getIntegerBinaryBitShow(int num) {
        StringBuilder sb = new StringBuilder();
        // 索引为：0-31,依次递减
        for (int i = 31; i >= 0; i--) {
            char c = (num & (1 << i)) == 0 ? '0' : '1';
            sb.append(c);
        }
        return sb.toString();
    }


    // test
    private static int getRandomValue(int maxValue) {
        // [0,maxValue] - [0,maxValue] == [-maxValue,maxValue]
        return ((int) (Math.random() * (maxValue + 1))) - (int) (Math.random() * (maxValue + 1));
    }
}

```



### 数组中只有两种数出现奇数次，求出这两种数



```java
public class OnlyTwoOddNumArray {

    public static void main(String[] args) {
        int[] arr = {3, 4, 5, 5, 6, 6, 6, 6};
        onlyTwoOddNum(arr);
    }

  	// 解法二：异或
    // 数组中只有两种数出现奇数次，求出这两种数
    public static void onlyTwoOddNum(int[] arr) {
        // 进行异或运算消掉偶次个的数
        int eor = 0;
        for (int i = 0; i < arr.length; i++) {
            eor ^= arr[i];
        }
        // 循环结束，eor = a ^ b ( a != b)
        // 显然 a != b 肯定有位上是不同的，我们将eor最右侧的1提取出来
        int rightOne = eor & (-eor);
      	// int rightOne = eor & (~eor + 1);
        // 那么此时原数组的数可以分为二类：在此位上是1的、在此位上是0的
        int a = 0;
        for (int i = 0; i < arr.length; i++) {
            // 确定此位是1的情况,那第此区中必然只有一个是奇数个
            if ((arr[i] & rightOne) != 0) {
                a ^= arr[i];
            }
        }
        // 输出a
        System.out.println("a = " + a);
        // 输出b
        int b = eor ^ a;
        System.out.println("b = " + b);
    }
  
  	// 解法一：HashMap
}
```





### 求一个数二进制位上有几个1



```java
public class Bit1Count {

    public static void main(String[] args) {
        int count = bit1counts(14);
        System.out.println("count = " + count);
    }
		
  	// 解法二：位与运算，求最右边1，再异或消除，直到N==0
    // 求一个数有几个1，就是看一个数二进制位上有几个1
    public static int bit1counts(int N) {
        int count = 0;

        //   011011010000
        //   000000010000     1

        //   011011000000
        //

        // 看一个数有几个1，就是不断的将位的1消去，最后N==0
        while (N != 0) {
            // 求一个数最右侧的1，就是此数与相反数 位与，也等同于 此数与（取反 +1的数）位与
            int rightOne = N & ((~N) + 1);
            // 计算有几个1
            count++;
            // 异或运算，是无进位相加
            // 这里相当于，将原来的数最右的1消掉
            N ^= rightOne;
            // N -= rightOne
        }

        return count;
    }
  	// 解法一：求出一个数的二进制表示，最后统计
}
```



### 将一个整型数转成二进制数组表示,数组0-31索引依次表示int型数的0-31位的情况



```java
package com.aitx.study.base;

import java.util.Arrays;

/**
 * 将一个整型数转成二进制数组表示,数组0-31索引依次表示int型数的0-31位的情况
 */
public class IntegerBinaryArrayShow {

    public static void main(String[] args) {
        int testTimes = 100000;
        int maxValue = 1000;
        for (int i = 0; i < testTimes; i++) {
            int num = generateRandomValue(maxValue);
            if (!Arrays.equals(getIntegerBinaryArrayShow1(num), getIntegerBinaryArrayShow2(num))) {
                System.out.println(num);
            }
        }
    }


    /**
     * 解法二：1不动，num左移
     */
    private static int[] getIntegerBinaryArrayShow1(int num) {
        int[] result = new int[32];
        for (int i = 0; i < 32; i++) {
            // 相当于只取num的0索引处的值
            int res = ((num >> i) & 1);
            result[i] = res;
        }
        return result;
    }

    /**
     * 解法一：1动且向左移，num不动
     */
    private static int[] getIntegerBinaryArrayShow2(int num) {
        int[] result = new int[32];
        for (int i = 31; i >= 0; i--) {
            // 注意，这里1是要左移
            result[i] = (num & (1 << i)) == 0 ? 0 : 1;
        }
        return result;
    }


    // test
    private static int generateRandomValue(int maxValue) {
        // [0,maxValue] - [0,maxValue] == [-maxValue,maxValue]
        return ((int) (Math.random() * (maxValue + 1))) - ((int) (Math.random() * (maxValue + 1)));
    }
}

```



### 一个数组中，存在一种数会出现K次，其他种类数出现M次，M>1,K<M,求出现K次的数为多少



```java
package com.aitx.study.base;


import java.util.*;
import java.util.stream.Collectors;

/**
 * 一个数组中，存在一种数会出现K次，其他种类数出现M次，M>1,K<M,求出现K次的数为多少、
 * 词频的暴力解法肯定用HashMap能解决
 * 这里相当于数组中存在其他数为偶数次的数，1个奇数次的数的拓展，所以这道题也可以用位运算来解决
 */
public class KM {


    /**
     * 解法一：通过32位数组统计某位上的1个数
     */
    private static int getKTimesNum(int[] arr, int K, int M) {
        int[] calc = new int[32];
        for (int num : arr) {
            // 相当于统计所有数在此位上1的个数
            for (int i = 0; i < 32; i++) {
                calc[i] += (num >> i) & 1;
            }
        }
        int ans = 0;
        for (int i = 0; i < 32; i++) {
            // 如果对M取模不等于0，代表此位上会出现K次1,也就是要求的数在此位为1
            if (calc[i] % M != 0) {
                ans |= 1 << i;
            }
        }
        return ans;
    }

    /**
     * 解法二：通过HashMap统计
     */
    private static int getKTimesNumByHashMap(int[] arr, int K, int M) {
        // key:num,value:times
        Map<Integer, Integer> map = new HashMap<>();
        for (int num : arr) {
            if (map.containsKey(num)) {
                map.put(num, map.get(num) + 1);
            } else {
                map.put(num, 1);
            }
        }
        for (Integer num : map.keySet()) {
            if (map.get(num) == K) {
                return num;
            }
        }
        throw new RuntimeException("找不到此数");
    }

    // for test
    private static int[] generateRandomArray(int maxKinds, int maxValue, int K, int M) {
        // 种类数：[0,maxKinds-2] + 2 == [2,maxKinds]
        int kinds = ((int) (Math.random() * (maxKinds - 1))) + 2;
        // 所以 数组总长度为 K + (kinds - 1) * M
        int length = K + (kinds - 1) * M;
        int[] result = new int[length];
        int index = 0;
        int kTimesNum = generateRandomValue(maxValue);
        // 填充出现K次的数
        for (; index < K; index++) {
            result[index] = kTimesNum;
        }
        kinds--;
        Set<Integer> set = new HashSet<>();
        set.add(kTimesNum);
        // 填加其他种类的数
        while (kinds != 0) {
            int curNum;
            do {
                curNum = generateRandomValue(maxValue);
            } while (set.contains(curNum));
            for (int i = 0; i < M; i++) {
                result[index++] = curNum;
            }
            set.add(curNum);
            kinds--;
        }
        // 将数组打乱
        for (int i = 0; i < length; i++) {
            // [0,length-1]
            int j = ((int) (Math.random() * (length)));
            int temp = result[i];
            result[i] = result[j];
            result[j] = temp;
        }
        return result;
    }

    // for test
    private static int generateRandomValue(int maxValue) {
        return ((int) (Math.random() * (maxValue + 1))) - ((int) (Math.random() * (maxValue + 1)));
    }

    // for test
    public static void main(String[] args) {
        int testTimes = 100000;
        int maxKinds = 5;
        int maxValue = 100;
        int KMMax = 9;
        for (int i = 0; i < testTimes; i++) {
            // [0,KMMax-1] + 1 == [1,KMMax]
            int a = (int) (Math.random() * KMMax) + 1;
            // [1,KMMax]
            int b = (int) (Math.random() * KMMax) + 1;
            int K = Math.min(a, b);
            int M = Math.max(a, b);
            if (K == M) {
                M = K + 1;
            }

            int[] arr = generateRandomArray(maxKinds, maxValue, K, M);
            if (getKTimesNum(arr, K, M) != getKTimesNumByHashMap(arr, K, M)) {
                System.out.println("arr=" + Arrays.toString(arr) + ",K=" + K + ",M=" + M);
            }
        }
    }
}

```



### 数据结构-链表



```java
/**
 * 单向链表
 */
public class Node<T> {

    // 数据域
    T val;

    // 指针域
    Node<T> next;
}

/**
 * 双向链表
 */
class DoubleNode<T> {

    // 数据域
    T val;

    // 指针域
    Node<T> pre;

    Node<T> next;
}
```



### 链表反转



```java
package com.aitx.study.base;

import java.util.ArrayList;
import java.util.List;

/**
 * 任何链表问题都可以有两种解法：1指针法；2容器法
 */
public class LinkedListReverse {


    private static class Node {
        int value;

        Node next;

        public Node(int value) {
            this.value = value;
        }
    }

    private static class DoubleNode {

        int value;

        DoubleNode pre;

        DoubleNode next;

        public DoubleNode(int value) {
            this.value = value;
        }

    }


    /**
     * 翻转单链表
     * a->b->c->null
     * null<-a<-b<-c
     */
    private static Node reverseSingleNode(Node head) {
        Node pre = null;
        Node next = null;
        while (head != null) {
            next = head.next;
            head.next = pre;
            pre = head;
            head = next;
        }
        // 跳出while循环后，head == null,pre == 最后一个节点
        // 此时pre就是第一个节点（也兼容head==null的场景）
        return pre;
    }

    /**
     * 翻转双向链表
     */
    private static DoubleNode reverseDoubleNode(DoubleNode head) {
        DoubleNode pre = null;
        DoubleNode next = null;
        while (head != null) {
            next = head.next;
            // 注意双向链表反转时next,pre都要调转方向
            head.next = pre;
            head.pre = next;
            pre = head;
            head = next;
        }
        // 跳出循环时，head == null，pre == 最后一个节点
        return pre;
    }

    /**
     * 通过容器的方式翻转单链表
     */
    private static Node reverseSingleNodeByContainer(Node head) {
        if (head == null) {
            return null;
        }
        // 走到这，代表肯定有1个及以上的节点
        List<Node> list = new ArrayList<>();
        while (head != null) {
            list.add(head);
            head = head.next;
        }
        int N = list.size();
        // 将
        list.get(0).next = null;
        for (int i = 1; i < N; i++) {
            list.get(i).next = list.get(i - 1);
        }
        return list.get(N - 1);
    }

    /**
     * 通过容器的方式翻转双向链表
     */
    private static DoubleNode reverseDoubleNodeByContainer(DoubleNode head) {
        // 任何时候都要用边界条件，没写边界，代表是输入不可能是边界条件或后面代码兼容边界条件
        if (head == null) {
            return null;
        }
        // 走到这，代表只有1个节点
        List<DoubleNode> list = new ArrayList<>();
        while (head != null) {
            list.add(head);
            head = head.next;
        }
        DoubleNode firstNode = list.get(0);
        firstNode.next = null;
        int N = list.size();
        for (int i = 1; i < N; i++) {
            DoubleNode doubleNode = list.get(i);
            doubleNode.next = list.get(i - 1);
            // 这里不能直接取i+1索引处的值，所以我们要用前一个节点的
            doubleNode.pre = null;
            list.get(i - 1).pre = doubleNode;
        }
        return list.get(N - 1);
    }

    // for test 生成随机单链表
    private static Node generateRandomSingleLinkedList(int maxLength, int maxValue) {
        int length = (int) (Math.random() * (maxLength + 1));
        if (length == 0) {
            return null;
        }
        // 先生成头
        length--;
        Node head = new Node(generateRandomValue(maxValue));
        Node cur = head;
        for (int i = 0; i < length; i++) {
            Node node = new Node(generateRandomValue(maxValue));
            cur.next = node;
            cur = node;
        }
        return head;
    }

    // for test 生成随机值
    private static int generateRandomValue(int maxValue) {
        return ((int) (Math.random() * (maxValue + 1))) - ((int) (Math.random() * (maxValue + 1)));
    }

    // fot test 生成随机双向链表
    private static DoubleNode generateRandomDoubleLinkedList(int maxLength, int maxValue) {
        int length = (int) (Math.random() * (maxLength + 1));
        if (length == 0) {
            return null;
        }
        // 先生成头
        length--;
        DoubleNode head = new DoubleNode(generateRandomValue(maxValue));
        DoubleNode cur = head;
        for (int i = 0; i < length; i++) {
            DoubleNode doubleNode = new DoubleNode(generateRandomValue(maxValue));
            cur.next = doubleNode;
            doubleNode.pre = cur;
            cur = doubleNode;
        }

        return head;

    }

    // fot test 获取原单向链表值 列表
    private static List<Integer> getOriginSingleLinkedValueList(Node head) {
        List<Integer> result = new ArrayList<>();
        while (head != null) {
            result.add(head.value);
            head = head.next;
        }
        return result;
    }

    // for test 获取原双向链表值 列表
    private static List<Integer> getOriginDoubleLinkedValueList(DoubleNode head) {
        List<Integer> result = new ArrayList<>();
        while (head != null) {
            result.add(head.value);
            head = head.next;
        }
        return result;
    }

    // for test 检测单向链表是否已反转
    private static boolean checkSingleLinkedListIsReverse(List<Integer> originValueList, Node reverseHead) {
        int N = originValueList.size();
        for (int i = N - 1; i >= 0; i--) {
            if (!originValueList.get(i).equals(reverseHead.value)) {
                return false;
            }
            reverseHead = reverseHead.next;
        }
        if (reverseHead != null) {
            return false;
        }
        return true;
    }

    // for test 检测双向链表是否已反转
    private static boolean checkDoubleLinkedListIsReverse(List<Integer> originValueList, DoubleNode reverseHead) {
        int N = originValueList.size();
        DoubleNode end = null;
        for (int i = N - 1; i >= 0; i--) {
            if (!originValueList.get(i).equals(reverseHead.value)) {
                return false;
            }
            end = reverseHead;
            reverseHead = reverseHead.next;
        }
        // 循环结束时，正常情况下end就是最后一个节点
        // 想一下有没有可能双向链表中的一截刚好覆盖上面的list，那第此时end就是覆盖一截的最后一个节点
        if (reverseHead != null) {
            return false;
        }
        // 走这到，代表列表长度与链表长度一致
        for (int i = 0; i < N; i++) {
            if (!originValueList.get(i).equals(end.value)) {
                return false;
            }
            end = end.pre;
        }
        return true;
    }

    public static void main(String[] args) {
        int testTimes = 100000;
        int maxLength = 10;
        int maxValue = 100;
        for (int i = 0; i < testTimes; i++) {
            // 校验指针法反转单链表是否正确
            Node node1 = generateRandomSingleLinkedList(maxLength, maxValue);
            if (!checkSingleLinkedListIsReverse(getOriginSingleLinkedValueList(node1), reverseSingleNode(node1))) {
                System.out.println("checkSingleLinkedListIsReverse-pointer fail");
                break;
            }
            // 校验容器法反转单链表是否正确
            Node node2 = generateRandomSingleLinkedList(maxLength, maxValue);
            if (!checkSingleLinkedListIsReverse(getOriginSingleLinkedValueList(node2), reverseSingleNodeByContainer(node2))) {
                System.out.println("checkSingleLinkedListIsReverse-container fail");
            }
            // 校验指针法反转双向链表是否正确
            DoubleNode doubleNode1 = generateRandomDoubleLinkedList(maxLength, maxValue);
            if (!checkDoubleLinkedListIsReverse(getOriginDoubleLinkedValueList(doubleNode1), reverseDoubleNode(doubleNode1))) {
                System.out.println("checkDoubleLinkedListIsReverse-pointer fail");
                break;
            }
            DoubleNode doubleNode2 = generateRandomDoubleLinkedList(maxLength, maxValue);
            if (!checkDoubleLinkedListIsReverse(getOriginDoubleLinkedValueList(doubleNode2), doubleNode2)) {
                System.out.println("checkDoubleLinkedListIsReverse-container fail");
                break;
            }
        }

    }
}

```



### 根据给定值删除链表节点



```java
package com.aitx.study.base;

import java.util.ArrayList;
import java.util.List;

/**
 * 通过给定值删除链表节点
 */
public class DeleteLinkedListNodeByGiveValue {


    private static class Node {

        int value;

        Node next;

        public Node(int value) {
            this.value = value;
        }
    }

    // 解法一：指针法
    private static Node deleteByGivenValue(Node head, int val) {
        // 边界
        if (head == null) {
            return null;
        }

        // 有可能头结点就是val值，所以要找到第一个不是val的节点
        while (head != null) {
            if (head.value != val) {
                break;
            }
            head = head.next;
        }
        // 退出while循环时，要么head == null 或者 head.value != val
        if (head == null) {
            return null;
        }
        Node cur = head;
        Node pre = head;
        while (cur != null) {
            if (cur.value == val) {
                pre.next = cur.next;
                cur = cur.next;
            } else {
                pre = cur;
                cur = cur.next;
            }
        }
        return head;
    }

    // 解法二：指针加强法：dummy Node
    private static Node deleteByGivenValue2(Node head, int val) {
        if (head == null) {
            return null;
        }
        Node dummyNode = new Node(Integer.MIN_VALUE);
        dummyNode.next = head;

        Node pre = dummyNode;
        Node cur = head;
        while (cur != null) {
            if (cur.value == val) {
                pre.next = cur.next;
                cur = cur.next;
            } else {
                pre = cur;
                cur = cur.next;
            }
        }
        // 退出while循环后，cur == null
        return dummyNode.next;
    }

    // 解法三：容器法
    private static Node deleteByGivenValueContainer(Node head, int val) {
        if (head == null) {
            return null;
        }
        List<Node> result = new ArrayList<>();
        while (head != null) {
            result.add(head);
            head = head.next;
        }
        // 满足条件时移除节点
        result.removeIf(node -> node.value == val);
        if (result.size() == 0) {
            return null;
        }
        // 显然这时候要重建链表
        Node firstNode = result.get(0);
        firstNode.next = null;
        int N = result.size();
        Node pre = firstNode;
        for (int i = 1; i < N; i++) {
            Node node = result.get(i);
            pre.next = node;
            node.next = null;
            pre = node;
        }

        return firstNode;

    }

    // for test 生成随机值
    private static int generateRandomValue(int maxValue) {
        return ((int) (Math.random() * (maxValue + 1))) - ((int) (Math.random() * (maxValue + 1)));
    }

    // for test 生成随机链表
    private static Node generateRandomLinkedList(int maxLength, int maxValue) {
        int length = (int) (Math.random() * (maxLength + 1));
        if (length == 0) {
            return null;
        }
        // 生成头节点
        length--;
        Node head = new Node(generateRandomValue(maxValue));
        Node cur = head;
        for (int i = 0; i < length; i++) {
            Node node = new Node(generateRandomValue(maxValue));
            cur.next = node;
            cur = node;
        }

        return head;
    }

    // for test 获取链表值 列表
    private static List<Integer> getLinkedListValueList(Node head) {
        if (head == null) {
            return new ArrayList<>();
        }
        List<Integer> result = new ArrayList<>();
        while (head != null) {
            result.add(head.value);
            head = head.next;
        }
        // 退出while循环时，head == null
        return result;
    }

    // for test 复制链表(值顺序一样)
    private static Node copyLinkedList(Node head) {
        if (head == null) {
            return null;
        }
        // 先构造头
        Node copyHead = new Node(head.value);
        Node curCopy = copyHead;
        Node cur = head.next;
        while (cur != null) {
            Node node = new Node(cur.value);
            curCopy.next = node;
            cur = cur.next;
            curCopy = node;
        }
        return copyHead;
    }

    public static void main(String[] args) {
        int testTimes = 100000;
        int maxLength = 10;
        int maxValue = 100;
        for (int i = 0; i < testTimes; i++) {
            Node head = generateRandomLinkedList(maxLength, maxValue);
            Node copyHead = copyLinkedList(head);
            if (!getLinkedListValueList(head).equals(getLinkedListValueList(copyHead))) {
                System.out.println("error");
                break;
            }
        }
    }


}

```



