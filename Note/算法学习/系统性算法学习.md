

---

author: aitx

title: 系统性算法学习

time: 2023-12-17 周六

tags: 
  - 算法
  - 学习
  - 编程

---

## 基础入门



### 阶乘和

```java
package com.aitx.study.base;  
  
/**  
 * 阶乘和 * 给定一个参数N， 
 * 返回：  1! + 2! + 3! + 4! + … + N!   的结果 
 * <p>  
 * 思路： * 一、求每部分后再加和 * 二、后一个跟前一个有关系，直接求和 
 * */
 public class Code001_Factorial {  
  
  
    /**  
     * 思路一：求每部分后再加和     
     * */    
    public static int factorialSum(int N) {  
        int sum = 0;  
        for (int i = 1; i <= N; i++) {  
            sum += factorial(i);  
        }  
        return sum;  
    }  
  
    // 求每部分的值  
    private static int factorial(int N) {  
        int result = 1;  
        for (int i = 1; i <= N; i++) {  
            result *= i;  
        }  
        return result;  
    }  
  
    /**  
     * 思路二：后一个跟前一个有关系，直接求和     
     * */
	public static int factorialSumNew(int N) {  
        int sum = 0;  
        int fac = 1;  
        for (int i = 1; i <= N; i++) {  
            fac *= i;  
            sum += fac;  
        }  
        return sum;  
    }  
  
}
```



### 位运算



#### 二进制与位运算简介

```
二进制：用0、1表示，逢二进一

位运算：与&，或｜，非！，异或^

```



#### 打印int类型的二进制数表示

```
打印一个int型数的二进制表示， 比如5的二进制表示为00000000000000000000000000000101 
```

```java
package com.aitx.study.base;  
  
/**
 * 将一个数的二进制表示打印出来
 * <p>
 * 思路：
 * int型数占用4字节32位，打印二进制表示相当于 通过位运算取出各个位置的01打印出来
 * <p>
 * 其他相关：
 * 二进制转十进制，系数 * 2^n
 * 十进数转二进制，小数点前：除以2取余 从下向上写，小数点后：乘以2取整数，从上向下写
 * <p>
 * 一个数的相反数 就是 此数取反加一
 */
 public class PrintInteger2RadixNum {  
  
  
    public static void main(String[] args) {  
        int num = 5;  
        print(5);  
        System.out.println();  
        System.out.println("=======");  
        test();  
    }  
  
    /**  
     * 打印一个int型数的二进制表示   
     * @param num int类型的数  
     */    
     private static void print(int num) {  
        // int的二进制位数为4个字节，共32位数据，由于二进制的索引是从0开始，所以为0-31  
        // 那么我们想要打印出某位的数，只需要将数字与某位上的1进行与运算即可        
        int max = 31;  
        for (int i = max; i >= 0; i--) {  
            // 这里如果某位上是0，则位与后的数等于0，如果某位是1，则位与后的数肯定不等于0  
            char c = (num & (1 << i)) == 0 ? '0' : '1';  
            System.out.print(c);  
        }  
    }  
  
    /**  
     * 延伸：原码，反码，补码     
     * 1)最高位0表示正数，1表示负数；     
     * 2)由于Java中的int为有符号整型，且0归为非负范围，所以int类型的数值范围为-2^31 - 2^31-1    
     * 3)
     * 正数最高位为0，其他0-30位表示数值，原码     
     * 负数最高位为1，其他0-30位需要取反+1（可以进位到31位），补码     
     * 0的最高位为0，其他0-30位都为0     
     * 4)一个数的相反数 等于其取反+1，即：-N == (~N + 1)     
     * 由于正数范围比负数范围小1，所以最小负数的相反数还是其自身
     * 5)常用的位运算：
     * &位与
     * |位或
     * ^异或
     * ～取反
     * 
     * */    
     private static void test() {  
        // 先看下最大正数的二进制表示  
		// 最大正数，31位符号位为0，0-31位是1        
		System.out.println(Integer.MAX_VALUE); // 2147483647  
        print(Integer.MAX_VALUE); // 01111111111111111111111111111111  
  
        System.out.println();  
        System.out.println("=======");  
  
        // 再看下最小负数的二进制表示  
        // 最小负数，31位符号为1，0-31位是0        
        // ? 为什么有反直觉，我们认为最小的负数，除符号位之外其他位不应该是数值越大，就是越小吗？   
        // 其实，这里就是补码的原因：取反加一        
        // 10000000000000000000000000000000        
        // 最高位是1，代表是负数        
        // 其他位取反+1，是10000000000000000000000000000000，也就是2^31        
        // 所以是-2^31        
        System.out.println(Integer.MIN_VALUE);// -2147483648  
        print(Integer.MIN_VALUE);// 10000000000000000000000000000000  
  
        System.out.println();  
        System.out.println("=======");  
  
        // 最后看下怎么求一个数的相反数  
        // 最简单的方式加个负号        
        int N = 5; 
        // 00000000000000000000000000000101  
        print(N);   
        System.out.println();  
        int reverseN = -N;  
        // 11111111111111111111111111111011  
        print(reverseN);  
        System.out.println();  
        // 11111111111111111111111111111011  
        int reverseN2 = (~N + 1);  
        print(reverseN2);  
        System.out.println();  
    }  
  
}
```

	注：>>> 不带符号右移，>> 带符号右移；
	无符号右移：正负数在最高位均补0
	有符号右移：正数的最高位补0，负数的最高位补1

### 时间复杂度

```
常数时间操作：固定时间操作，与数据量N无关的操作。（常数：Constant）

常见的常数时间操作：

1）算术运算

2）位移运算

3）比较运算

4）赋值运算

5）寻址运算

6）自增自减运算
```

```
Big O(n)：时间复杂度是与数据量N相关的估算函数，N->无穷大时，忽略常数项与低阶项。（big O指的是omega）
```



#### 时间复杂度：冒泡排序




```java
import java.util.Arrays;

public class TimeComplexity4BubbleSort {

    public static void main(String[] args) {
        int[] arr = {43, 12, 3, 78, 90, 45};
        bubbleSort(arr);
        System.out.println("arr = " + Arrays.toString(arr));
    }


    /**
     * 那么冒泡排序的时间复杂度为多少，我们可以看下内层的循环计算出总的次数
     * 1~end=>1~N-1=>N-1
     * 1~end=>1~N-2=>N-2
     * ...
     * 1~end=>1~1=>1
     * 1~end=>1~0=>0
     * 构成等差数列 1,2,...,N-1
     * 根据等差数列求和公式可得
     * S=N(N-1)/2 ==> O(n)=O(n^2)
     *
     * 那再看下稳定度：
     * bubbleSort,用>号比较时，是稳定的
     */
    public static void bubbleSort(int[] arr) {
        // 边界条件
        if (arr == null || arr.length < 2) {
            return;
        }
        // bubbleSort
        // 0~N-1 两两比较 大值向后移
        // 0~N-2
        // 0~i
        // 0~0
        // 左端点不变，右端点递减
        int N = arr.length;
        for (int end = N - 1; end >= 0; end--) {
            // 两两比较交换
            // 0,1;1,2;2,3;...;end-1,end
            // 可以看到右端点从1递增到end
            for (int right = 1; right <= end; right++) {
                // left > right => swap
                if (arr[right - 1] > arr[right]) {
                    swap(arr, right - 1, right);
                }
            }
        }
    }

    private static void swap(int[] arr, int left, int right) {
        int temp = arr[left];
        arr[left] = arr[right];
        arr[right] = temp;
    }
}
```



#### 时间复杂度：选择排序



```java
import java.util.Arrays;

public class TimeComplexity4SelectSort {

    public static void main(String[] args) {
        int[] arr = {43, 12, 3, 78, 90, 45};
        selectSort(arr);
        System.out.println("arr = " + Arrays.toString(arr));
    }

    /**
     * 看下选择排序的时间复杂度：
     * 看下内层的循环
     * 1~N-1 => N-1
     * 2~N-1 => N-2
     * N-1~N-1 => 1
     * 构成等差数列：所以
     * O(n) = O(n^2)
     * <p>
     * 再看下稳定度
     * 有如下的数组：33,45,33,12
     * 则33,12换换后，原两个33相对位置改变，不稳定
     */
    public static void selectSort(int[] arr) {
        //  边界条件
        if (arr == null || arr.length < 2) {
            return;
        }
        // selectSort
        // 0~N-1 找到最小值 与 0 位置交换
        // 1~N-1
        // 2~N-1
        // i~N-1
        // N-1~N-1
        // 可以看到左端点依次递增，右端点不变
        int N = arr.length;
        for (int i = 0; i < N; i++) {
            // i 默认为最小值的索引
            int minNumIndex = i;
            // 如果 后面的数 有比 最小值索引代表的数 小，则记录
            for (int j = i + 1; j < N; j++) {
                if (arr[j] < arr[minNumIndex]) {
                    minNumIndex = j;
                }
            }
            // 交换i,minNumIndex
            swap(arr, i, minNumIndex);
        }
    }

    private static void swap(int[] arr, int left, int right) {
        int temp = arr[left];
        arr[left] = arr[right];
        arr[right] = temp;
    }
}

```



#### 时间复杂度：插入排序



```java
import java.util.Arrays;

public class TimeComplexity4InsertSort {

    public static void main(String[] args) {
        int[] arr = {43, 12, 3, 78, 90, 45};
        insertSort(arr);
        System.out.println("arr = " + Arrays.toString(arr));
    }

    /**
     * 插入排序insertSort
     * 类似于打扑克牌
     * <p>
     * 首先看下时间复杂度
     * 我们想像一个最差的情况
     * 有个逆序的数组
     * 5,4,3,2,1
     * 现在要将此数组从小到大排序
     * 0~1=>1
     * 0~2=>2
     * 0~i=>i
     * 0~N-1=>N-1
     * 构成等差数列，时间复杂度O(n) = O(n power 2)
     * <p>
     * 再看下稳定度，当比较符号为>号时
     * 是稳定的
     */
    public static void insertSort(int[] arr) {
        // 边界条件
        if (arr == null || arr.length < 2) {
            return;
        }
        // insertSort
        // 0~0 有序
        // 0~1
        // 0~2
        // 0~i
        // 0~N-1
        // 左端点不变，右端点依次递增
        int N = arr.length;
        for (int i = 1; i < N; i++) {
            // i位置作为新加入的数，要与前面有序的数进行比较
            int newNumIndex = i;
            while ((newNumIndex - 1) >= 0 && arr[newNumIndex - 1] > arr[newNumIndex]) {
                swap(arr, newNumIndex - 1, newNumIndex);
                newNumIndex--;
            }
        }
    }

    private static void swap(int[] arr, int left, int right) {
        // 用eor(exclusive or)进行交换两数时，左右指针不能相同
        // 如果相同时，则两数相等，异或的值为0
        // 异或 == 无进位的位运算相加
        if (left == right) {
            return;
        }
        arr[left] = arr[left] ^ arr[right];
        arr[right] = arr[left] ^ arr[right];
        arr[left] = arr[left] ^ arr[right];
    }
}


```



#### 额外空间复杂度



```
额外空间复杂度：关键是额外两字，就是入参、出参所需的空间不算额外，在算法过程中需要支持你算法运行的其他空间是额外空间复杂度。

如果只是有限几个变量，额外空间复杂度为O(1)
```



#### 时间复杂度中的常数项



```
这里所说的常数项，准确说是时间复杂度函数前的常数系数。

如果我们的时间复杂度一样，就到比拼常数项阶段，一般都是实测来确定谁的常数项更好，更省时。
```



#### 算法的最优解



```
时间复杂度>额外空间复杂度>常数项
```



### 随机数



#### 验证Math.random()生成随机数是概率相等

```java
package com.aitx.study.base.code002;

import java.util.Arrays;

/**
 * 验证Math.random()生成随机数是概率相等
 * <p>
 * 一. 当x <=1,Math.random < x的概率就是x
 * 二. Math.random() * M < N 的概率就是(double) N / M
 * 三. (int)( Math.random() * (N+1) ) 后生成的各数[0,N] 概率相等
 */
public class Code002_VerifyRandom {

    public static void main(String[] args) {
        verify3();
    }

    // ---------------------------------------------

    // 一. 当x <=1,Math.random < x的概率就是x
    public static void verify1() {
        int testTimes = 100000;
        double x = 0.75;
        int count = 0;
        for (int i = 0; i < testTimes; i++) {
            if (Math.random() < x) {
                count++;
            }
        }
        System.out.println(x);
        System.out.println(((double) count) / testTimes);
    }

    // ---------------------------------------------
    // 二. Math.random() * M < N 的概率就是(double) N / M
    public static void verify2() {
        int M = 10;
        int N = 5;

        int testTimes = 100000;
        int count = 0;
        for (int i = 0; i < testTimes; i++) {
            if (Math.random() * M < N) {
                count++;
            }
        }
        System.out.println(((double) N) / M);
        System.out.println((double) count / testTimes);
    }

    // ---------------------------------------------
    // 三. (int)( Math.random() * (N) ) 后生成的各数[0,N-1] 概率相等
    public static void verify3() {
        int testTimes = 100000;
        int N = 10;

        int[] result = new int[N];
        for (int i = 0; i < testTimes; i++) {
            int ans = (int) (Math.random() * N);
            result[ans]++;
        }

        System.out.println(Arrays.toString(result));

    }


}

```



#### 利用Math.random()函数把得到[0,x)范围上的数的概率从x调整成x^2



```java
package com.aitx.study.base.code002;

/**
 * 如果利用Math.random()函数，
 * 如果x属于[0,1]
 * 把得到[0,x)范围上的数的概率从x调整成x^2
 * <p>
 * 思路：
 * 这里的x就是Math.random()的概率，现在要求x^2，也就是x * x，概据乘法原理，
 * 也就是两个Math.random()都要满足 < x，也就是 两个随机数最大值要满足 < x
 */
public class Code002_Random2Power2 {

    public static double x2Power2() {
        return Math.max(Math.random(), Math.random());
    }
}

```



#### 从1~5随机到1~7随机



```java
package com.aitx.study.base.code002;


/**
 * 从1~5随机到1~7随机
 * 存在函数f1()生成随机的等概率[1,5]，现在要创建函数f()生成随机的等概率[1,7]
 * <p>
 * 思路：先创建01生成器，再通过位移的方式生成随机数
 */
public class Code002_Random15ToRandom17 {


    // jar包中的函数f1()，生成随机的[1,5]
    public static int f1() {
        return ((int) (Math.random() * 5)) + 1;
    }

    // 第一步：01生成器
    private static int zeroOneGen() {
        int ans;

        do {
            ans = f1();
        } while (ans == 3);

        // 走到这，代表ans != 3;

        return ans < 3 ? 0 : 1;
    }

    // 01生成器 随机到 [1,7]
    public static int f() {
        int ans;
        do {
            // 01 -> [0,6]
            ans = (zeroOneGen() << 2) + (zeroOneGen() << 1) + zeroOneGen();
        } while (ans == 7);

        return ans + 1;
    }


}

```



#### 01不等概率随机到01等概率随机



```java
package com.aitx.study.base.code002;

/**
 * 01不等概率随机到01等概率随机
 * <p>
 * 思路：假设0的概率为p,则1的概率为1-p，根据乘法原理，
 * 00概率为pp
 * 01概率p(1-p)
 * 10概率p(1-p)
 * 11概率(1-p)(1-p)
 * <p>
 * 所以只要计算2次，要求第二次不等第一次，则概率就会变成相等
 */
public class Code002_ZeroOneProbabilityNot2Equal {

    // jar包存在不等概率的01生成器
    public static int zeroOneGenNot() {
        return Math.random() < 0.75 ? 0 : 1;
    }

    public static int zeroOneGen() {
        int ans;
        
        do {
            ans = zeroOneGenNot();
        } while (ans == zeroOneGenNot());

        // 走到这，代表 ans != 第二次生成的值
        return ans;
    }
}

```



#### 盲盒随机函数 到 指定的等概率随机函数



```java
package com.aitx.study.base.code002;

/**
 * 盲盒随机函数 到 指定的等概率随机函数
 * <p>
 * 给你一个RandomBox，能等概率随机出[min,max]间的值，这是唯一能借助的随机机制，
 * 现在要求等概率返回from~to范围上任何一个数
 * 要求from<=to
 */
public class Code002_RandomBox2Random {


    public static class RandomBox {

        int min;

        int max;

        public RandomBox(int min, int max) {
            this.min = min;
            this.max = max;
        }

        public int min() {
            return this.min;
        }

        public int max() {
            return this.max;
        }

        // 盲盒随机方法
        public int random() {
            // [0,max-min] + min ---> [min,max]
            return ((int) (Math.random() * (max - min + 1))) + min;
        }

    }

    // 最重要的 01生成器
    private static int zeroOneGen(RandomBox randomBox) {

        int min = randomBox.min();
        int max = randomBox.max();

        // 查看盲盒能生成多少个数
        int size = max - min + 1;
        // 是否为奇数
        boolean odd = size % 2 == 1;

        // 如果size是7，中位数就是3，左右索引理解为012，456，相当于要去掉3
        // 如果是8，中位数是4，0123 4567，相当于没有去除任何数
        int mid = size / 2;

        int ans;
        do {
            // [min,max] ---> [0,max-min]
            ans = randomBox.random() - min;
        } while (odd && ans == mid);

        return ans < mid ? 0 : 1;

    }

    /**
     * 给你一个RandomBox，能等概率随机出[min,max]间的值，这是唯一能借助的随机机制，
     * 现在要求等概率返回from~to范围上任何一个数
     * 要求from<=to
     */
    public static int random(RandomBox randomBox, int from, int to) {
        if (from == to) {
            return from;
        }
        // 走到这，代表from < to

        // 看看要表示多少个数
        int size = to - from + 1;

        // 要表示size个数至少要多少位的01
        int num = 1;
        while ((1 << num) < size) {
            num++;
        }
        // 跳出循环时，( 1 << num ) >= size
        int ans = 0;

        do {
            for (int i = 0; i < num; i++) {
                // [0,2^num]
                ans |= zeroOneGen(randomBox) << i;
            }
            // 超出的数字 重新生成
        } while (ans > (to - from));

        // 走到这，代表ans 属于 [0,to-from]
        
        return ans + from;
    }


}

```



### 对数器



```java
package com.aitx.study.base;

public class NumComparer {

    /**
     * 生成随机数组
     *
     * @param maxLength 数组最大长度，[0,maxLength]
     * @param maxValue  数组元素最大值，[-maxValue,maxValue]
     * @return 随机数组
     */
    private static int[] generateRandomArr(int maxLength, int maxValue) {
      	// [0,maxLength]
        int length = (int) (Math.random() * (maxLength + 1));
        int[] result = new int[length];
        for (int i = 0; i < length; i++) {
            result[i] = generateRandomValue(maxValue);
        }
        return result;
    }

    /**
     * 生成随机整数
     *
     * @param maxValue 最大值 [-maxValue,maxValue]
     * @return 生成随机的整数
     */
    private static int generateRandomValue(int maxValue) {
        // [0,maxValue] - [0,maxValue] ==> [-maxValue,maxValue]
        return ((int) (Math.random() * (maxValue + 1))) - ((int) (Math.random() * (maxValue + 1)));
    }
}

```



### 数组区间和，前缀数组



```java
package com.aitx.study.base.code002;

/**
 * 前缀数组
 * 假设有一个数组arr，用户总是频繁的查询arr中某一段的累加和
 * 你如何组织数据，能让这种查询变得便利和快捷？
 * <p>
 * 思路：
 * 一、相当于求[L,R]区间的数据之和，如果存在矩阵，则行表示L，列表示R，则可以求出
 * 二、相当于求[L,R]区间的数据之和，如果存在数组prefixArray[],i位置数代表是[0,i]的数据之和，
 * 则转成求prefix[R] - prefix[L-1]
 * 三、遍历区间[L,R]求和
 * 
 * 显然思路二更可取
 */
public class Code002_PrefixArray {

    // 求数组[L,R]区间和
    public static int intervalSum(int[] arr, int L, int R) {

        // 思路：构建前缀数组
        int[] prefixArray = buildPrefixArray(arr);

        if (L < 1) {
            return prefixArray[R];
        } else {
            return prefixArray[R] - prefixArray[L - 1];
        }
    }

    private static int[] buildPrefixArray(int[] arr) {
        if (arr == null || arr.length == 0) {
            return new int[]{};
        }
        int N = arr.length;
        int[] result = new int[N];
        int sum = 0;
        for (int i = 0; i < N; i++) {
            sum += arr[i];
            result[i] = sum;
        }
        return result;
    }


}

```



### 二分法



#### 通过二分法判断数是否存在于数组中



```java
import java.util.Arrays;

/**
 * 有序数组中找到num
 * <p>
 * 思考：
 * 一、遍历
 * 二、有序数组中，必然存在 小于此数的，大于此数的，考虑二分法
 */
public class BinarySearchExist {

    public static void main(String[] args) {
        int loopTimes = 100000;
        for (int i = 0; i < loopTimes; i++) {
            int[] randomArray = generateRandomArray(10, 100);
            // 注意，必须是有序数组
            Arrays.sort(randomArray);
            int target = ((int) (Math.random() * (100 + 1))) - ((int) (Math.random() * 100));
            boolean b1 = sequenceSearch(randomArray, target);
            boolean b2 = binarySearchExist(randomArray, target);
            if (b1 != b2) {
                System.out.println("randomArray=" + Arrays.toString(randomArray) + ", target=" + target);
            }
        }
    }

    /**
     * 通过二分查找来查看目标值是否存在数组中
     */
    public static boolean binarySearchExist(int[] arr, int target) {
        // 边界条件
        if (arr == null || arr.length == 0) {
            return false;
        }
        int L = 0;
        int R = arr.length - 1; 
      	// 注意，这里R是有效值，所以是闭区间
        // 所以我们这里可以用<=,当我们用<时，代表数组至少有2个数
        // 如下的写法就是代表至少有2个数，用<号
        while (L < R) {
            int mid = L + ((R - L) >> 1);
            if (arr[mid] == target) {
                return true;
            } else if (target < arr[mid]) {
                R = mid - 1;
            } else {
                L = mid + 1;
            }
        }
        // 因为上面用啊L<R，只覆盖了至少2个元素的数组
        // 这里要覆盖下只有1个数的场景
        return arr[L] == target;
    }

    // 对数器，产生随机数组
    public static int[] generateRandomArray(int maxLength, int maxValue) {
        int length = (int) (Math.random() * (maxLength + 1));
        int[] result = new int[length];
        for (int i = 0; i < length; i++) {
            int value = ((int) (Math.random() * (maxValue + 1))) - ((int) (Math.random() * maxValue));
            result[i] = value;
        }
        return result;
    }

    // 线性搜索
    public static boolean sequenceSearch(int[] arr, int target) {
        // 边界条件
        if (arr == null || arr.length == 0) {
            return false;
        }
        for (int i = 0; i < arr.length; i++) {
            if (target == arr[i]) {
                return true;
            }
        }
        return false;
    }


}

```



#### 在数组中找到>=target最左边的值的索引



```java
package com.aitx.study.base.code003;

import java.util.Arrays;

/**
 * 有序数组中找到>=num最左的位置
 * <p>
 * 思路：
 * 一、遍历
 * 二、看到数组分区，想到二分法
 */
public class Code003_MostNearLeft {

    // 二分法
    public static int mostNearLeftByBinary(int[] arr, int num) {
        if (arr == null || arr.length == 0) {
            return -1;
        }
        int L = 0;
        int R = arr.length - 1;

        int result = -1;

        while (L <= R) {

            int mid = L + ((R - L) >> 1);

            if (arr[mid] >= num) {
                result = mid;
                R = mid - 1;
            } else {
                L = mid + 1;
            }
        }

        // 跳出循环时，L > R
        return result;
    }

    // ---------------------------------------------------------

    // 遍历
    public static int mostNearLeftBySequence(int[] arr, int num) {
        if (arr == null || arr.length == 0) {
            return -1;
        }
        int N = arr.length;
        for (int i = 0; i < N; i++) {
            if (arr[i] >= num) {
                return i;
            }
        }
        // 跳出循环时，i=N
        return -1;
    }

    // ---------------------------------------------------------


    // 生成随机数组
    public static int[] getRandomArray(int maxLength, int maxValue) {
        int length = (int) (Math.random() * (maxLength + 1));
        int[] result = new int[length];
        for (int i = 0; i < length; i++) {
            // [0-maxValue] - [0-maxValue] == [-maxValue,maxValue]
            result[i] = getRandomValue(maxValue);
        }
        return result;
    }

    // 随机数
    public static int getRandomValue(int maxValue) {
        return ((int) (Math.random() * (maxValue + 1))) - ((int) (Math.random() * (maxValue + 1)));
    }

    public static void main(String[] args) {
        int testTimes = 1000;
        int maxLength = 10;
        int maxValue = 100;

        for (int i = 0; i < testTimes; i++) {
            int[] randomArray = getRandomArray(maxLength, maxValue);
            // 注意一定要有序
            Arrays.sort(randomArray);
            int randomValue = getRandomValue(maxValue);
            if (mostNearLeftBySequence(randomArray, randomValue) != mostNearLeftByBinary(randomArray, randomValue)) {
                System.out.println("有误");
                break;
            }
        }
    }
}

```



#### 在数组上找满足<=value的最右边值的索引



```java
package com.aitx.study.base.code003;

import java.util.Arrays;

/**
 * 有序数组中找到<=num最右的位置
 * <p>
 * 思路：
 * 一、倒着遍历
 * 二、看到分区，想到二分法
 */
public class Code003_MostNearRight {

    // 二分法
    public static int mostNearRightByBinary(int[] arr, int num) {
        if (arr == null || arr.length == 0) {
            return -1;
        }
        int L = 0;
        int R = arr.length - 1;

        int result = -1;

        while (L <= R) {

            int mid = L + ((R - L) >> 1);

            if (arr[mid] <= num) {
                result = mid;
                L = mid + 1;
            } else {
                R = mid - 1;
            }
        }

        // 跳出循环时，L > R
        return result;
    }

    // ---------------------------------------------------------

    // 遍历
    public static int mostNearRightBySequence(int[] arr, int num) {
        if (arr == null || arr.length == 0) {
            return -1;
        }
        int N = arr.length;
        for (int i = (N - 1); i >= 0; i--) {
            if (arr[i] <= num) {
                return i;
            }
        }
        // 跳出循环时，i=-1
        return -1;
    }

    // ---------------------------------------------------------


    // 生成随机数组
    public static int[] getRandomArray(int maxLength, int maxValue) {
        int length = (int) (Math.random() * (maxLength + 1));
        int[] result = new int[length];
        for (int i = 0; i < length; i++) {
            // [0-maxValue] - [0-maxValue] == [-maxValue,maxValue]
            result[i] = getRandomValue(maxValue);
        }
        return result;
    }

    // 随机数
    public static int getRandomValue(int maxValue) {
        return ((int) (Math.random() * (maxValue + 1))) - ((int) (Math.random() * (maxValue + 1)));
    }

    public static void main(String[] args) {
        int testTimes = 1000;
        int maxLength = 10;
        int maxValue = 100;

        for (int i = 0; i < testTimes; i++) {
            int[] randomArray = getRandomArray(maxLength, maxValue);
            // 注意一定要有序
            Arrays.sort(randomArray);
            int randomValue = getRandomValue(maxValue);
            if (mostNearRightBySequence(randomArray, randomValue) != mostNearRightByBinary(randomArray, randomValue)) {
                System.out.println("有误");
                break;
            }
        }
    }


}


```



#### 求数组的局部最小值



```java
package com.aitx.study.base.code003;

/**
 * 一个数组，左右元素各不相等，求此数组的局部极小值的索引位置
 * <p>
 * 思考：
 * 一、左右不等，有几种情况：
 * 1）左大，右大，存在局部最小值
 * 2）左大，右小，则右端点处可能有最小值
 * 3）左小，右大，则左端点处可能有最小值
 * 4）左小，右小，则左右端点处可能有最小值
 * <p>
 * 这里也有左右分区，考虑二分法
 */
public class Code003_LocalMin {


    public static int localMin(int[] arr) {
        if (arr == null || arr.length == 0) {
            return -1;
        }
        int N = arr.length;
        if (N == 1) {
            return 0;
        }
        // 走到这，代表数组长度至少为2
        if (arr[0] < arr[1]) {
            return 0;
        }
        // 走到这，代表arr[0] > arr[1]
        if (arr[N - 1] < arr[N - 2]) {
            return N - 1;
        }
        // 走到这，代表arr[N-1] > arr[N-2]，且代表至少3个数

        // 结合看，函数图像给人是先减再增，则存在局部最小值

        int L = 0;
        int R = N - 1;

        // 涉及到三个数，保证有3个数存在
        while (L < R - 1) {
            int mid = L + ((R - L) >> 1);

            if (arr[mid] < arr[mid - 1] && arr[mid] < arr[mid + 1]) {
                return mid;
            } else {
                if (arr[mid] > arr[mid - 1]) {
                    R = mid - 1;
                } else {
                    L = mid + 1;
                }
            }
        }
        // 跳出循环时，L >= R-1
        // 1) L = R-1 则只有2个数，直接判断大小
        // 2）L > R-1 则 R-1，R，L或R-1，R(L)
        return arr[L] < arr[R] ? L : R;
    }

    // ------------------------------------------------

    // 生成左右不等的数组
    public static int[] getLRNotEqualRandomArray(int maxLength, int maxValue) {
        int length = (int) (Math.random() * (maxLength + 1));
        int[] result = new int[length];
        if (length == 0) {
            return result;
        }
        result[0] = ((int) (Math.random() * (maxValue + 1)));
        for (int i = 1; i < length; i++) {
            do {
                result[i] = ((int) (Math.random() * (maxValue + 1)));
            } while (result[i] == result[i - 1]);
        }
        return result;
    }

    private static boolean checkCorrect(int[] arr, int index) {
        if (arr == null || arr.length == 0) {
            return -1 == index;
        }
        int N = arr.length;
        if (N == 1) {
            return 0 == index;
        }
        int leftIndex = index - 1;
        int rightIndex = index + 1;
        boolean leftBigger = leftIndex < 0 || (arr[leftIndex] > arr[index]);
        boolean rightBigger = rightIndex >= N || (arr[rightIndex] > arr[index]);
        return leftBigger && rightBigger;
    }

    public static void main(String[] args) {
        int testTimes = 100000;
        int maxLength = 10;
        int maxValue = 100;
        for (int i = 0; i < testTimes; i++) {
            int[] lRNotEqualRandomArray = getLRNotEqualRandomArray(maxLength, maxValue);
            int localMinIndex = localMin(lRNotEqualRandomArray);
            if (!checkCorrect(lRNotEqualRandomArray, localMinIndex)) {
                System.out.println("有误");
                break;
            }
        }
    }

}


```





### 异或运算



```
异或运算：相同为0，不同为1

同或运算：相同为1，不同为0

异或运算 就相当于 无进位的相加

0 ^ N = N

N ^ N = 0

异或运算 满足交换律、结合律
```



#### 不用额外空间实现两数交换



```java
public class SwapTwoNum {

    public static void main(String[] args) {

        int a = 3;
        int b = 4;

        a = a ^ b;
        b = a ^ b; // 原a ^ 原b ^ 原b == 原a ^ 0 = 原a
        a = a ^ b; // 原a ^ 原b ^ 原a == 0 ^ 原b = 原b

        // 用异或实现 交换两数
        System.out.println("a = " + a);
        System.out.println("b = " + b);


    }

    private static void swap(int[] arr, int left, int right) {
        // 如果left == right
        // 则
        // arr[left] = arr[left] ^ arr[left] = 0
        // arr[right] = 0 ^ 0 = 0
        // arr[left] = 0 ^ 0 = 0
        // 会将两数直接变成0，所以如果索引相同时，不能用异或eor来运算
      	// eor == exlusive or
      	// 也就是用异或两个数在内存中不能是同一内存空间
        //
        // 再考虑如果left != right,但arr[left] == arr[right]
        // arr[left] = 0
        // arr[right] = 0 ^ o-arr[right] = o-arr[right]
        // arr[left] = 0 ^ arr[right] = o-arr[right] = o-arr[left]
        // 所以两数相等，但索引不同，可以用异或进行交换
        if (left == right) {
            return;
        }
        arr[left] = arr[left] ^ arr[right];
        arr[right] = arr[left] ^ arr[right];
        arr[left] = arr[left] ^ arr[right];
    }
}
```



#### 数组中只有一个数是奇数次个，求这个数



```java
public class OnlyOneIsOddNumArray {

    public static void main(String[] args) {
        int[] arr = {3, 3, 3, 4, 4, 5, 5, 5, 5};
        int num = onlyOneIsOddNum(arr);
        System.out.println("num = " + num); // num = 3
    }

  	// 解法二：用异或解决
    // 数组中只有一个数是奇数次个，求这个数
    private static int onlyOneIsOddNum(int[] arr) {
        // N ^ N = 0
        // 0 ^ N = N
        int eor = 0;
        for (int i = 0; i < arr.length; i++) {
            eor ^= arr[i];
        }
        return eor;
    }
  
  	// 解法一：用HashMap装词频，暴力解法
}
```



#### 将int类型的数提取出最右侧的1(位运算视角)



```java
package com.aitx.study.base;

/**
 * 将int类型的数提取出最右侧的1,比如13，二进制数为1101，最右侧的1就是0001（十进制为1）
 */
public class getIntegerRightOne {

    public static void main(String[] args) {
        int testTimes = 10000;
        int maxValue = Integer.MAX_VALUE;
        for (int i = 0; i < testTimes; i++) {
            int num = getRandomValue(maxValue);
            if (getIntegerRightOne1(num) != getIntegerRightOne2(num)) {
                System.out.println("error" + num);
            }
        }
    }

    /**
     * 解法二：位与处理，
     * N & (-N) == N & (~N + 1)
     * 这里有个知识点就是 相反数 == 原数取反+1
     * 比如1101 0000 ^ (0010 1111 再加1,也就是0011 0000 )
     * 1101 0000 & 0011 0000
     * 也就求出最右侧的1了
     */
    private static int getIntegerRightOne2(int num) {
        return num & (-num);
    }


    /**
     * 解法一：找出int的二进制展示，并求出最右侧1的索引
     */
    private static int getIntegerRightOne1(int num) {
        String integerBinaryBitShow = getIntegerBinaryBitShow(num);
        String reverse = new StringBuilder(integerBinaryBitShow).reverse().toString();
        int index = reverse.indexOf('1');
        if (index == 31) {
            return Integer.MIN_VALUE;
        } else if (index == -1) {
            return 0;
        } else {
            return (1 << (index));
        }
    }


    private static String getIntegerBinaryBitShow(int num) {
        StringBuilder sb = new StringBuilder();
        // 索引为：0-31,依次递减
        for (int i = 31; i >= 0; i--) {
            char c = (num & (1 << i)) == 0 ? '0' : '1';
            sb.append(c);
        }
        return sb.toString();
    }


    // test
    private static int getRandomValue(int maxValue) {
        // [0,maxValue] - [0,maxValue] == [-maxValue,maxValue]
        return ((int) (Math.random() * (maxValue + 1))) - (int) (Math.random() * (maxValue + 1));
    }
}

```



#### 数组中只有两种数出现奇数次，求出这两种数



```java
public class OnlyTwoOddNumArray {

    public static void main(String[] args) {
        int[] arr = {3, 4, 5, 5, 6, 6, 6, 6};
        onlyTwoOddNum(arr);
    }

  	// 解法二：异或
    // 数组中只有两种数出现奇数次，求出这两种数
    public static void onlyTwoOddNum(int[] arr) {
        // 进行异或运算消掉偶次个的数
        int eor = 0;
        for (int i = 0; i < arr.length; i++) {
            eor ^= arr[i];
        }
        // 循环结束，eor = a ^ b ( a != b)
        // 显然 a != b 肯定有位上是不同的，我们将eor最右侧的1提取出来
        int rightOne = eor & (-eor);
      	// int rightOne = eor & (~eor + 1);
        // 那么此时原数组的数可以分为二类：在此位上是1的、在此位上是0的
        int a = 0;
        for (int i = 0; i < arr.length; i++) {
            // 确定此位是1的情况,那第此区中必然只有一个是奇数个
            if ((arr[i] & rightOne) != 0) {
                a ^= arr[i];
            }
        }
        // 输出a
        System.out.println("a = " + a);
        // 输出b
        int b = eor ^ a;
        System.out.println("b = " + b);
    }
  
  	// 解法一：HashMap
}
```





#### 求一个数二进制位上有几个1



```java
public class Bit1Count {

    public static void main(String[] args) {
        int count = bit1counts(14);
        System.out.println("count = " + count);
    }
		
  	// 解法二：位与运算，求最右边1，再异或消除，直到N==0
    // 求一个数有几个1，就是看一个数二进制位上有几个1
    public static int bit1counts(int N) {
        int count = 0;

        //   011011010000
        //   000000010000     1

        //   011011000000
        //

        // 看一个数有几个1，就是不断的将位的1消去，最后N==0
        while (N != 0) {
            // 求一个数最右侧的1，就是此数与相反数 位与，也等同于 此数与（取反 +1的数）位与
            int rightOne = N & ((~N) + 1);
            // 计算有几个1
            count++;
            // 异或运算，是无进位相加
            // 这里相当于，将原来的数最右的1消掉
            N ^= rightOne;
            // N -= rightOne
        }

        return count;
    }
  	// 解法一：求出一个数的二进制表示，最后统计
}
```



#### 将一个整型数转成二进制数组表示,数组0-31索引依次表示int型数的0-31位的情况



```java
package com.aitx.study.base;

import java.util.Arrays;

/**
 * 将一个整型数转成二进制数组表示,数组0-31索引依次表示int型数的0-31位的情况
 */
public class IntegerBinaryArrayShow {

    public static void main(String[] args) {
        int testTimes = 100000;
        int maxValue = 1000;
        for (int i = 0; i < testTimes; i++) {
            int num = generateRandomValue(maxValue);
            if (!Arrays.equals(getIntegerBinaryArrayShow1(num), getIntegerBinaryArrayShow2(num))) {
                System.out.println(num);
            }
        }
    }


    /**
     * 解法二：1不动，num左移
     */
    private static int[] getIntegerBinaryArrayShow1(int num) {
        int[] result = new int[32];
        for (int i = 0; i < 32; i++) {
            // 相当于只取num的0索引处的值
            int res = ((num >> i) & 1);
            result[i] = res;
        }
        return result;
    }

    /**
     * 解法一：1动且向左移，num不动
     */
    private static int[] getIntegerBinaryArrayShow2(int num) {
        int[] result = new int[32];
        for (int i = 31; i >= 0; i--) {
            // 注意，这里1是要左移
            result[i] = (num & (1 << i)) == 0 ? 0 : 1;
        }
        return result;
    }


    // test
    private static int generateRandomValue(int maxValue) {
        // [0,maxValue] - [0,maxValue] == [-maxValue,maxValue]
        return ((int) (Math.random() * (maxValue + 1))) - ((int) (Math.random() * (maxValue + 1)));
    }
}

```



#### 一个数组中，存在一种数会出现K次，其他种类数出现M次，M>1,K<M,求出现K次的数为多少



```java
package com.aitx.study.base;


import java.util.*;
import java.util.stream.Collectors;

/**
 * 一个数组中，存在一种数会出现K次，其他种类数出现M次，M>1,K<M,求出现K次的数为多少、
 * 词频的暴力解法肯定用HashMap能解决
 * 这里相当于数组中存在其他数为偶数次的数，1个奇数次的数的拓展，所以这道题也可以用位运算来解决
 */
public class KM {


    /**
     * 解法一：通过32位数组统计某位上的1个数
     */
    private static int getKTimesNum(int[] arr, int K, int M) {
        int[] calc = new int[32];
        for (int num : arr) {
            // 相当于统计所有数在此位上1的个数
            for (int i = 0; i < 32; i++) {
                calc[i] += (num >> i) & 1;
            }
        }
        int ans = 0;
        for (int i = 0; i < 32; i++) {
            // 如果对M取模不等于0，代表此位上会出现K次1,也就是要求的数在此位为1
            if (calc[i] % M != 0) {
                ans |= 1 << i;
            }
        }
        return ans;
    }

    /**
     * 解法二：通过HashMap统计
     */
    private static int getKTimesNumByHashMap(int[] arr, int K, int M) {
        // key:num,value:times
        Map<Integer, Integer> map = new HashMap<>();
        for (int num : arr) {
            if (map.containsKey(num)) {
                map.put(num, map.get(num) + 1);
            } else {
                map.put(num, 1);
            }
        }
        for (Integer num : map.keySet()) {
            if (map.get(num) == K) {
                return num;
            }
        }
        throw new RuntimeException("找不到此数");
    }

    // for test
    private static int[] generateRandomArray(int maxKinds, int maxValue, int K, int M) {
        // 种类数：[0,maxKinds-2] + 2 == [2,maxKinds]
        int kinds = ((int) (Math.random() * (maxKinds - 1))) + 2;
        // 所以 数组总长度为 K + (kinds - 1) * M
        int length = K + (kinds - 1) * M;
        int[] result = new int[length];
        int index = 0;
        int kTimesNum = generateRandomValue(maxValue);
        // 填充出现K次的数
        for (; index < K; index++) {
            result[index] = kTimesNum;
        }
        kinds--;
        Set<Integer> set = new HashSet<>();
        set.add(kTimesNum);
        // 填加其他种类的数
        while (kinds != 0) {
            int curNum;
            do {
                curNum = generateRandomValue(maxValue);
            } while (set.contains(curNum));
            for (int i = 0; i < M; i++) {
                result[index++] = curNum;
            }
            set.add(curNum);
            kinds--;
        }
        // 将数组打乱
        for (int i = 0; i < length; i++) {
            // [0,length-1]
            int j = ((int) (Math.random() * (length)));
            int temp = result[i];
            result[i] = result[j];
            result[j] = temp;
        }
        return result;
    }

    // for test
    private static int generateRandomValue(int maxValue) {
        return ((int) (Math.random() * (maxValue + 1))) - ((int) (Math.random() * (maxValue + 1)));
    }

    // for test
    public static void main(String[] args) {
        int testTimes = 100000;
        int maxKinds = 5;
        int maxValue = 100;
        int KMMax = 9;
        for (int i = 0; i < testTimes; i++) {
            // [0,KMMax-1] + 1 == [1,KMMax]
            int a = (int) (Math.random() * KMMax) + 1;
            // [1,KMMax]
            int b = (int) (Math.random() * KMMax) + 1;
            int K = Math.min(a, b);
            int M = Math.max(a, b);
            if (K == M) {
                M = K + 1;
            }

            int[] arr = generateRandomArray(maxKinds, maxValue, K, M);
            if (getKTimesNum(arr, K, M) != getKTimesNumByHashMap(arr, K, M)) {
                System.out.println("arr=" + Arrays.toString(arr) + ",K=" + K + ",M=" + M);
            }
        }
    }
}

```



### 前缀树



#### 前缀树(固定数组实现)



```java
package com.aitx.study.base.code002;

/**
 * 前缀树PrefixTree(Trie)
 * 链接 : https://leetcode.cn/problems/implement-trie-ii-prefix-tree/
 * <p>
 * 1）单个字符串中，字符从前到后的加到一棵多叉树上
 * 2）字符放在路上，节点上有专属的数据项（常见的是pass和end值）
 * 3）所有样本都这样添加，如果没有路就新建，如有路就复用
 * 4）沿途节点的pass值增加1，每个字符串结束时来到的节点end值增加1
 * <p>
 * 设计一种结构。用户可以：
 * 1）void insert(String str)  添加某个字符串，可以重复添加，每次算1个
 * 2）int search(String str)   查询某个字符串在结构中还有几个
 * 3) void delete(String str)  删掉某个字符串，可以重复删除，每次算1个
 * 4）int prefixNumber(String str) 查询有多少个字符串，是以str做前缀的
 * <p>
 * 前缀数组的实现：
 * 1）固定数组实现
 * 2）哈希表实现
 */
public class Trie {

    /**
     * 前缀树的节点
     * pass; // 通过的量
     * end; // 结尾的量
     * nexts; // 邻居节点
     */
    private static class Node {

        // 通过的量
        int pass;

        // 结尾的量
        int end;

        // 邻居节点
        Node[] nexts;


        public Node() {
            pass = 0;
            end = 0;
            // 如果字符串只有小写英文字母
            nexts = new Node[26];
        }
    }


    Node root;

    public Trie() {
        root = new Node();
    }

    /**
     * 添加某个字符串，可以重复添加，每次算1个
     */
    public void insert(String str) {
        if (str == null || str.length() == 0) {
            return;
        }

        char[] chars = str.toCharArray();
        int N = chars.length;

        Node cur = root;
        cur.pass++;
        for (int i = 0; i < N; i++) {
            // 相当于前缀树中，字符串中的字符是通过 边 来表示的
            int index = chars[i] - 'a';
            if (cur.nexts[index] == null) {
                cur.nexts[index] = new Node();
            }
            cur = cur.nexts[index];
            cur.pass++;
        }
        // 退出循环时，cur指向最后一个节点
        cur.end++;
    }

    /**
     * 查询某个字符串在结构中还有几个
     */
    public int search(String str) {

        if (str == null || str.length() == 0) {
            return 0;
        }

        char[] chars = str.toCharArray();
        int N = chars.length;

        Node cur = root;
        for (int i = 0; i < N; i++) {
            // 求 边 的索引值
            int index = chars[i] - 'a';
            if (cur.nexts[index] == null) {
                return 0;
            }
            cur = cur.nexts[index];
        }
        // 退出循环时，cur指向最后一个节点
        return cur.end;
    }

    /**
     * 删掉某个字符串，可以重复删除，每次算1个
     */
    public void delete(String str) {
        if (str == null || str.length() == 0) {
            return;
        }

        // 看下待删除的str在不在前缀树中
        if (search(str) == 0) {
            return;
        }

        char[] chars = str.toCharArray();
        int N = chars.length;

        Node cur = root;
        cur.pass--;
        for (int i = 0; i < N; i++) {
            int index = chars[i] - 'a';
            cur.nexts[index].pass--;
            if (cur.nexts[index].pass == 0) {
                cur.nexts[index] = null;
                return;
            }
            cur = cur.nexts[index];
        }
        cur.end--;
    }

    /**
     * 查询有多少个字符串，是以str做前缀的
     */
    public int prefixNumber(String str) {

        if (str == null || str.length() == 0) {
            return 0;
        }

        char[] chars = str.toCharArray();
        int N = chars.length;

        Node cur = root;
        for (int i = 0; i < N; i++) {
            int index = chars[i] - 'a';
            if (cur.nexts[index] == null) {
                return 0;
            }
            cur = cur.nexts[index];
        }
        // 退出循环时,cur指向最后一个节点
        return cur.pass;
    }

}

```



#### 前缀树(Hash表实现)



```java
package com.aitx.study.base.code002;

import java.util.HashMap;
import java.util.Map;

/**
 * 前缀树PrefixTree(Trie)
 * 链接 : https://leetcode.cn/problems/implement-trie-ii-prefix-tree/
 * <p>
 * 1）单个字符串中，字符从前到后的加到一棵多叉树上
 * 2）字符放在路上，节点上有专属的数据项（常见的是pass和end值）
 * 3）所有样本都这样添加，如果没有路就新建，如有路就复用
 * 4）沿途节点的pass值增加1，每个字符串结束时来到的节点end值增加1
 * <p>
 * 设计一种结构。用户可以：
 * 1）void insert(String str)  添加某个字符串，可以重复添加，每次算1个
 * 2）int search(String str)   查询某个字符串在结构中还有几个
 * 3) void delete(String str)  删掉某个字符串，可以重复删除，每次算1个
 * 4）int prefixNumber(String str) 查询有多少个字符串，是以str做前缀的
 * <p>
 * 前缀数组的实现：
 * 1）固定数组实现
 * 2）哈希表实现
 */
public class TrieByHashMapImpl {

    /**
     * 前缀树的节点
     * pass; // 通过的量
     * end; // 结尾的量
     * nexts; // 邻居节点
     */
    private static class Node {

        // 通过的量
        int pass;

        // 结尾的量
        int end;

        // 邻居节点
        Map<Character, Node> nexts;


        public Node() {
            pass = 0;
            end = 0;
            // 通过Hash表实现，key可以是Integer或是Character
            nexts = new HashMap<>();
        }
    }

    // 定义头节点
    Node root;

    public TrieByHashMapImpl() {
        root = new Node();
    }

    /**
     * 添加某个字符串，可以重复添加，每次算1个
     */
    public void insert(String str) {
        if (str == null || str.length() == 0) {
            return;
        }

        char[] chars = str.toCharArray();
        int N = chars.length;

        Node cur = root;
        cur.pass++;
        for (int i = 0; i < N; i++) {
            // 相当于前缀树中，字符串中的字符是通过 边 来表示的
            Character c = chars[i];
            if (!cur.nexts.containsKey(c)) {
                cur.nexts.put(c, new Node());
            }
            cur = cur.nexts.get(c);
            cur.pass++;
        }
        // 退出循环时，cur指向最后一个节点
        cur.end++;
    }

    /**
     * 查询某个字符串在结构中还有几个
     */
    public int search(String str) {

        if (str == null || str.length() == 0) {
            return 0;
        }

        char[] chars = str.toCharArray();
        int N = chars.length;

        Node cur = root;
        for (int i = 0; i < N; i++) {
            // 求 边 的索引值
            Character c = chars[i];
            if (!cur.nexts.containsKey(c)) {
                return 0;
            }
            cur = cur.nexts.get(c);
        }
        // 退出循环时，cur指向最后一个节点
        return cur.end;
    }

    /**
     * 删掉某个字符串，可以重复删除，每次算1个
     */
    public void delete(String str) {
        if (str == null || str.length() == 0) {
            return;
        }

        // 看下待删除的str在不在前缀树中
        if (search(str) == 0) {
            return;
        }

        char[] chars = str.toCharArray();
        int N = chars.length;

        Node cur = root;
        cur.pass--;
        for (int i = 0; i < N; i++) {
            Character c = chars[i];
            cur.nexts.get(c).pass--;
            if (cur.nexts.get(c).pass == 0) {
                cur.nexts.remove(c);
                return;
            }
            cur = cur.nexts.get(c);
        }
        cur.end--;
    }

    /**
     * 查询有多少个字符串，是以str做前缀的
     */
    public int prefixNumber(String str) {

        if (str == null || str.length() == 0) {
            return 0;
        }

        char[] chars = str.toCharArray();
        int N = chars.length;

        Node cur = root;
        for (int i = 0; i < N; i++) {
            Character c = chars[i];
            if (!cur.nexts.containsKey(c)) {
                return 0;
            }
            cur = cur.nexts.get(c);
        }
        // 退出循环时,cur指向最后一个节点
        return cur.pass;
    }

}

```



### 比较器与堆



#### 比较器



```java
package com.aitx.study.base.code001;

import java.util.Comparator;
import java.util.PriorityQueue;

public class MyComparatorTest {


    private static class Inner {

        int id;
    }

    private static class MyComparator implements Comparator<Inner> {

        /**
         * 返回负值，代表o1比o2优先
         * 返回正值，代表o2比o1优先
         * 返回0，代表o1与o2一样优先
         */
        @Override
        public int compare(Inner o1, Inner o2) {
            return o1.id - o2.id;
        }
    }


    public static void main(String[] args) {
        // 优先级队列，默认为小顶堆，构造器可以传入自定义的比较器进行排序
        PriorityQueue<Inner> priorityQueue = new PriorityQueue<>(new MyComparator());
    }
}

```



### 堆



#### 大顶堆



```java
package com.aitx.study.base.code001;

/**
 * 堆Heap == 数组 == 完全二叉树 == 优先级队列
 * <p>
 * 1）堆结构就是用数组实现的完全二叉树结构,
 * 数组中任意index位置的父为(index-1)/2;
 * 左子为index*2+1;右子为index*2+2
 * 2）完全二叉树中如果每棵子树的最大值都在顶部就是大根堆
 * 3）完全二叉树中如果每棵子树的最小值都在顶部就是小根堆
 * 4）堆结构的heapInsert与heapify操作
 * 5）堆结构的增大和减少
 * 6）优先级队列结构，就是堆结构
 */
public class MyHeapTest {


    /**
     * 实现大顶堆
     */
    private static class MaxTopHeap {

        // 堆 == 数组 == 完全二叉树 == 优先级队列
        int[] heap;

        // 数组限制大小
        final int limit;

        // 堆大小
        int heapSize;

        public MaxTopHeap(int limit) {
            this.limit = limit;
            heap = new int[limit];
            heapSize = 0;
        }

        public boolean isEmpty() {
            return this.heapSize == 0;
        }

        public boolean isFull() {
            return this.heapSize == limit;
        }

        public void push(int value) {
            if (isFull()) {
                throw new RuntimeException();
            }
            heap[heapSize] = value;

            // index位置 添加后 要heapInsert 调整位置
            heapInsert(heapSize);

            heapSize++;
        }

        public int pop() {

            if (isEmpty()) {
                throw new RuntimeException();
            }

            int result = heap[0];

            // 0索引位置用最后的位置来填
            swap(heap, 0, heapSize - 1);

            heapSize--;

            // 新移到0索引位置的肯定比较小，要向下heapify
            heapify(0);

            return result;
        }

        /**
         * 向下heapify，调整堆结构，保证大顶堆
         */
        private void heapify(int index) {

            int left = index * 2 + 1;

            while (left < this.heapSize) {

                // 左右找最大的
                int largest = (left + 1) < this.heapSize && heap[left + 1] > heap[left] ?
                        (left + 1) : left;
                // 上下找最大的
                largest = heap[largest] > heap[index] ? largest : index;
                if (index == largest) {
                    break;
                }

                swap(heap, index, largest);

                index = largest;
                left = index * 2 + 1;

            }
        }


        /**
         * index位置添加数据，因为是末尾，
         * 所以有可能向上移动
         */
        private void heapInsert(int index) {
            // 当子 大于 父时，向上heapInsert
            while (heap[index] > heap[(index - 1) / 2]) {
                swap(heap, index, (index - 1) / 2);
                index = (index - 1) / 2;
            }
        }


        private void swap(int[] heap, int left, int right) {
            int temp = heap[left];
            heap[left] = heap[right];
            heap[right] = temp;
        }


    }


    /**
     * 暴力实现大顶堆，求最大值是遍历的方式求
     */
    private static class RightMaxTopHeap {

        // 堆 == 数组 == 完全二叉树 == 优先级队列
        int[] heap;

        // 数组限制大小
        final int limit;

        // 堆大小
        int heapSize;

        public RightMaxTopHeap(int limit) {
            this.limit = limit;
            heap = new int[limit];
            heapSize = 0;
        }

        public boolean isEmpty() {
            return this.heapSize == 0;
        }

        public boolean isFull() {
            return this.heapSize == limit;
        }

        public void push(int value) {
            if (isFull()) {
                throw new RuntimeException();
            }

            heap[heapSize] = value;

            heapSize++;
        }

        public int pop() {
            if (isEmpty()) {
                throw new RuntimeException();
            }

            int maxIndex = 0;
            for (int i = 1; i < this.heapSize; i++) {
                if (heap[i] > heap[maxIndex]) {
                    maxIndex = i;
                }
            }

            int result = heap[maxIndex];

            swap(heap, maxIndex, heapSize - 1);

            heapSize--;

            return result;
        }

        private void swap(int[] heap, int left, int right) {
            int temp = heap[left];
            heap[left] = heap[right];
            heap[right] = temp;
        }


    }


}

```





### 链表



#### 数据结构-链表



```java
/**
 * 单向链表
 */
public class Node<T> {

    // 数据域
    T val;

    // 指针域
    Node<T> next;
}

/**
 * 双向链表
 */
class DoubleNode<T> {

    // 数据域
    T val;

    // 指针域
    Node<T> pre;

    Node<T> next;
}
```



#### 链表反转



```java
package com.aitx.study.base;

import java.util.ArrayList;
import java.util.List;

/**
 * 给定一个单链表的头head，完成链表的逆序调整
 * 给定一个双链表的头head，完成链表的逆序调整
 * <p>
 * 思考：
 * 一、容器法
 * 二、指针法
 *
 * 任何链表问题都可以有两种解法：1指针法；2容器法
 */

public class LinkedListReverse {


    private static class Node {
        int value;

        Node next;

        public Node(int value) {
            this.value = value;
        }
    }

    private static class DoubleNode {

        int value;

        DoubleNode pre;

        DoubleNode next;

        public DoubleNode(int value) {
            this.value = value;
        }

    }


    /**
     * 翻转单链表
     * a->b->c->null
     * null<-a<-b<-c
     */
    private static Node reverseSingleNode(Node head) {
        Node pre = null;
        Node next = null;
        while (head != null) {
            next = head.next;
            head.next = pre;
            pre = head;
            head = next;
        }
        // 跳出while循环后，head == null,pre == 最后一个节点
        // 此时pre就是第一个节点（也兼容head==null的场景）
        return pre;
    }

    /**
     * 翻转双向链表
     */
    private static DoubleNode reverseDoubleNode(DoubleNode head) {
        DoubleNode pre = null;
        DoubleNode next = null;
        while (head != null) {
            next = head.next;
            // 注意双向链表反转时next,pre都要调转方向
            head.next = pre;
            head.pre = next;
            pre = head;
            head = next;
        }
        // 跳出循环时，head == null，pre == 最后一个节点
        return pre;
    }

    /**
     * 通过容器的方式翻转单链表
     */
    private static Node reverseSingleNodeByContainer(Node head) {
        if (head == null) {
            return null;
        }
        // 走到这，代表肯定有1个及以上的节点
        List<Node> list = new ArrayList<>();
        while (head != null) {
            list.add(head);
            head = head.next;
        }
        int N = list.size();
        // 将
        list.get(0).next = null;
        for (int i = 1; i < N; i++) {
            list.get(i).next = list.get(i - 1);
        }
        return list.get(N - 1);
    }

    /**
     * 通过容器的方式翻转双向链表
     */
    private static DoubleNode reverseDoubleNodeByContainer(DoubleNode head) {
        // 任何时候都要用边界条件，没写边界，代表是输入不可能是边界条件或后面代码兼容边界条件
        if (head == null) {
            return null;
        }
        // 走到这，代表只有1个节点
        List<DoubleNode> list = new ArrayList<>();
        while (head != null) {
            list.add(head);
            head = head.next;
        }
        DoubleNode firstNode = list.get(0);
        firstNode.next = null;
        int N = list.size();
        for (int i = 1; i < N; i++) {
            DoubleNode doubleNode = list.get(i);
            doubleNode.next = list.get(i - 1);
            // 这里不能直接取i+1索引处的值，所以我们要用前一个节点的
            doubleNode.pre = null;
            list.get(i - 1).pre = doubleNode;
        }
        return list.get(N - 1);
    }

    // for test 生成随机单链表
    private static Node generateRandomSingleLinkedList(int maxLength, int maxValue) {
        int length = (int) (Math.random() * (maxLength + 1));
        if (length == 0) {
            return null;
        }
        // 先生成头
        length--;
        Node head = new Node(generateRandomValue(maxValue));
        Node cur = head;
        for (int i = 0; i < length; i++) {
            Node node = new Node(generateRandomValue(maxValue));
            cur.next = node;
            cur = node;
        }
        return head;
    }

    // for test 生成随机值
    private static int generateRandomValue(int maxValue) {
        return ((int) (Math.random() * (maxValue + 1))) - ((int) (Math.random() * (maxValue + 1)));
    }

    // fot test 生成随机双向链表
    private static DoubleNode generateRandomDoubleLinkedList(int maxLength, int maxValue) {
        int length = (int) (Math.random() * (maxLength + 1));
        if (length == 0) {
            return null;
        }
        // 先生成头
        length--;
        DoubleNode head = new DoubleNode(generateRandomValue(maxValue));
        DoubleNode cur = head;
        for (int i = 0; i < length; i++) {
            DoubleNode doubleNode = new DoubleNode(generateRandomValue(maxValue));
            cur.next = doubleNode;
            doubleNode.pre = cur;
            cur = doubleNode;
        }

        return head;

    }

    // fot test 获取原单向链表值 列表
    private static List<Integer> getOriginSingleLinkedValueList(Node head) {
        List<Integer> result = new ArrayList<>();
        while (head != null) {
            result.add(head.value);
            head = head.next;
        }
        return result;
    }

    // for test 获取原双向链表值 列表
    private static List<Integer> getOriginDoubleLinkedValueList(DoubleNode head) {
        List<Integer> result = new ArrayList<>();
        while (head != null) {
            result.add(head.value);
            head = head.next;
        }
        return result;
    }

    // for test 检测单向链表是否已反转
    private static boolean checkSingleLinkedListIsReverse(List<Integer> originValueList, Node reverseHead) {
        int N = originValueList.size();
        for (int i = N - 1; i >= 0; i--) {
            if (!originValueList.get(i).equals(reverseHead.value)) {
                return false;
            }
            reverseHead = reverseHead.next;
        }
        if (reverseHead != null) {
            return false;
        }
        return true;
    }

    // for test 检测双向链表是否已反转
    private static boolean checkDoubleLinkedListIsReverse(List<Integer> originValueList, DoubleNode reverseHead) {
        int N = originValueList.size();
        DoubleNode end = null;
        for (int i = N - 1; i >= 0; i--) {
            if (!originValueList.get(i).equals(reverseHead.value)) {
                return false;
            }
            end = reverseHead;
            reverseHead = reverseHead.next;
        }
        // 循环结束时，正常情况下end就是最后一个节点
        // 想一下有没有可能双向链表中的一截刚好覆盖上面的list，那第此时end就是覆盖一截的最后一个节点
        if (reverseHead != null) {
            return false;
        }
        // 走这到，代表列表长度与链表长度一致
        for (int i = 0; i < N; i++) {
            if (!originValueList.get(i).equals(end.value)) {
                return false;
            }
            end = end.pre;
        }
        return true;
    }

    public static void main(String[] args) {
        int testTimes = 100000;
        int maxLength = 10;
        int maxValue = 100;
        for (int i = 0; i < testTimes; i++) {
            // 校验指针法反转单链表是否正确
            Node node1 = generateRandomSingleLinkedList(maxLength, maxValue);
            if (!checkSingleLinkedListIsReverse(getOriginSingleLinkedValueList(node1), reverseSingleNode(node1))) {
                System.out.println("checkSingleLinkedListIsReverse-pointer fail");
                break;
            }
            // 校验容器法反转单链表是否正确
            Node node2 = generateRandomSingleLinkedList(maxLength, maxValue);
            if (!checkSingleLinkedListIsReverse(getOriginSingleLinkedValueList(node2), reverseSingleNodeByContainer(node2))) {
                System.out.println("checkSingleLinkedListIsReverse-container fail");
            }
            // 校验指针法反转双向链表是否正确
            DoubleNode doubleNode1 = generateRandomDoubleLinkedList(maxLength, maxValue);
            if (!checkDoubleLinkedListIsReverse(getOriginDoubleLinkedValueList(doubleNode1), reverseDoubleNode(doubleNode1))) {
                System.out.println("checkDoubleLinkedListIsReverse-pointer fail");
                break;
            }
            DoubleNode doubleNode2 = generateRandomDoubleLinkedList(maxLength, maxValue);
            if (!checkDoubleLinkedListIsReverse(getOriginDoubleLinkedValueList(doubleNode2), doubleNode2)) {
                System.out.println("checkDoubleLinkedListIsReverse-container fail");
                break;
            }
        }

    }
}

```



#### 单链表实现队列与栈



```java
package com.aitx.study.base.code004;

/**
 * 用单链表结构实现队列结构
 * 用单链表结构实现栈结构
 * <p>
 * 思考：
 * 队列与栈都是抽象结构
 * 队列：队尾新增，队首出，先进先出
 * 栈：相当于瓶子，先进后出
 * <p>
 * 如果使用链表构建队列，队首、队尾 要有2个指针，再加1个size属性
 * 如果使用链表构建栈，需要1个指针，再加1个size属性
 */
public class Code004_LinkedList2QueueAndStack {

    private static class Node<T> {

        T value;

        Node<T> next;

        public Node(T value) {
            this.value = value;
        }

    }


    // 单链表实现队列
    public static class Queue<T> {


        int size;

        Node<T> head;

        Node<T> tail;

        public int size() {
            return size;
        }

        public boolean isEmpty() {
            return size == 0;
        }

        // offer
        public void offer(T value) {
            Node<T> node = new Node<>(value);
            if (tail == null) {
                head = node;
                tail = node;
            } else {
                // 要考虑新进来的节点与原来的节点的链接关系
                // 原 -》 新
                // 新 -》 原 ,这样不可取
                tail.next = node;
                tail = node;
            }
            size++;
        }

        // poll
        public T poll() {
            T result = null;
            if (head != null) {
                result = head.value;
                head = head.next;
                size--;
            }
            if (head == null) {
                tail = null;
            }
            return result;
        }


        public T peek() {
            T result = null;
            if (head != null) {
                result = head.value;
            }
            return result;
        }

    }


    // 单链表实现栈
    public static class Stack<T> {

        int size;

        Node<T> head;

        public int size() {
            return size;
        }

        public boolean isEmpty() {
            return size == 0;
        }

        // push
        public void push(T value) {
            Node<T> node = new Node<>(value);
            if (head == null) {
                head = node;
            } else {
                // 新 -》原 ，可取
                // 原 -》 新，不可取
                node.next = head;
                head = node;
            }
            size++;
        }

        // pop
        public T pop() {
            T result = null;
            if (head != null) {
                result = head.value;
                head = head.next;
            }
            return result;
        }

        // peek
        public T peek() {
            T result = null;
            if (head != null) {
                result = head.value;
            }
            return result;
        }

    }


}

```



#### 用双链表结构实现双端队列



```java
package com.aitx.study.base.code004;

/**
 * 用双链表结构实现双端队列
 * <p>
 * 思考：
 * 双端队列 Deque，Java中LinkedList就是双端队列
 * 从头可以加，从头可以减
 * 从尾可以加，从尾可以减
 * <p>
 * 用的节点的双向链表的节点
 * <p>
 * 要实现双端队列，要有头尾2个指针，size
 */
public class Code004_DoubleLinkedList2Deque {

    private static class DoubleNode<T> {

        T value;

        DoubleNode<T> pre;

        DoubleNode<T> next;

        public DoubleNode(T value) {
            this.value = value;
        }

    }

    // 用双向链表实现双端队列
    public static class Deque<T> {

        int size;

        DoubleNode<T> head;

        DoubleNode<T> tail;

        public int size() {
            return this.size;
        }

        public boolean isEmpty() {
            return size == 0;
        }

        public void offerHead(T value) {
            DoubleNode<T> doubleNode = new DoubleNode<>(value);
            if (head == null) {
                head = doubleNode;
                tail = doubleNode;
            } else {
                // 要考虑新节点与原节点的链接关系
                // 新 -》 原
                // 原 -》 新 ，2个都可以，但还是采用 更自然的 新 -》 原
                doubleNode.next = head;
                head.pre = doubleNode;
                head = doubleNode;
            }
            size++;
        }

        public void offerTail(T value) {
            DoubleNode<T> doubleNode = new DoubleNode<>(value);
            if (tail == null) {
                head = doubleNode;
                tail = doubleNode;
            } else {
                // 采用更自然的 原 -》 新
                tail.next = doubleNode;
                doubleNode.pre = tail;
                tail = doubleNode;
            }
            size++;
        }

        public T pollHead() {
            T result = null;
            if (head != null) {
                result = head.value;
                head = head.next;
                size--;
            }

            if (head == null) {
                tail = null;
            } else {
                head.pre = null;
            }
            return result;
        }

        public T pollTail() {
            T result = null;
            if (tail != null) {
                result = tail.value;
                tail = tail.pre;
                size--;
            }
            if (tail == null) {
                head = null;
            } else {
                tail.next = null;
            }
            return result;
        }

        public T peekHead() {
            T result = null;
            if (head != null) {
                result = head.value;
            }
            return result;
        }

        public T peekTail() {
            T result = null;
            if (tail != null) {
                result = tail.value;
            }
            return result;
        }

    }
}

```





#### 根据给定值删除链表节点



```java
package com.aitx.study.base;

import java.util.ArrayList;
import java.util.List;

/**
 * 通过给定值删除链表节点
 */
public class DeleteLinkedListNodeByGiveValue {


    private static class Node {

        int value;

        Node next;

        public Node(int value) {
            this.value = value;
        }
    }

    // 解法一：指针法
    private static Node deleteByGivenValue(Node head, int val) {
        // 边界
        if (head == null) {
            return null;
        }

        // 有可能头结点就是val值，所以要找到第一个不是val的节点
        while (head != null) {
            if (head.value != val) {
                break;
            }
            head = head.next;
        }
        // 退出while循环时，要么head == null 或者 head.value != val
        if (head == null) {
            return null;
        }
        Node cur = head;
        Node pre = head;
        while (cur != null) {
            if (cur.value == val) {
                pre.next = cur.next;
                cur = cur.next;
            } else {
                pre = cur;
                cur = cur.next;
            }
        }
        return head;
    }

    // 解法二：指针加强法：dummy Node
    private static Node deleteByGivenValue2(Node head, int val) {
        if (head == null) {
            return null;
        }
        Node dummyNode = new Node(Integer.MIN_VALUE);
        dummyNode.next = head;

        Node pre = dummyNode;
        Node cur = head;
        while (cur != null) {
            if (cur.value == val) {
                pre.next = cur.next;
                cur = cur.next;
            } else {
                pre = cur;
                cur = cur.next;
            }
        }
        // 退出while循环后，cur == null
        return dummyNode.next;
    }

    // 解法三：容器法
    private static Node deleteByGivenValueContainer(Node head, int val) {
        if (head == null) {
            return null;
        }
        List<Node> result = new ArrayList<>();
        while (head != null) {
            result.add(head);
            head = head.next;
        }
        // 满足条件时移除节点
        result.removeIf(node -> node.value == val);
        if (result.size() == 0) {
            return null;
        }
        // 显然这时候要重建链表
        Node firstNode = result.get(0);
        firstNode.next = null;
        int N = result.size();
        Node pre = firstNode;
        for (int i = 1; i < N; i++) {
            Node node = result.get(i);
            pre.next = node;
            node.next = null;
            pre = node;
        }

        return firstNode;

    }

    // for test 生成随机值
    private static int generateRandomValue(int maxValue) {
        return ((int) (Math.random() * (maxValue + 1))) - ((int) (Math.random() * (maxValue + 1)));
    }

    // for test 生成随机链表
    private static Node generateRandomLinkedList(int maxLength, int maxValue) {
        int length = (int) (Math.random() * (maxLength + 1));
        if (length == 0) {
            return null;
        }
        // 生成头节点
        length--;
        Node head = new Node(generateRandomValue(maxValue));
        Node cur = head;
        for (int i = 0; i < length; i++) {
            Node node = new Node(generateRandomValue(maxValue));
            cur.next = node;
            cur = node;
        }

        return head;
    }

    // for test 获取链表值 列表
    private static List<Integer> getLinkedListValueList(Node head) {
        if (head == null) {
            return new ArrayList<>();
        }
        List<Integer> result = new ArrayList<>();
        while (head != null) {
            result.add(head.value);
            head = head.next;
        }
        // 退出while循环时，head == null
        return result;
    }

    // for test 复制链表(值顺序一样)
    private static Node copyLinkedList(Node head) {
        if (head == null) {
            return null;
        }
        // 先构造头
        Node copyHead = new Node(head.value);
        Node curCopy = copyHead;
        Node cur = head.next;
        while (cur != null) {
            Node node = new Node(cur.value);
            curCopy.next = node;
            cur = cur.next;
            curCopy = node;
        }
        return copyHead;
    }

    public static void main(String[] args) {
        int testTimes = 100000;
        int maxLength = 10;
        int maxValue = 100;
        for (int i = 0; i < testTimes; i++) {
            Node head = generateRandomLinkedList(maxLength, maxValue);
            Node copyHead = copyLinkedList(head);
            if (!getLinkedListValueList(head).equals(getLinkedListValueList(copyHead))) {
                System.out.println("error");
                break;
            }
        }
    }


}

```



### 并查集



#### 并查集的HashMap实现（了解）



```java
package com.aitx.study.base.code005;


import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Stack;

/**
 * 并查集 UnionFind
 * <p>
 * 思考：
 * 想像有一堆元素，初始化时每个元素的父就是本身 并且 归属于一个集合，这个集合的大小为1，只有对应的元素
 * <p>
 * 1） 现在将2个集合合并，较小的集合的代表节点 指向 较大集合的代表节点
 * 2） 判断两个元素是否就是同一个集合，就看所归属集合的代表节点是否是同一个
 * 3） 查找某个元素的代表节点 的过程中 要将路径上所有的节点 扁平化 指向 代表节点
 * <p>
 * 那么并查集这样的结构，就要有2个HashMap：
 * 1. FatherHashMap 存储每个节点的直接父亲节点
 * 2. SizeHashMap 只存储代表节点所在集合的size
 * <p>
 * 记住以下结论：
 * 并查集的时间复杂度为big O(1)，证明过程复杂
 */
public class Code005_UnionFind {


    public static class UnionFind<T> {

        Map<T, T> fatherMap;

        Map<T, Integer> sizeMap;


        // 构造器，初始化
        public UnionFind(List<T> valueList) {

            fatherMap = new HashMap<>();
            sizeMap = new HashMap<>();

            for (T value : valueList) {
                fatherMap.put(value, value);
                sizeMap.put(value, 1);
            }
        }

        // 找代表节点
        public T findAncestor(T value) {
            Stack<T> path = new Stack<>();
            while (value != fatherMap.get(value)) {
                path.push(value);
                value = fatherMap.get(value);
            }
            // 退出循环时，value == fatherMap.get(value)，此时value 就是集合的代表节点

            // 将路径上的节点扁平化指向代表节点value
            if (!path.isEmpty()) {
                fatherMap.put(path.pop(), value);
            }
            return value;
        }

        // 两个节点是否为同一集合
        public boolean isSameSet(T valueA, T valueB) {
            return findAncestor(valueA) == findAncestor(valueB);
        }

        // 两个节点归属的集合 合并
        public void union(T valueA, T valueB) {
            T ancestorA = findAncestor(valueA);
            T ancestorB = findAncestor(valueB);
            if (ancestorA != ancestorB) {
                Integer sizeA = sizeMap.get(ancestorA);
                Integer sizeB = sizeMap.get(ancestorB);

                if (sizeA > sizeB) {
                    // valueA的集合大
                    fatherMap.put(ancestorB, ancestorA);
                    sizeMap.put(ancestorA, sizeA + sizeB);
                    sizeMap.remove(ancestorB);
                } else {
                    // valueB的集合大
                    fatherMap.put(ancestorA, ancestorB);
                    sizeMap.put(ancestorB, sizeA + sizeB);
                    sizeMap.remove(ancestorA);
                }
            }

        }

        // 求有几个集合，就是看代表节点有几个，就是sizeMap的size
        public int setNum() {
            return sizeMap.size();
        }

    }


}

```



#### 并查集的数组实现（重要）



```java
package com.aitx.study.base.code005;

/**
 * 并查集数组实现
 * <p>
 * 思考：
 * 并查集要有father数组、size数组，再加个辅助数组help用于find时记录路径值
 */
public class Code005_UnionFindArrayImp {

    public static class UnionFind {

        int[] father;

        int[] size;

        // help数组是find时扁平化用的
        int[] help;

        // 构造器初始化，入参代表共有[0,n]索引值的数
        public UnionFind(int n) {
            father = new int[n + 1];
            size = new int[n + 1];
            help = new int[n + 1];

            for (int i = 0; i <= n; i++) {
                father[i] = i;
                size[i] = 1;
            }
        }

        // 查x索引的祖先索引
        public int find(int v) {
            int hi = 0;
            while (v != father[v]) {
                help[hi++] = v;
                v = father[v];
            }
            // 退出循环时x == father[x] ，x 就是代表节点

            // 路径上的索引的父索引就是 x
            for (hi--; hi >= 0; hi--) {
                father[help[hi]] = v;
            }

            return v;
        }

        public void union(int x, int y) {
            int xAncestor = find(x);
            int yAncestor = find(y);
            if (xAncestor != yAncestor) {

                int xSize = size[xAncestor];
                int ySize = size[yAncestor];

                if (xSize > ySize) {
                    father[yAncestor] = xAncestor;
                    size[yAncestor] = xSize + ySize;
                    // 小集合的代表节点size抹不抹看具体问题而定
                } else {
                    father[xAncestor] = yAncestor;
                    size[yAncestor] = xSize + ySize;
                }

            }
        }

        public boolean isSameSet(int x, int y) {
            return find(x) == find(y);
        }
    }


}

```



#### 省份数量



```java
package com.aitx.study.base.code005;

/**
 * 有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，
 * 且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。
 * 省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。
 * <p>
 * 给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，
 * 而 isConnected[i][j] = 0 表示二者不直接相连。
 * <p>
 * 返回矩阵中 省份 的数量。
 * <p>
 * 链接：https://leetcode.cn/problems/bLyHh0/
 * <p>
 * 思考：
 * 间接相连也是同一个集合，这里显然是并查集的知识点
 */
public class Code005_FriendCircle {


    public int findCircleNum(int[][] isConnected) {
        if (isConnected == null || isConnected.length == 0) {
            return 0;
        }
        int N = isConnected.length;

        UnionFind unionFind = new UnionFind(N);

        // 只需看右上角的部分
        for (int i = 0; i < N; i++) {
            for (int j = i + 1; j < N; j++) {
                if (isConnected[i][j] == 1) {
                    unionFind.union(i, j);
                }
            }
        }
        return unionFind.sets();
    }


    // 最重要的要构建出 数组实现的并查集
    public static class UnionFind {

        // 节点的父节点
        int[] parent;


        // 集合的大小
        int[] size;

        // 辅助数组
        int[] help;

        // 集合的数量
        int sets;

        public UnionFind(int N) {
            parent = new int[N];
            size = new int[N];
            help = new int[N];
            sets = N;

            for (int i = 0; i < N; i++) {
                parent[i] = i;
                size[i] = 1;
            }
        }

        public int find(int index) {
            int hi = 0;
            while (index != parent[index]) {
                help[hi++] = index;
                index = parent[index];
            }
            // 退出循环时，index == parent[index]

            // 扁平化
            for (hi--; hi >= 0; hi--) {
                parent[help[hi]] = index;
            }

            return index;
        }

        public void union(int indexA, int indexB) {
            int parentA = find(indexA);
            int parentB = find(indexB);
            if (parentA != parentB) {
                int sizeA = size[parentA];
                int sizeB = size[parentB];
                if (sizeA > sizeB) {
                    parent[parentB] = parentA;
                    size[parentA] = sizeA + sizeB;
                } else {
                    parent[parentA] = parentB;
                    size[parentB] = sizeA + sizeB;
                }
                sets--;
            }
        }

        public int sets() {
            return sets;
        }

    }

}

```



#### 岛屿数量



```java
package com.aitx.study.base.code005;

import java.util.*;

/**
 * 岛屿数量
 * 给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。
 * 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
 * 此外，你可以假设该网格的四条边均被水包围。
 * <p>
 * 链接：https://leetcode.cn/problems/number-of-islands/description/
 * <p>
 * 思考：
 * 一、通过递归，感染的方法
 * 二、并查集
 */
public class Code005_IslandNumber {


    // 一、递归法
    public int numIslands(char[][] grid) {
        if (grid == null || grid.length == 0 || grid[0].length == 0) {
            return 0;
        }
        int result = 0;
        int rowNum = grid.length;
        int columnNum = grid[0].length;

        for (int i = 0; i < rowNum; i++) {
            for (int j = 0; j < columnNum; j++) {
                if ('1' == grid[i][j]) {
                    result++;
                    infect(grid, i, j);
                }
            }
        }
        return result;
    }

    private void infect(char[][] grid, int i, int j) {
        int rowNum = grid.length;
        int columnNum = grid[0].length;
        if (i < 0 || i >= rowNum) {
            return;
        }
        if (j < 0 || j >= columnNum) {
            return;
        }
        if ('1' != grid[i][j]) {
            return;
        }
        grid[i][j] = '2';
        infect(grid, i, j - 1); // 左
        infect(grid, i - 1, j); // 上
        infect(grid, i, j + 1); // 右
        infect(grid, i + 1, j); // 下
    }

    // ---------------------------------------

    // 二、并查集 HashMap实现
    public int numIslands2(char[][] grid) {
        if (grid == null || grid.length == 0 || grid[0].length == 0) {
            return 0;
        }
        int rowNum = grid.length;
        int columnNum = grid[0].length;

        Dot[][] dots = new Dot[rowNum][columnNum];


        // char[][] -> Dot[][] ，char数组转Dot数组，'1'就是非null，'0'就是null
        List<Dot> list = new ArrayList<>();
        for (int i = 0; i < rowNum; i++) {
            for (int j = 0; j < columnNum; j++) {
                if ('1' == grid[i][j]) {
                    dots[i][j] = new Dot();
                    list.add(dots[i][j]);
                }
            }
        }

        UnionFind<Dot> unionFind = new UnionFind<>(list);

        // 第0行
        for (int j = 1; j < columnNum; j++) {
            if (grid[0][j - 1] == '1' && grid[0][j] == '1') {
                unionFind.union(dots[0][j - 1], dots[0][j]);
            }
        }

        // 第0列
        for (int i = 1; i < rowNum; i++) {
            if (grid[i - 1][0] == '1' && grid[i][0] == '1') {
                unionFind.union(dots[i - 1][0], dots[i][0]);
            }
        }

        for (int i = 1; i < rowNum; i++) {
            for (int j = 1; j < columnNum; j++) {
                if (grid[i][j] == '1') {
                    if (grid[i][j - 1] == '1') {
                        unionFind.union(dots[i][j - 1], dots[i][j]);
                    }
                    if (grid[i - 1][j] == '1') {
                        unionFind.union(dots[i - 1][j], dots[i][j]);
                    }
                }
            }
        }

        return unionFind.sets();
    }

    private static class UnionFind<T> {

        Map<T, T> parentMap;

        Map<T, Integer> sizeMap;


        public UnionFind(List<T> values) {
            parentMap = new HashMap<>();
            sizeMap = new HashMap<>();
            for (T value : values) {
                parentMap.put(value, value);
                sizeMap.put(value, 1);
            }
        }

        public T find(T value) {
            Stack<T> path = new Stack<>();
            while (value != parentMap.get(value)) {
                path.push(value);
                value = parentMap.get(value);
            }

            // 退出循环时，value == parentMap.get(value)
            while (!path.isEmpty()) {
                parentMap.put(path.pop(), value);
            }

            return value;
        }


        public void union(T valueA, T valueB) {
            T ancestorA = find(valueA);
            T ancestorB = find(valueB);
            if (ancestorA != ancestorB) {
                Integer sizeA = sizeMap.get(ancestorA);
                Integer sizeB = sizeMap.get(ancestorB);
                if (sizeA > sizeB) {
                    parentMap.put(ancestorB, ancestorA);
                    sizeMap.put(ancestorA, sizeA + sizeB);
                    sizeMap.remove(ancestorB);
                } else {
                    parentMap.put(ancestorA, ancestorB);
                    sizeMap.put(ancestorB, sizeA + sizeB);
                    sizeMap.remove(ancestorA);
                }
            }
        }

        public int sets() {
            return sizeMap.size();
        }

    }

    private static class Dot {

    }

    // ----------------------------------------------------

    // 三、并查集 数组实现

    public int numIslands3(char[][] grid) {

        if (grid == null || grid.length == 0 || grid[0].length == 0) {
            return 0;
        }
        int rowNum = grid.length;
        int columnNum = grid[0].length;


        UnionFind3 unionFind = new UnionFind3(grid);

        // 第0行
        for (int j = 1; j < columnNum; j++) {
            if (grid[0][j - 1] == '1' && grid[0][j] == '1') {
                unionFind.union(0, j - 1, 0, j);
            }
        }

        // 第0列
        for (int i = 1; i < rowNum; i++) {
            if (grid[i - 1][0] == '1' && grid[i][0] == '1') {
                unionFind.union(i - 1, 0, i, 0);
            }
        }

        for (int i = 1; i < rowNum; i++) {
            for (int j = 1; j < columnNum; j++) {
                if (grid[i][j] == '1') {
                    if (grid[i][j - 1] == '1') {
                        unionFind.union(i, j, i, j - 1);
                    }
                    if (grid[i - 1][j] == '1') {
                        unionFind.union(i, j, i - 1, j);
                    }
                }
            }
        }

        return unionFind.sets();

    }

    private static class UnionFind3 {

        int[] parent;

        int[] size;

        int[] help;

        int sets;

        int rowNum;

        int columnNum;


        public UnionFind3(char[][] grid) {

            rowNum = grid.length;
            columnNum = grid[0].length;

            int length = rowNum * columnNum;

            parent = new int[length];
            size = new int[length];
            help = new int[length];

            sets = 0;

            for (int i = 0; i < rowNum; i++) {
                for (int j = 0; j < columnNum; j++) {
                    if (grid[i][j] == '1') {
                        int index = index(i, j);
                        parent[index] = index;
                        size[index] = 1;
                        sets++;
                    }
                }
            }

        }

        public int find(int rowIndex, int columnIndex) {

            int index = index(rowIndex, columnIndex);
            int hi = 0;

            while (index != parent[index]) {
                help[hi++] = index;
                index = parent[index];
            }

            // 退出循环时 index == parent[index]
            for (hi--; hi >= 0; hi--) {
                parent[help[hi]] = index;
            }

            return index;
        }

        public void union(int rowIndex1, int columnIndex1, int rowIndex2, int columnIndex2) {

            int ancestor1 = find(rowIndex1, columnIndex1);
            int ancestor2 = find(rowIndex2, columnIndex2);
            if (ancestor1 != ancestor2) {
                int index1 = index(rowIndex1, columnIndex1);
                int index2 = index(rowIndex2, columnIndex2);
                int size1 = size[index1];
                int size2 = size[index2];
                if (size1 > size2) {
                    parent[ancestor2] = ancestor1;
                    size[ancestor1] = size1 + size2;
                } else {
                    parent[ancestor1] = ancestor2;
                    size[ancestor2] = size1 + size2;
                }
                sets--;
            }
        }

        public int sets() {
            return sets;
        }

        private int index(int rowIndex, int columnIndex) {
            return rowIndex * columnNum + columnIndex;
        }


    }


}

```





#### 岛屿数量II



```java
package com.aitx.study.base.code005;

import java.util.*;

/**
 * 岛屿数量2
 * <p>
 * 给你一个大小为 m x n 的二进制网格 grid 。网格表示一个地图，其中，0 表示水，1 表示陆地。
 * 最初，grid 中的所有单元格都是水单元格（即，所有单元格都是 0）。
 * 可以通过执行 addLand 操作，将某个位置的水转换成陆地。给你一个数组 positions ，
 * 其中 positions[i] = [ri, ci] 是要执行第 i 次操作的位置 (ri, ci) 。
 * 返回一个整数数组 answer ，其中 answer[i] 是将单元格 (ri, ci) 转换为陆地后，地图中岛屿的数量。
 * 岛屿 的定义是被「水」包围的「陆地」，通过水平方向或者垂直方向上相邻的陆地连接而成。
 * 你可以假设地图网格的四边均被无边无际的「水」所包围。
 * <p>
 * 付费题：https://leetcode.com/problems/number-of-islands-ii/description/
 * <p>
 * 思考：
 * 岛屿数量还是用的并查集，但原来是直接给出数组，求数量
 * 现在是每次添加，必然并查集的部分初始化要放到一个方法里进行，这里就是connect()方法
 */
public class Code005_IslandNumber2 {


    public List<Integer> numIslands21(int m, int n, int[][] positions) {

        List<Integer> result = new ArrayList<>();


        UnionFind unionFind = new UnionFind();
        for (int[] position : positions) {
            result.add(unionFind.connect(position[0], position[1]));
        }

        return result;
    }

    private static class UnionFind {


        Map<String, String> parentMap;

        Map<String, Integer> sizeMap;

        Integer sets;


        private String index(int rowIndex, int columnIndex) {
            return String.valueOf(rowIndex) + "_" + String.valueOf(columnIndex);
        }


        public UnionFind() {
            parentMap = new HashMap<>();
            sizeMap = new HashMap<>();
            sets = 0;
        }


        public String find(String index) {

            Stack<String> path = new Stack<String>();

            while (index.equals(parentMap.get(index))) {

                path.push(index);

                index = parentMap.get(index);
            }

            // 退出循环时，index = parentMap.get(index)
            while (!path.isEmpty()) {
                parentMap.put(path.pop(), index);
            }

            return index;

        }

        public void union(String index1, String index2) {

            if ((!parentMap.containsKey(index1)) || (!parentMap.containsKey(index2))) {
                return;
            }


            String ancestor1 = find(index1);
            String ancestor2 = find(index2);

            if (!ancestor1.equals(ancestor2)) {
                Integer size1 = sizeMap.get(ancestor1);
                Integer size2 = sizeMap.get(ancestor2);
                if (size1 > size2) {
                    parentMap.put(ancestor2, ancestor1);
                    sizeMap.put(ancestor1, size1 + size2);
                    sizeMap.remove(ancestor2);
                } else {
                    parentMap.put(ancestor1, ancestor2);
                    sizeMap.put(ancestor2, size1 + size2);
                    sizeMap.remove(ancestor1);
                }
                sets--;
            }

        }


        public int sets() {
            return sets;
        }


        public int connect(int rowIndex, int columnIndex) {


            String index = index(rowIndex, columnIndex);
            if (!parentMap.containsKey(index)) {
                parentMap.put(index, index);
                sizeMap.put(index, 1);
                sets++;

                // 上下左右 合并
                union(index(rowIndex - 1, columnIndex), index);
                union(index(rowIndex + 1, columnIndex), index);
                union(index(rowIndex, columnIndex - 1), index);
                union(index(rowIndex, columnIndex + 1), index);
            }


            return sets();
        }

    }


    // -----------------------------------------------------------------------

    public List<Integer> numIslands22(int m, int n, int[][] positions) {

        List<Integer> result = new ArrayList<>();


        UnionFindArrayImp unionFindArrayImp = new UnionFindArrayImp(m, n);
        for (int[] position : positions) {
            result.add(unionFindArrayImp.connect(position[0], position[1]));
        }

        return result;
    }

    private static class UnionFindArrayImp {

        int[] parent;

        int[] size;

        int[] help;

        int sets;

        int rowNum;

        int columnNum;

        public UnionFindArrayImp(int rowNum, int columnNum) {

            this.rowNum = rowNum;
            this.columnNum = columnNum;
            int length = this.rowNum * this.columnNum;

            parent = new int[length];
            size = new int[length];
            help = new int[length];
            sets = 0;
        }

        private int index(int rowIndex, int columnIndex) {
            return rowIndex * columnNum + columnIndex;
        }

        public int find(int index) {

            int hi = 0;
            while (index != parent[index]) {
                help[hi++] = index;
                index = parent[index];
            }

            for (hi--; hi >= 0; hi--) {
                parent[help[hi]] = index;
            }

            return index;

        }

        public void union(int indexA, int indexB) {

            if (size[indexA] == 0 || size[indexB] == 0) {
                return;
            }

            int ancestorA = find(indexA);
            int ancestorB = find(indexB);

            if (ancestorA != ancestorB) {
                int sizeA = size[ancestorA];
                int sizeB = size[ancestorB];
                if (sizeA > sizeB) {
                    parent[ancestorB] = ancestorA;
                    size[ancestorA] = sizeA + sizeB;
                } else {
                    parent[ancestorA] = ancestorB;
                    size[ancestorB] = sizeA + sizeB;
                }

                sets--;
            }
        }

        public int sets() {
            return sets;
        }


        public int connect(int rowIndex, int columnIndex) {
            int index = index(rowIndex, columnIndex);

            if (size[index] == 0) {
                parent[index] = index;
                size[index] = 1;
                sets++;

                // 上下左右
                int up = rowIndex - 1;
                int down = rowIndex + 1;
                int left = columnIndex - 1;
                int right = columnIndex + 1;
                if (up >= 0) {
                    union(index(up, columnIndex), index);
                }
                if (down < rowNum) {
                    union(index(down, columnIndex), index);
                }
                if (left >= 0) {
                    union(index(rowIndex, left), index);
                }
                if (right < columnNum) {
                    union(index(rowIndex, right), index);
                }

            }


            return sets();

        }

    }


}

```



### 图



> 图的概念：
>
> 1）由点的集合和边的集合构成
>
> 2）虽然存在有向图和无向图的概念，但实际上都可以用有向图来表达
>
> 3）边上可能带有权值
>
> 图的常用表达形式：
>
> 1）邻接表法，比如a:b,c;d:e这里代表a的邻边是bc,d的邻边是e
>
> 2）邻接矩阵法，画张N*N的表，格子标1代表直接相连3）其他表示法



#### 图的解题常用表示法



```java
package com.aitx.study.base.code001;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;

/**
 * 图是由点与边组成
 * 点：入度，出度，值，nexts直接邻居点（指向别人的），edges直接邻居边（指向别人的）
 * 边：from(来自节点),to(去向节点),weight(权重)
 */
public class MyGraph {


    // 图的成员变量：点与边

    // 这里相当于给节加了序号，key为序号
    HashMap<Integer, Node> nodeHashMap;

    HashSet<Edge> edgeHashSet;

    public MyGraph() {

        nodeHashMap = new HashMap<>();

        edgeHashSet = new HashSet<>();

    }

    // 定义节点
    private static class Node {

        int in;

        int out;

        int value;

        List<Node> nexts;

        List<Edge> edges;

        public Node(int value) {

            in = 0;
            out = 0;
            this.value = value;
            nexts = new ArrayList<>();
            edges = new ArrayList<>();
        }
    }


    // 定义边
    private static class Edge {

        Node from;

        Node to;

        int weight;

        public Edge(Node from, Node to, int weight) {
            this.from = from;
            this.to = to;
            this.weight = weight;
        }
    }


}

```



#### 图的宽度优先遍历BFS



```java
package com.aitx.study.base.code001;

import java.util.*;

/**
 * 图的宽度优先遍历：
 * 1，利用队列实现
 * 2，从源节点开始依次按照宽度进队列，然后弹出
 * 3，每弹出一个点，把该节点所有没有进过队列的邻接点放入队列
 * 4，直到队列变空
 * <p>
 * 思考：看到宽度优先，就要想到队列
 */
public class GraphBFS {


    // 从起始节点开始宽度优先遍历
    public static void bfs(MyGraph.Node start) {
        // 边界条件
        if (start == null) {
            return;
        }

        // 走到这，代表start不为空

        Queue<MyGraph.Node> queue = new LinkedList<>();
        queue.add(start);

        Set<MyGraph.Node> set = new HashSet<>();
        // 加入set中，防止重复添加到队列
        set.add(start);

        while (!queue.isEmpty()) {

            // poll出
            MyGraph.Node poll = queue.poll();

            // 打印
            System.out.println(poll);

            // poll出节点的所有邻接节点
            List<MyGraph.Node> nexts = poll.nexts;

            for (MyGraph.Node next : nexts) {
                if (!set.contains(next)) {
                    queue.add(next);
                    set.add(next);
                }
            }

        }


    }
}

```



#### 图的深度优先遍历DFS



```java
package com.aitx.study.base.code001;

import java.util.HashSet;
import java.util.Set;
import java.util.Stack;

/**
 * 图的深度优先遍历：
 * 1，利用栈实现
 * 2，从源节点开始把节点按照深度放入栈，然后弹出
 * 3，每弹出一个点，把该节点下一个没有进过栈的邻接点放入栈
 * 4，直到栈变空
 * <p>
 * 思考：看到深度优先遍历，就要想到递归，递归都能转成栈解决
 */
public class GraphDFS {


    public static void dfs(MyGraph.Node start) {
        // 边界条件
        if (start == null) {
            return;
        }

        Stack<MyGraph.Node> stack = new Stack<>();
        Set<MyGraph.Node> set = new HashSet<>();

        stack.push(start);
        set.add(start);
        // 加入就打印
        System.out.println(start);

        while (!stack.isEmpty()) {
            // 弹栈
            MyGraph.Node pop = stack.pop();

            for (MyGraph.Node next : pop.nexts) {
                if (!set.contains(next)) {
                    // 子问题还没解决，根问题肯定要入栈，相当于一条线
                    stack.push(pop);
                    stack.push(next);
                    set.add(next);
                    System.out.println(next);
                    break;
                }
            }

        }
    }


}

```



#### 图的拓扑排序（0入度解法）



```java
package com.aitx.study.base.code001;

import java.util.*;

/**
 * 图的拓扑排序
 * 最常用的思路：入度为0的节点就是起始节点
 * <p>
 * 1）在图中找到所有入度为0的点输出
 * 2）把所有入度为0的点在图中删掉，继续找入度为0的点输出，周而复始
 * 3）图的所有点都被删除后，依次输出的顺序就是拓扑排序
 * <p>
 * 要求：有向图且其中没有环
 * 应用：事件安排、编译顺序
 */
public class GraphTopSort {


    public static List<MyGraph.Node> topSort(MyGraph graph) {
        // 边界条件
        if (graph == null) {
            return new ArrayList<>();
        }

        // 由于graph记录所有的节点与边，且节点中有入度信息，故用HashMap记录节点的入度值
        // graph.nodeHashMap key是序号，value是节点

        // 入度记录Map
        Map<MyGraph.Node, Integer> inDegreeMap = new HashMap<>();
        // 入度为0的队列
        LinkedList<MyGraph.Node> zeroInDegreeQueue = new LinkedList<>();
        for (Map.Entry<Integer, MyGraph.Node> entry : graph.nodeHashMap.entrySet()) {
            MyGraph.Node node = entry.getValue();
            inDegreeMap.put(node, node.in);
            if (inDegreeMap.get(node) == 0) {
                zeroInDegreeQueue.addLast(node);
            }
        }

        List<MyGraph.Node> result = new ArrayList<>();
        while (!zeroInDegreeQueue.isEmpty()) {
            MyGraph.Node poll = zeroInDegreeQueue.pollFirst();
            result.add(poll);
            // 消除poll出节点对邻居节点入度的影响
            for (MyGraph.Node next : poll.nexts) {
                inDegreeMap.put(next, inDegreeMap.get(next) - 1);
                if (inDegreeMap.get(next) == 0) {
                    zeroInDegreeQueue.addLast(next);
                }
            }
        }

        return result;
    }


}

```



#### 图的拓扑排序（点次解法）



```java
package com.aitx.study.base.code001;

import java.util.*;
import java.util.stream.Collectors;

/**
 * 图的拓扑排序（点次法）
 * <p>
 * 思考：如果a子图的点次 大于 b子图的点次，则a的拓扑排序在前
 * <p>
 * 链接：https://www.lintcode.com/problem/topological-sorting
 */
public class GraphTopSort_DFS_NodeTimes {

    // 题目给的类（不能修改）
    // 相当于有value值与邻接节点 这2个变量
    private static class DirectedGraphNode {
        public int label;
        public List<DirectedGraphNode> neighbors;

        public DirectedGraphNode(int x) {
            label = x;
            neighbors = new ArrayList<DirectedGraphNode>();
        }
    }

    /**
     * 这里入参是 图graph 的所有节点
     */
    public static List<DirectedGraphNode> topSort(List<DirectedGraphNode> allNodes) {

        // 边界条件
        if (allNodes == null || allNodes.isEmpty()) {
            return new ArrayList<>();
        }

        // 类比树的递归套路与动态规划 获取图节点的点次信息
        Map<DirectedGraphNode, Info> nodeTimesMap = new HashMap<>();
        for (DirectedGraphNode node : allNodes) {
            process(node, nodeTimesMap);
        }
        // 跳出循环时，收集好所有节点的点次
        // 将节点的点次信息进行从大到小排序
        List<Info> list = nodeTimesMap.values().stream().sorted(new Comparator<Info>() {
            @Override
            public int compare(Info o1, Info o2) {
                // 大的点次数，代表拓扑序越靠前
                int times1 = o1.nodeTimes;
                int times2 = o2.nodeTimes;
                if (times1 == times2) {
                    return 0;
                } else {
                    return times1 > times2 ? -1 : 1;
                }
            }
        }).collect(Collectors.toList());


        List<DirectedGraphNode> result = new ArrayList<>();

        for (Info info : list) {
            result.add(info.node);
        }

        return result;

    }


    /**
     * 相当于动态规划中的傻缓存法
     */
    private static Info process(DirectedGraphNode start, Map<DirectedGraphNode, Info> nodeTimesMap) {

        // 原递归中加入缓存
        if (nodeTimesMap.containsKey(start)) {
            return nodeTimesMap.get(start);
        }

        int nodeTimes = 1;

        for (DirectedGraphNode neighbor : start.neighbors) {
            nodeTimes += process(neighbor, nodeTimesMap).nodeTimes;
        }

        Info info = new Info(start, nodeTimes);

        nodeTimesMap.put(start, info);

        return info;
    }

    private static class Info {

        // 当前节点
        DirectedGraphNode node;

        // 当前节点作为子图的 点次
        int nodeTimes;

        public Info(DirectedGraphNode node, int nodeTimes) {
            this.node = node;
            this.nodeTimes = nodeTimes;
        }
    }

}

```



#### 图的拓扑排序（深度解法）



```java
package com.aitx.study.base.code001;

import java.util.*;
import java.util.stream.Collectors;

/**
 * 图的拓扑排序（深度法）
 * <p>
 * 思考：如果a子图的深度 大于 b子图的深度，则a的拓扑排序在前
 * <p>
 * 链接：https://www.lintcode.com/problem/topological-sorting
 */
public class GraphTopSort_DFS_Deep {

    // 题目给的类（不能修改）
    // 相当于有value值与邻接节点 这2个变量
    private static class DirectedGraphNode {
        public int label;
        public List<DirectedGraphNode> neighbors;

        public DirectedGraphNode(int x) {
            label = x;
            neighbors = new ArrayList<DirectedGraphNode>();
        }
    }

    /**
     * 这里入参是 图graph 的所有节点
     */
    public static List<DirectedGraphNode> topSort(List<DirectedGraphNode> allNodes) {

        // 边界条件
        if (allNodes == null || allNodes.isEmpty()) {
            return new ArrayList<>();
        }

        // 类比树的递归套路与动态规划 获取图节点的点次信息
        Map<DirectedGraphNode, Info> nodeDeepMap = new HashMap<>();
        for (DirectedGraphNode node : allNodes) {
            process(node, nodeDeepMap);
        }
        // 跳出循环时，收集好所有节点的点次
        // 将节点的点次信息进行从大到小排序
        List<Info> list = nodeDeepMap.values().stream().sorted(new Comparator<Info>() {
            @Override
            public int compare(Info o1, Info o2) {
                // 大的深度，代表拓扑序越靠前
                int times1 = o1.deep;
                int times2 = o2.deep;
                if (times1 == times2) {
                    return 0;
                } else {
                    return times1 > times2 ? -1 : 1;
                }
            }
        }).collect(Collectors.toList());


        List<DirectedGraphNode> result = new ArrayList<>();

        for (Info info : list) {
            result.add(info.node);
        }

        return result;

    }


    /**
     * 相当于动态规划中的傻缓存法
     */
    private static Info process(DirectedGraphNode start, Map<DirectedGraphNode, Info> nodeDeepMap) {

        // 原递归中加入缓存
        if (nodeDeepMap.containsKey(start)) {
            return nodeDeepMap.get(start);
        }

        int deep = 0;

        for (DirectedGraphNode neighbor : start.neighbors) {
            deep = Math.max(deep, process(neighbor, nodeDeepMap).deep);
        }


        Info info = new Info(start, deep + 1);

        nodeDeepMap.put(start, info);

        return info;
    }

    private static class Info {

        // 当前节点
        DirectedGraphNode node;

        // 当前节点作为子图的 深度
        int deep;

        public Info(DirectedGraphNode node, int deep) {
            this.node = node;
            this.deep = deep;
        }
    }


}

```





### 动态规划

> 暴力递归到动态规划
>
> 某一个暴力递归，有解的重复调用，就可以把这个暴力递归优化成动态规划；任何动态规划问题，都一定对应着某一个有重复过程的暴力递归。但不是所有的暴力递归，都一定对应着动态规划
>
> 
>
> 什么暴力递归可以继续优化？
>
> ​	有重复调用同一个子问题的解，这种递归可以优化；如果每一个子问题都是不同的解，无法优化也不用优化
>
> 
>
> 如何找到某个问题的动态规划方式？
>
> ​	1）设计暴力递归：重要原则+4种常见尝试模型！重点！
>
> ​	2）分析有没有重复解：套路解决
>
> ​	3）用记忆化搜索 -> 用严格表结构实现动态规划：套路解决
>
> ​	4）看看能否继续优化：套路解决
>
> 
>
> 面试中设计暴力递归过程的原则
>
> ​	1）每一个可变参数的类型，一定不要比int类型更加复杂
>
> ​	2）原则1）可以违反，让类型突破到一维线性结构，那必须是单一可变参数
>
> ​	3）如果发现原则1）被违反，但不违反原则2），只需要做到记忆化搜索即可
>
> ​	4）可变参数的个数，能少则少
>
> 
>
> 常见的4种尝试模型
>
> ​	1）从左往右的尝试模型
>
> ​	2）范围上的尝试模型
>
> ​	3）多样本位置全对应的尝试模型
>
> ​	4）寻找业务限制的尝试模型
>
> 
>
> 暴力递归到动态规划的套路
>
> ​	1）你已经有了一个不违反原则的暴力递归，而且的确存在解的重复调用
>
> ​	2）找到哪些参数的变化会影响返回值，对每一个列出变化范围
>
> ​	3）参数间的所有的组合数量，意味着表大小
>
> ​	4）记忆化搜索的方法就是傻缓存，非常容易得到
>
> ​	5）规定好严格表的大小，分析位置的依赖顺序，然后从基础填写到最终解
>
> ​	6）对于有枚举行为的决策过程，进一步优化
>
> 
>
> 动态规划的进一步优化
>
> ​	1）空间压缩
>
> ​	2）状态化简
>
> ​	3）四边形不等式
>
> ​	4）其他优化技巧



#### 机器人步行

```java
package com.aitx.study.base.code001;

/**
 * 假设有排成一行的N个位置，记为1~N，N 一定大于或等于 2
 * 开始时机器人在其中的M位置上(M 一定是 1~N 中的一个)
 * 如果机器人来到1位置，那么下一步只能往右来到2位置；
 * 如果机器人来到N位置，那么下一步只能往左来到 N-1 位置；
 * 如果机器人来到中间位置，那么下一步可以往左走或者往右走；
 * 规定机器人必须走 K 步，最终能来到P位置(P也是1~N中的一个)的方法有多少种
 * 给定四个参数 N、M、K、P，返回方法数。
 * <p>
 * 思考：考虑机器人当前在什么位置，要怎么走
 */
public class RobotWalk {


    /**
     * 方法一：暴力递归(尝试)
     * 机器人起始位置M，要走K步，目标P位置，格子有N个位置
     */
    public static int ways1(int N, int M, int P, int K) {

        if (N < 2 || M < 1 || M > N || P < 1 || P > N || K < 1) {
            return -1;
        }

        return process1(M, K, N, P);

    }

    /**
     * 机器人起始位置start，要走rest步，目标aim位置，格子有N个位置
     */
    private static int process1(int start, int rest, int N, int aim) {
        if (rest == 0) {
            return start == aim ? 1 : 0;
        }
        // 走到这，代表还有rest步要走
        if (start == 1) {
            return process1(2, rest - 1, N, aim);
        } else if (start == N) {
            return process1(N - 1, rest - 1, N, aim);
        } else {
            return process1(start - 1, rest - 1, N, aim) + process1(start + 1, rest - 1, N, aim);
        }
    }


    /**
     * 方法二：暴力递归过程中加入缓存（傻缓存）
     * 机器人起始位置M，要走K步，目标P位置，格子有N个位置
     */
    public static int ways2(int N, int M, int P, int K) {

        if (N < 2 || M < 1 || M > N || P < 1 || P > N || K < 1) {
            return -1;
        }

        // start [1,N]
        // rest [0,K]

        // 要求都从0索引开始，则表的大小为 (N + 1) * (K + 1)
        int[][] dp = new int[N + 1][K + 1];

        for (int i = 0; i <= N; i++) {
            for (int j = 0; j <= K; j++) {
                dp[i][j] = -1;
            }
        }


        return process2(M, K, N, P, dp);

    }


    /**
     * 机器人起始位置start，要走rest步，目标aim位置，格子有N个位置
     * <p>
     * 由于暴力递归有重复运算，所以可以加入傻缓存方法
     */
    private static int process2(int start, int rest, int N, int aim, int[][] dp) {
        if (dp[start][rest] != -1) {
            return dp[start][rest];
        }

        int ans;

        if (rest == 0) {
            ans = start == aim ? 1 : 0;
        } else {
            // 走到这，代表还有rest步要走
            if (start == 1) {
                ans = process1(2, rest - 1, N, aim);
            } else if (start == N) {
                ans = process1(N - 1, rest - 1, N, aim);
            } else {
                ans = process1(start - 1, rest - 1, N, aim) + process1(start + 1, rest - 1, N, aim);
            }
        }

        dp[start][rest] = ans;

        return ans;

    }


    /**
     * 方法三：暴力递归到动态规划（状态转移）
     * 机器人起始位置M，要走K步，目标P位置，格子有N个位置
     */
    public static int ways3(int N, int M, int P, int K) {

        if (N < 2 || M < 1 || M > N || P < 1 || P > N || K < 1) {
            return -1;
        }

        /**
         *         if (rest == 0) {
         *             return start == aim ? 1 : 0;
         *         }
         *         // 走到这，代表还有rest步要走
         *         if (start == 1) {
         *             return process1(2, rest - 1, N, aim);
         *         } else if (start == N) {
         *             return process1(N - 1, rest - 1, N, aim);
         *         } else {
         *             return process1(start - 1, rest - 1, N, aim) + process1(start + 1, rest - 1, N, aim);
         *         }
         */

        /**
         *         // start [1,N]
         *         // rest [0,K]
         */

        // 1。新建表
        int[][] dp = new int[N + 1][K + 1];

        // 初始化表
        dp[P][0] = 1;
        for (int rest = 1; rest <= K; rest++) {
            dp[1][rest] = dp[2][rest - 1];

            for (int start = 2; start < N; start++) {
                dp[start][rest] = dp[start - 1][rest - 1] + dp[start + 1][rest - 1];
            }

            dp[N][rest] = dp[N - 1][rest - 1];
        }

        // 机器人起始位置M，要走K步，目标P位置，格子有N个位置
        return dp[M][K];

    }


    public static void main(String[] args) {
        System.out.println(ways1(5, 2, 4, 6)); // 13
        System.out.println(ways2(5, 2, 4, 6)); // 13
        System.out.println(ways3(5, 2, 4, 6)); // 13
    }

}

```



#### 纸牌

```java
package com.aitx.study.base.code001;

/**
 * 给定一个整型数组arr，代表数值不同的纸牌排成一条线
 * 玩家A和玩家B依次拿走每张纸牌
 * 规定玩家A先拿，玩家B后拿
 * 但是每个玩家每次只能拿走最左或最右的纸牌
 * 玩家A和玩家B都绝顶聪明
 * 请返回最后获胜者的分数。
 * <p>
 * 思路：递归尝试,
 * 首先对于A与B，分先手与后手这两种规则；
 * 然后对于左右端点处的牌分两种情况，拿与不拿
 */
public class ChooseCard {


    /**
     * 方法一：暴力递归
     */
    public static int chooseCard1(int[] arr) {

        // 边界条件
        if (arr == null || arr.length == 0) {
            return -1;
        }

        // 分两种情况：先手 与 后手
        int N = arr.length;


        int f1Result = f1(0, N - 1, arr);

        int g1Result = g1(0, N - 1, arr);

        // 先手与后手选出最大的
        return Math.max(f1Result, g1Result);

    }

    /**
     * 先手函数
     */
    private static int f1(int L, int R, int[] arr) {
        if (L == R) {
            return arr[L];
        }
        // 走到这，代表至少2个数
        int p1 = arr[L] + g1(L + 1, R, arr);
        int p2 = arr[R] + g1(L, R - 1, arr);
        return Math.max(p1, p2);
    }

    /**
     * 后手函数
     */
    private static int g1(int L, int R, int[] arr) {
        if (L == R) {
            return 0;
        }
        // 走到这，
        int p1 = f1(L + 1, R, arr);
        int p2 = f1(L, R - 1, arr);
        return Math.min(p1, p2);
    }


    /**
     * 方法二：暴力递归,傻缓存(当暴力递归有相同求解时，就可以用傻缓存的方法)
     */
    public static int chooseCard2(int[] arr) {

        // 边界条件
        if (arr == null || arr.length == 0) {
            return -1;
        }

        // 分两种情况：先手 与 后手
        int N = arr.length;

        // 有两个变量：L与R
        // L的区间为[0,N-1]
        // R的区间为[0,N-1]
        // 然后相应的函数有2个，所以需要2张表，表的大小都是N * N

        // 1。新建表
        int[][] fMap = new int[N][N];
        int[][] gMap = new int[N][N];

        // 2。初始化表
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                fMap[i][j] = -1;
                gMap[i][j] = -1;
            }
        }

        int f1Result = f2(0, N - 1, arr, fMap, gMap);

        int g1Result = g2(0, N - 1, arr, fMap, gMap);

        // 先手与后手选出最大的
        return Math.max(f1Result, g1Result);

    }

    /**
     * 先手函数
     */
    private static int f2(int L, int R, int[] arr, int[][] fMap, int[][] gMap) {
        if (fMap[L][R] != -1) {
            return fMap[L][R];
        }

        if (L == R) {
            return arr[L];
        }
        // 走到这，代表至少2个数
        int p1 = arr[L] + g2(L + 1, R, arr, fMap, gMap);
        int p2 = arr[R] + g2(L, R - 1, arr, fMap, gMap);
        return Math.max(p1, p2);
    }

    /**
     * 后手函数
     */
    private static int g2(int L, int R, int[] arr, int[][] fMap, int[][] gMap) {
        if (gMap[L][R] != -1) {
            return gMap[L][R];
        }

        if (L == R) {
            return 0;
        }
        // 走到这，
        int p1 = f2(L + 1, R, arr, fMap, gMap);
        int p2 = f2(L, R - 1, arr, fMap, gMap);
        return Math.min(p1, p2);
    }


    /**
     * 方法三：暴力递归到动态规化（位置依赖）
     */
    public static int chooseCard3(int[] arr) {

        // 边界条件
        if (arr == null || arr.length == 0) {
            return -1;
        }

        // 分两种情况：先手 与 后手
        int N = arr.length;

        // 有两个变量：L与R
        // L的区间为[0,N-1]
        // R的区间为[0,N-1]
        // 然后相应的函数有2个，所以需要2张表，表的大小都是N * N

        // 1。新建表
        int[][] fMap = new int[N][N];
        int[][] gMap = new int[N][N];

        // 2。初始化表
        /** fMap
         *         if (L == R) {
         *             return arr[L];
         *         }
         *         // 走到这，代表至少2个数
         *         int p1 = arr[L] + g1(L + 1, R, arr);
         *         int p2 = arr[R] + g1(L, R - 1, arr);
         *         return Math.max(p1, p2);
         *
         *  gMap
         *          if (L == R) {
         *             return 0;
         *         }
         *         // 走到这，
         *         int p1 = f1(L + 1, R, arr);
         *         int p2 = f1(L, R - 1, arr);
         *         return Math.min(p1, p2);
         *
         */
        for (int i = 0; i < N; i++) {
            fMap[i][i] = arr[i];
        }
        for (int col = 1; col < N; col++) {
            int loopRow = 0;
            int loopCol = col;
            while (loopCol < N) {
                int fP1 = arr[loopRow] + gMap[loopRow + 1][loopCol];
                int fP2 = arr[loopCol] + gMap[loopRow][loopCol - 1];
                fMap[loopRow][loopCol] = Math.max(fP1, fP2);

                int gP1 = fMap[loopRow + 1][loopCol];
                int gP2 = fMap[loopRow][loopCol - 1];
                gMap[loopRow][loopCol] = Math.min(gP1, gP2);

                loopRow++;
                loopCol++;
            }
        }


        int f1Result = fMap[0][N - 1];

        int g1Result = gMap[0][N - 1];

        // 先手与后手选出最大的
        return Math.max(f1Result, g1Result);

    }


    public static void main(String[] args) {
        int[] arr = {5, 7, 4, 5, 8, 1, 6, 0, 3, 4, 6, 1, 7};
        System.out.println(chooseCard1(arr)); // 32
        System.out.println(chooseCard2(arr)); // 32
        System.out.println(chooseCard3(arr)); // 32
    }


}

```



#### 背包问题

```java
package com.aitx.study.base.code001;

/**
 * 给定两个长度都为N的数组weights和values，
 * weights[i]和values[i]分别代表 i号物品的重量和价值。
 * 给定一个正数bag，表示一个载重bag的袋子，
 * 你装的物品不能超过这个重量。
 * 返回你能装下最多的价值是多少?
 * <p>
 * 思考：可以考虑i号货物要还是不要，则从暴力递归到动态规划
 */
public class Knapsack {


    public static int maxValue(int[] weights, int[] values, int bag) {
        // 边界条件
        if (weights == null || values == null || weights.length != values.length || weights.length == 0) {
            return -1;
        }
        // 当前指针指到index号货物，背包容量还有rest，返回此时做决定后最大的重量
        return process(0, bag, weights, values);

    }

    /**
     * 当前指针指到index号货物，背包容量还有rest，返回此时做决定后最大的重量
     */
    private static int process(int index, int rest, int[] weights, int[] values) {
        if (rest < 0) {
            return -1;
        }
        // 走到这，代表背包还有容量
        if (index == weights.length) {
            return 0;
        }
        // 不要index位置的东西
        int p1 = process(index + 1, rest, weights, values);
        // 要index位置的东西
        int p2 = 0;
        int next = process(index + 1, rest - weights[index], weights, values);
        if (next != -1) {
            p2 = values[index] + next;
        }
        return Math.max(p1, p2);
    }

    public static int dp(int[] weights, int[] values, int bag) {
        // 边界条件
        if (weights == null || values == null || weights.length != values.length || weights.length == 0) {
            return -1;
        }
        int N = weights.length;

        // 当前指针指到index号货物，背包容量还有rest，返回此时做决定后最大的重量
        /**
         *         if (rest < 0) {
         *             return -1;
         *         }
         *         // 走到这，代表背包还有容量
         *         if (index == weights.length) {
         *             return 0;
         *         }
         *         // 不要index位置的东西
         *         int p1 = process(index + 1, rest, weights, values);
         *         // 要index位置的东西
         *         int p2 = 0;
         *         int next = process(index + 1, rest - weights[index], weights, values);
         *         if (next != -1) {
         *             p2 = values[index] + next;
         *         }
         *         return Math.max(p1, p2);
         */
        // index [0,N]
        // bag [-无穷，bag]
        // 所以，index[0,N] bag[0,bag],当bag是负数时，可以理解是-1的海洋
        // 画图分析依赖后，可得到从下到上，从左到右来初始化表
        // 1.新建表
        int[][] dp = new int[N + 1][bag + 1];

        // 2.初始化表
        for (int index = N - 1; index >= 0; index--) {
            for (int rest = 0; rest <= bag; rest++) {
                // 不要index位置的东西
                int p1 = dp[index + 1][rest];
                // 要index位置的东西
                int p2 = 0;
                int next = rest - weights[index] < 0 ? -1 : dp[index + 1][rest - weights[index]];
                if (next != -1) {
                    p2 = values[index] + next;
                }
                dp[index][rest] = Math.max(p1, p2);
            }
        }

        return dp[0][bag];

    }


    public static void main(String[] args) {
        int[] weights = {3, 2, 4, 7, 3, 1, 7};
        int[] values = {5, 6, 3, 19, 12, 4, 2};
        int bag = 15;
        System.out.println(maxValue(weights, values, bag)); // 42
        System.out.println(dp(weights, values, bag)); // 42
    }
}

```



### 滑动窗口

>滑动窗口是什么？
>
>滑动窗口是一种想象出来的数据结构：
>
>滑动窗口有左边界L和有边界R
>
>在数组或者字符串或者一个序列上，记为S，窗口就是S[L..R]这一部分
>
>L往右滑意味着一个样本出了窗口，R往右滑意味着一个样本进了窗口
>
>L和R都只能往右滑
>
>
>
>滑动内最大值和最小值的更新结构？
>
>窗口不管L还是R滑动之后，都会让窗口呈现新状况，
>
>如何能够更快的得到窗口当前状况下的最大值和最小值？
>
>最好平均下来复杂度能做到O(1)
>
>利用单调双端队列！这里一般是LinkedList,从队尾添加数据，队首弹出数据，如果
>
>要保证是最大值的滑动窗口，则添加数据时如果此数比队列中队尾的数小则添加，
>
>否则队尾的数据移出直到前面的数大时再添加数据



#### 最大值滑动窗口



```java
package com.aitx.study.base.code001;

import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;

/**
 * 假设一个固定大小为W的窗口，依次划过arr，
 * 返回每一次滑出状况的最大值
 * 例如，arr = [4,3,5,4,3,3,6,7], W = 3
 * 返回：[5,5,5,4,6,7]
 * <p>
 * 思考：看到w大小的窗口，就要想到滑动窗口法
 */
public class SlideWindowMaxArray {

    /**
     * 暴力求解，现在想到的某个窗口不断向右滑动
     * 然后求窗口内的最大值，求最大值时直接遍历求出
     */
    public static int[] right(int[] arr, int w) {
        // 边界条件
        if (arr == null || w < 1 || w > arr.length) {
            return new int[]{};
        }

        int N = arr.length;
        // 结果数组的长度与原数组长度，窗口的长度有关
        int resultLen = N - w + 1;
        int[] result = new int[resultLen];
        int resultIndex = 0;

        int L = 0;
        int R = w - 1;
        while (R < N) {

            int max = arr[L];
            for (int i = L + 1; i <= R; i++) {
                max = Math.max(arr[i], max);
            }
            result[resultIndex++] = max;
            L++;
            R++;
        }


        return result;

    }

    /**
     * 滑动窗口法，想像着窗口的LR在0位置左边，然后R向右移
     */
    public static int[] slideWindow(int[] arr, int w) {
        // 边界条件
        if (arr == null || w < 1 || w > arr.length) {
            return new int[]{};
        }

        int N = arr.length;
        // 结果数组的长度与原数组长度，窗口的长度有关
        int resultLen = N - w + 1;
        int[] result = new int[resultLen];
        int resultIndex = 0;

        // 滑动窗口通常使用LinkedList，
        // 这里要记录数据的下标(注意这里的的类型要使用LinkedList)
        LinkedList<Integer> maxQueue = new LinkedList<>();

        // 这里只需要右坐标，过期左坐标可以通过w推出来
        for (int R = 0; R < N; R++) {
            // 如果新添加的数 大于或等于 队尾的数，则队尾弹出
            while (!maxQueue.isEmpty() && (arr[R] >= arr[maxQueue.peekLast()])) {
                maxQueue.pollLast();
            }
            // 队尾添加数
            maxQueue.addLast(R);
            // 将过期的左坐标弹出,这里过期的左坐标就是R-W
            if (maxQueue.peekFirst() == R - w) {
                maxQueue.pollFirst();
            }
            // 收集结果时从w-1时开始收集
            if (R >= w - 1) {
                result[resultIndex++] = arr[maxQueue.peekFirst()];
            }
        }

        return result;

    }


    // ------------------------------------------------------------------------
    public static int[] getRandomArray(int maxLength, int maxValue) {

        // [0,1)-> [0,maxLength]
        int length = (int) (Math.random() * (maxLength + 1));

        int[] result = new int[length];

        for (int i = 0; i < length; i++) {
            result[i] = getRandomValue(maxValue);
        }

        return result;

    }

    // [-maxValue,maxValue]
    public static int getRandomValue(int maxValue) {
        // [0,maxValue] - [0,maxValue] =>  [-maxValue,maxValue]
        return ((int) (Math.random() * (maxValue + 1))) - ((int) (Math.random() * (maxValue + 1)));
    }


    public static void main(String[] args) {
        int loopTimes = 10000;
        int maxLength = 10;
        int maxValue = 100;

        for (int i = 0; i < loopTimes; i++) {
            int[] arr = getRandomArray(maxLength, maxValue);
            int w = getRandomValue(maxValue);


            int[] arr1 = right(arr, w);
            int[] arr2 = slideWindow(arr, w);

            if (!Arrays.equals(arr1, arr2)) {
                System.out.println("error");
                break;
            }

        }
    }

}

```



#### Max-Min小于num的子数组数量

```java
package com.aitx.study.base.code001;

import java.util.LinkedList;

/**
 * 给定一个整型数组arr，和一个整数num
 * 某个arr中的子数组sub，如果想达标，必须满足：
 * sub中最大值 – sub中最小值 <= num，
 * 返回arr中达标子数组的数量
 * <p>
 * 思考：子数组一定是连续的
 * 1）暴力枚举L，R求出所有的子数组，再求出子数组中的最大值与最小值
 * 2）求数组的最大值与最小值，考虑滑动窗口法
 * <p>
 * 这里要知道如果[L,R]如果达标，则所有的子数组都达标
 * 如果[L,R]不达标，R向右移，也不会达标
 * 固定L，R端点向右移，获取所有的可能子数组
 * <p>
 * 由于L，R不回退则时间复杂度O(N)
 */
public class AllLessNumSubArray {


    /**
     * 暴力法
     */
    public static int right(int[] arr, int num) {

        // 边界条件,由于是最大值-最小值，则 sum >= 0
        if (arr == null || arr.length == 0 || num < 0) {
            return 0;
        }
        int N = arr.length;


        int result = 0;

        // 遍历所有的子数组
        for (int L = 0; L < N; L++) {
            // 注意这里R不能小于L
            for (int R = L; R < N; R++) {

                int min = arr[L];
                int max = arr[L];

                for (int i = L + 1; i <= R; i++) {
                    min = Math.min(min, arr[i]);
                    max = Math.max(max, arr[i]);
                }

                if (max - min <= num) {
                    result++;
                }

            }
        }

        return result;
    }


    /**
     * 滑动窗口法（双端队列）
     */
    public static int slideWindow(int[] arr, int num) {

        // 边界条件,由于是最大值-最小值，则 sum >= 0
        if (arr == null || arr.length == 0 || num < 0) {
            return 0;
        }
        int N = arr.length;

        // R不回退
        int R = 0;

        LinkedList<Integer> maxQueue = new LinkedList<>();
        LinkedList<Integer> minQueue = new LinkedList<>();

        int result = 0;

        for (int L = 0; L < N; L++) {

            while (R < N) {

                // 此时进入的是arr[R]，从队尾进入，注意索引与值的区别
                while (!maxQueue.isEmpty() && arr[maxQueue.peekLast()] <= arr[R]) {
                    maxQueue.pollLast();
                }
                // 注意这里记录的是索引
                maxQueue.addLast(R);
                while (!minQueue.isEmpty() && arr[minQueue.peekLast()] >= arr[R]) {
                    minQueue.pollLast();
                }
                minQueue.addLast(R);

                // 加入后，要校验此时是否达标
                if (arr[maxQueue.peekFirst()] - arr[minQueue.peekFirst()] <= num) {
                    R++;
                } else {
                    break;
                }
            }

            // 跳出循环进，代表 R == N 或者 不达标
            result += R - L;


            // 下轮循环时，L要++，则需要将即将过期的索引给移除
            if (maxQueue.peekFirst() == L) {
                maxQueue.pollFirst();
            }

            if (minQueue.peekFirst() == L) {
                minQueue.pollFirst();
            }

        }

        return result;
    }


    // ----------------------------------------------------------

    // [-maxValue,maxValue]
    private static int getRandomValue(int maxValue) {
        // [0,maxValue] - [0,maxValue]
        return ((int) (Math.random() * (maxValue + 1))) - ((int) (Math.random() * (maxValue + 1)));
    }

    private static int[] getRandomArray(int maxLength, int maxValue) {
        // [0,maxLength]
        int length = ((int) (Math.random() * (maxLength + 1)));
        int[] result = new int[length];

        for (int i = 0; i < length; i++) {
            result[i] = getRandomValue(maxValue);
        }

        return result;
    }

    public static void main(String[] args) {
        int loopTimes = 10000;
        int maxLength = 10;
        int maxValue = 100;

        for (int i = 0; i < loopTimes; i++) {
            int[] arr = getRandomArray(maxLength, maxValue);
            int num = getRandomValue(maxValue);
//            int[] arr = new int[]{-2, 85, 46};
//            int num = 17;

            int res1 = right(arr, num);
            int res2 = slideWindow(arr, num);

            if (res1 != res2) {
                System.out.println("Error");
            }

        }
    }

}

```



#### 加油站

```java
package com.aitx.study.base.code001;

import java.util.LinkedList;

/**
 * 链接：https://leetcode.cn/problems/gas-station/
 * 在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。
 * 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。
 * 你从其中的一个加油站出发，开始时油箱为空。
 * <p>
 * 给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，
 * 则返回出发时加油站的编号，否则返回 -1 。
 * <p>
 * 输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
 * 输出: 3
 * 解释:
 * 从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
 * 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
 * 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
 * 开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
 * 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
 * 开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
 * 因此，3 可为起始索引。
 * <p>
 * 思考：gas[i] - cost[i] 代表要想走到下一个站点时，是否够用
 * 如果是起始点 小于0代表无法到下一站点；
 * 如果是中间节点 剩于的值 + 此值后 小于0代表无法到下一站点
 * 显然走到中间节点及最后节点（因为要走到最开始的节点）时，相当于之前的值要都加上，所以涉及数组的 前缀和 求解
 * 所以：如果在这个过程中，某个节点的前缀和小于0
 * 则 代表从开始节点出发后，这个路不是正解，
 * 这里如果这段区间内的最小值<0 也就是不是正解，如果>=0，则是正解
 */
public class GasStation {


    /**
     * 解法一：暴力解法，时间复杂度为N ^ 2
     */
    public static int right(int[] gas, int[] cost) {
        // 边界条件
        if (gas == null || cost == null || gas.length != cost.length || gas.length == 0) {
            return -1;
        }

        int N = gas.length;
        // 扩大一倍解决循环数组问题
        int M = N << 1;
        int[] arr = new int[M];

        for (int i = 0; i < N; i++) {
            // 这个节点的rest是否能支撑走到下一站点
            int rest = gas[i] - cost[i];
            arr[i] = rest;
            // 这里扩大1倍，相当于循环数组
            arr[N + i] = rest;
        }

        for (int i = 0; i < N; i++) {
            // 假设从i出发，到i+N-1共N个数都要符合才行
            int cnt = 0;
            int j = i;
            for (; j < i + N; j++) {
                cnt += arr[j];
                if (cnt < 0) {
                    break;
                }
            }
            // 走到这，代表要么是break的，要么都是符合的
            if (j == i + N) {
                return i;
            }

        }

        return -1;

    }

    /**
     * 解法二：数组前缀和，最小值滑动窗口法
     */
    public static int canCompleteCircuit(int[] gas, int[] cost) {
        // 边界条件
        if (gas == null || cost == null || gas.length != cost.length || gas.length == 0) {
            return -1;
        }

        boolean[] resultArr = goodArray(gas, cost);

        for (int i = 0; i < resultArr.length; i++) {
            if (resultArr[i]) {
                return i;
            }
        }
        return -1;

    }

    private static boolean[] goodArray(int[] gas, int[] cost) {
        int N = gas.length;
        // 由于要从[0,N-1]的某一点出发，所以延长1倍，解决循环数组问题
        int M = N << 1;

        int[] arr = new int[M];

        for (int i = 0; i < N; i++) {
            // 这个节点的rest是否能支撑走到下一站点
            int rest = gas[i] - cost[i];
            arr[i] = rest;
            // 这里扩大1倍，相当于循环数组
            arr[N + i] = rest;
        }

        // 走到这，代表有了节点rest的数组，显示能否支撑到走到下一站点，
        // 要看前面剩多少，这里要构造前缀和数组
        for (int i = 1; i < M; i++) {
            // arr[i-1]代表是前一个节点的前缀和
            arr[i] += arr[i - 1];
        }

        // 走到这，arr就是长度为2N的前缀和数组
        // 如果我们从某一节点出发，相当于求arr[i]到arr[i+N] 长度的 减去前面累加值后的 最小值
        // 比如看arr[i]，要减去arr[i-1]才是 真实的 rest值

        // 即然我们要求某区间的最小值，并且有窗口可以滑动，要想到滑动窗口法
        // 所以我们先构造长度为N的最小值滑动窗口
        LinkedList<Integer> w = new LinkedList<>();
        for (int i = 0; i < N; i++) {
            while (!w.isEmpty() && arr[i] <= arr[w.peekLast()]) {
                w.pollLast();
            }
            w.addLast(i);
        }

        // 即将滑入窗口的索引
        int enterWindowIndex = N;

        // 结果数组，元素初始化为false
        boolean[] result = new boolean[N];

        // 已滑出窗口的索引-1
        int outWindowIndex = -1;

        for (int i = 0; i < N; i++) {

            // 初始状态，窗口为[0,N-1]
            // arr[w.peekFirst()]代表是窗口的最小值，但是我们要求rest值，
            // 所以要减掉这个窗口的前一个索引的前缀和
            int offset = outWindowIndex < 0 ? 0 : arr[outWindowIndex];
            if (arr[w.peekFirst()] - offset >= 0) {
                result[i] = true;
            }
            // result数组 元素默认为false
            while (!w.isEmpty() && arr[enterWindowIndex] <= arr[w.peekLast()]) {
                w.pollLast();
            }
            w.addLast(enterWindowIndex);

            // 此时i要出队
            if (i == w.peekFirst()) {
                w.pollFirst();
            }

            enterWindowIndex++;
            outWindowIndex++;


        }


        return result;
    }


}

```



#### 求aim值的最小硬币数



```java
package com.aitx.study.base.code001;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;

/**
 * arr是货币数组，其中的值都是正数。再给定一个正数aim。
 * 每个值都认为是一张货币，
 * 返回组成aim的最少货币数
 * <p>
 * 思考：现在相当于给了个数组，自然相到某个索引的硬币要还是不要
 * 所以是动态规划
 */
public class MinCoinsNum2Aim {


    /**
     * 解法一：暴力递归
     */
    public static int minCoinsNum1(int[] arr, int aim) {
        // 边界条件
        if (arr == null || arr.length == 0 || aim == 0) {
            return 0;
        }

        return process(0, aim, arr);
    }

    /**
     * 走到index位置，此时还要完成rest量才能完成目标
     */
    private static int process(int index, int rest, int[] arr) {
        if (rest < 0) {
            // 因为要求最小值，所以最大整数就是无效值
            return Integer.MAX_VALUE;
        }
        if (index == arr.length) {
            return rest == 0 ? 0 : Integer.MAX_VALUE;
        }
        // 走到这，代表index 还是有效的

        // 第一种情况：不要index
        int p1 = process(index + 1, rest, arr);
        // 第二种情况：要index
        int p2 = process(index + 1, rest - arr[index], arr);
        if (p2 != Integer.MAX_VALUE) {
            // 代表要了此index的硬币
            p2 = p2 + 1;
        }
        return Math.min(p1, p2);
    }

    /**
     * 解法二：动态规划
     */
    public static int minCoinsNum2(int[] arr, int aim) {
        // 边界条件
        if (arr == null || arr.length == 0 || aim == 0) {
            return 0;
        }

        // 只有2个变量
        // index [0,N]
        // rest [0,aim]
        // 所以表格的大小为 （N+1）* （aim +1）
        int N = arr.length;

        // 1.创建dp表
        int[][] dp = new int[N + 1][aim + 1];

        // 2.初始化dp表
        dp[N][0] = 0;
        for (int j = 1; j <= aim; j++) {
            dp[N][j] = Integer.MAX_VALUE;
        }
        /**
         * if (rest < 0) {
         *             // 因为要求最小值，所以最大整数就是无效值
         *             return Integer.MAX_VALUE;
         *         }
         *         if (index == arr.length) {
         *             return rest == 0 ? 0 : Integer.MAX_VALUE;
         *         }
         *         // 走到这，代表index 还是有效的
         *
         *         // 第一种情况：不要index
         *         int p1 = process(index + 1, rest, arr);
         *         // 第二种情况：要index
         *         int p2 = process(index + 1, rest - arr[index], arr);
         *         if (p2 != Integer.MAX_VALUE) {
         *             // 代表要了此index的硬币
         *             p2 = p2 + 1;
         *         }
         *         return Math.min(p1, p2);
         */


        for (int index = N - 1; index >= 0; index--) {
            for (int rest = 0; rest <= aim; rest++) {
                int p1 = dp[index + 1][rest];
                int p2 = rest - arr[index] >= 0 ? dp[index + 1][rest - arr[index]] : Integer.MAX_VALUE;
                if (p2 != Integer.MAX_VALUE) {
                    p2 = p2 + 1;
                }

                dp[index][rest] = Math.min(p1, p2);
            }
        }


        // 3.返回值
        return dp[0][aim];

    }

    private static class Info {

        // 币值数组
        int[] coins;

        // 张数数组
        int[] nums;

        public Info(int[] coins, int[] nums) {
            this.coins = coins;
            this.nums = nums;
        }
    }

    private static Info getInfo(int[] arr) {
        int N = arr.length;

        // 币值 -> 张数
        Map<Integer, Integer> map = new HashMap<>();

        for (int i = 0; i < N; i++) {
            if (map.containsKey(arr[i])) {
                map.put(arr[i], map.get(arr[i]) + 1);
            } else {
                map.put(arr[i], 1);
            }
        }

        // 退出循环时，map收集完成
        int mapSize = map.size();
        // 币值
        int[] coins = new int[mapSize];
        // 张数
        int[] nums = new int[mapSize];


        int index = 0;
        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
            coins[index] = entry.getKey();
            nums[index] = entry.getValue();
            index++;
        }

        return new Info(coins, nums);
    }


    /**
     * 解法三：转化输入后 的 暴力递归
     * <p>
     * 刚才我们直接用的最原始的货币数组，
     * 我们可以将此数组再加工成 币值数组与 张数数组，再用动态规划解决
     */
    public static int minCoinsNum3(int[] arr, int aim) {
        // 边界条件
        if (arr == null || arr.length == 0 || aim == 0) {
            return 0;
        }
        Info info = getInfo(arr);
        int[] coins = info.coins;
        int[] nums = info.nums;

        return process2(0, aim, coins, nums);

    }

    /**
     * 走到index位置，前面的位置就不考虑
     * 此时要还是不要index币值，要是要几个进行考虑
     */
    private static int process2(int index, int rest, int[] coins, int[] nums) {
        if (rest < 0) {
            return Integer.MAX_VALUE;
        }
        if (index == coins.length) {
            return rest == 0 ? 0 : Integer.MAX_VALUE;
        }
        // 走到这，代表index有效
        // 第一种可能性：不要index
        int min = process2(index + 1, rest, coins, nums);
        // 第二种可能性：要index，要几个的问题
        int totalNum = nums[index];
        for (int i = 1; i <= totalNum; i++) {
            int p2 = process2(index + 1, rest - coins[index] * i, coins, nums);
            if (p2 != Integer.MAX_VALUE) {
                p2 = i + p2;
            }
            min = Math.min(min, p2);
        }

        return min;
    }

    /**
     * 解法四：转化输入后 的 暴力递归 到 动态规划
     * <p>
     * 刚才我们直接用的最原始的货币数组，
     * 我们可以将此数组再加工成 币值数组与 张数数组，再用动态规划解决
     */
    public static int minCoinsNum4(int[] arr, int aim) {
        // 边界条件
        if (arr == null || arr.length == 0 || aim == 0) {
            return 0;
        }
        Info info = getInfo(arr);
        int[] coins = info.coins;
        int[] nums = info.nums;

        int N = coins.length;

        // index [0,N]
        // rest [0,aim]
        int[][] dp = new int[N + 1][aim + 1];

        /**
         *  if (rest < 0) {
         *             return Integer.MAX_VALUE;
         *         }
         *         if (index == coins.length) {
         *             return rest == 0 ? 0 : Integer.MAX_VALUE;
         *         }
         *         // 走到这，代表index有效
         *         int min = process2(index + 1, rest, coins, nums);
         *         int totalNum = nums[index];
         *         for (int i = 1; i <= totalNum; i++) {
         *             int p2 = process2(index + 1, rest - coins[index] * i, coins, nums);
         *             if (p2 != Integer.MAX_VALUE) {
         *                 p2 = i + p2;
         *             }
         *             min = Math.min(min, p2);
         *         }
         *
         *         return min;
         */
        dp[N][0] = 0;
        for (int j = 1; j <= aim; j++) {
            dp[N][j] = Integer.MAX_VALUE;
        }

        for (int index = N - 1; index >= 0; index--) {
            for (int rest = 0; rest <= aim; rest++) {
                int min = dp[index + 1][rest];
                int totalNum = nums[index];
                // 这里有枚举的行为，现在想要优化这个循环，因为要求的是最小值，并且有入队出队的操作
                // 所以这里可以考虑最小值的滑动窗口
                for (int i = 1; i <= totalNum; i++) {
                    int p2 = rest - coins[index] * i >= 0 ? dp[index + 1][rest - coins[index] * i] : Integer.MAX_VALUE;
                    if (p2 != Integer.MAX_VALUE) {
                        p2 = i + p2;
                    }
                    min = Math.min(min, p2);
                }
                dp[index][rest] = min;

            }
        }

        return dp[0][aim];

    }


    /**
     * 解法五：通过最小值的滑动窗口优化 动态规划
     * <p>
     * 将上述有枚举行为 通过最小值的滑动窗口
     */
    public static int minCoinsNum5(int[] arr, int aim) {
        // 边界条件
        if (arr == null || arr.length == 0 || aim == 0) {
            return 0;
        }
        Info info = getInfo(arr);
        int[] coins = info.coins;
        int[] nums = info.nums;

        int N = coins.length;

        // index [0,N]
        // rest [0,aim]
        int[][] dp = new int[N + 1][aim + 1];
        dp[N][0] = 0;
        for (int j = 1; j <= aim; j++) {
            dp[N][j] = Integer.MAX_VALUE;
        }

        for (int index = N - 1; index >= 0; index--) {

            // 现在做的是枚举行为优化，使用滑动窗口法
            // 这里的mod相当于余数，根据当前的币值来跳到一下格
            int curCoin = coins[index];
            int curNum = nums[index];
            // 这里注意有可能aim比较小的情况
            for (int mod = 0; mod < Math.min((aim + 1), curCoin); mod++) {
                // 双端队列记录最小值
                LinkedList<Integer> queue = new LinkedList<>();
                queue.addLast(mod);
                // 给每个rest填值，但是是跳着填
                dp[index][mod] = dp[index + 1][mod];// 第一个跳点，因为是余数，又是因为依赖下方的数，只能是这个数了

                // 剩下的后续格子填一下
                for (int r = mod + curCoin; r <= aim; r = r + curCoin) {
                    // 现在r就是入队的rest索引，但是看动态规划的位置依赖是依赖下一级的几个枚举值
                    // 这里注意溢出的情况
                    while (!queue.isEmpty()
                            && ((dp[index + 1][queue.peekLast()] == Integer.MAX_VALUE)
                            || ((dp[index + 1][queue.peekLast()] + compensate(r, queue.peekLast(), curCoin)) >= dp[index + 1][r]))) {
                        queue.pollLast();
                    }
                    queue.addLast(r);
                    if (queue.peekFirst() == (r - curCoin * (curNum + 1))) {
                        queue.pollFirst();
                    }
                    dp[index][r] = dp[index + 1][queue.peekFirst()] == Integer.MAX_VALUE ? Integer.MAX_VALUE : dp[index + 1][queue.peekFirst()] + compensate(r, queue.peekFirst(), curCoin);
                }
            }
        }

        return dp[0][aim];
    }

    // 相当于cur钱，pre钱，当前的coin币值，求当前应该补偿多少
    private static int compensate(int cur, int pre, int coin) {
        return (cur - pre) / coin;
    }


    // 测试
    // -----------------------------------------------------------

    // [1,maxValue+1]
    public static int getRandomValue(int maxValue) {
        // 数组每个值都是正数
        return ((int) (Math.random() * (maxValue + 1))) + 1;
    }

    public static int[] getRandomArray(int maxLength, int maxValue) {
        int length = ((int) (Math.random() * (maxLength + 1)));
        int[] result = new int[length];
        for (int i = 0; i < length; i++) {
            result[i] = getRandomValue(maxValue);
        }

        return result;
    }


    public static void main(String[] args) {
        int loopTimes = 10000;
        int maxLength = 10;
        int maxValue = 100;

        for (int i = 0; i < loopTimes; i++) {
            int[] arr = getRandomArray(maxLength, maxValue);
//            int[] arr = new int[]{1, 46};
            // aim要是正数
            int aim = getRandomValue(maxValue);
//            int aim = 2;

            if (minCoinsNum4(arr, aim) != minCoinsNum5(arr, aim)) {
                System.out.println("Error");
                break;
            }

        }
    }


}

```



### 单调栈



#### 单调栈的实现(数组元素值不重复时)



```java
package com.aitx.study.base.code001;


import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import java.util.Stack;

/**
 * 单调栈
 * <p>
 * 一种特别设计的栈结构，为了解决如下的问题：
 * <p>
 * 给定一个可能含有重复值的数组arr，i位置的数一定存在如下两个信息
 * 1）arr[i]的左侧离i最近并且小于(或者大于)arr[i]的数在哪？
 * 2）arr[i]的右侧离i最近并且小于(或者大于)arr[i]的数在哪？
 * 如果想得到arr中所有位置的两个信息，怎么能让得到信息的过程尽量快。
 * <p>
 * 思考：
 * 获取某i位置左右最近的小于的数的索引，第一想到的是暴力遍历的方法，时间复杂度O(N^2)
 * <p>
 * 还有种方法，就是 单调栈 结构，时间复杂度只有O(N),因为每个元素只有入栈出栈2个操作
 * <p>
 * 以下 不考虑 重复值 的场景解法
 */
public class MonotonousStack {


    /**
     * 解法一：暴力遍历
     * <p>
     * 返回值二维数组，代表某index位置左右最近小的数的索引
     */
    public static int[][] right(int[] arr) {

        // 边界条件
        if (arr == null || arr.length == 0) {
            return new int[][]{};
        }

        int N = arr.length;

        // 返回值二维数组，代表某index位置左右最近小的数的索引
        int[][] result = new int[N][2];

        for (int i = 0; i < N; i++) {
            // 寻找左边接近的最小值
            int leftLessNear = -1;
            for (int j = i - 1; j >= 0; j--) {
                if (arr[j] < arr[i]) {
                    leftLessNear = j;
                    break;
                }
            }
            // 寻找右边接近的最小值
            int rightLessNear = -1;
            for (int j = i + 1; j < N; j++) {
                if (arr[j] < arr[i]) {
                    rightLessNear = j;
                    break;
                }
            }

            // 给index位置赋值
            result[i] = new int[]{leftLessNear, rightLessNear};

        }

        // 返回
        return result;

    }


    /**
     * 解法二：单调栈法,此方法不考虑重复值
     */
    public static int[][] getLessNearNoRepeat(int[] arr) {

        // 边界条件
        if (arr == null || arr.length == 0) {
            return new int[][]{};
        }

        int N = arr.length;

        // 返回值二维数组，代表某index位置左右最近小的数的索引
        int[][] result = new int[N][2];

        Stack<Integer> stack = new Stack<>();


        for (int i = 0; i < N; i++) {

            while (!stack.isEmpty() && arr[i] < arr[stack.peek()]) {
                // 出栈的元素要记录
                int pop = stack.pop();
                // 右边最接近的小于的数 就是 刚准备入栈的元素
                int rightLessNearIndex = i;
                // 左边最接近的小于的数 就是 弹出元素下面的元素
                int leftLessNearIndex = stack.isEmpty() ? -1 : stack.peek();

                result[pop] = new int[]{leftLessNearIndex, rightLessNearIndex};
            }
            // 退出循环时，stack要么是空 或 这个元素比较大
            // 此时遍历的元素入栈
            stack.push(i);
        }

        // 退出循环时，代表i == N，看下栈中是否有元素
        while (!stack.isEmpty()) {
            // 出栈的元素要记录
            int pop = stack.pop();
            // 右边最接近的小于的数 就是 -1
            int rightLessNearIndex = -1;
            // 左边最接近的小于的数 就是 弹出元素下面的元素
            int leftLessNearIndex = stack.isEmpty() ? -1 : stack.peek();

            result[pop][0] = leftLessNearIndex;
            result[pop][1] = rightLessNearIndex;
        }

        return result;
    }


    // -------------------------------------------------------------------
    public static int[] getRandomArray(int maxLength, int maxValue) {

        // [0,1)-> [0,maxLength]
        int length = (int) (Math.random() * (maxLength + 1));

        int[] result = new int[length];
				// 保持值不重复
        Set<Integer> set = new HashSet<>();

        for (int i = 0; i < length; i++) {
            int value;
            do {
                value = getRandomValue(maxValue);
            } while (set.contains(value));
            result[i] = value;
            set.add(value);
        }

        return result;

    }

    // [-maxValue,maxValue]
    public static int getRandomValue(int maxValue) {
        // [0,maxValue] - [0,maxValue] =>  [-maxValue,maxValue]
        return ((int) (Math.random() * (maxValue + 1))) - ((int) (Math.random() * (maxValue + 1)));
    }


    public static void main(String[] args) {
        int loopTimes = 10000;
        int maxLength = 3;
        int maxValue = 100;

        for (int i = 0; i < loopTimes; i++) {
            int[] arr = getRandomArray(maxLength, maxValue);
            if (!Arrays.deepEquals(right(arr), getLessNearNoRepeat(arr))) {
                System.out.println("Error");
                break;
            }
        }
    }
}

```



#### 单调栈的实现(数组元素值重复时)



```java
package com.aitx.study.base.code001;


import java.util.*;

/**
 * 单调栈
 * <p>
 * 一种特别设计的栈结构，为了解决如下的问题：
 * <p>
 * 给定一个可能含有重复值的数组arr，i位置的数一定存在如下两个信息
 * 1）arr[i]的左侧离i最近并且小于(或者大于)arr[i]的数在哪？
 * 2）arr[i]的右侧离i最近并且小于(或者大于)arr[i]的数在哪？
 * 如果想得到arr中所有位置的两个信息，怎么能让得到信息的过程尽量快。
 * <p>
 * 思考：
 * 获取某i位置左右最近的小于的数的索引，第一想到的是暴力遍历的方法，时间复杂度O(N^2)
 * <p>
 * 还有种方法，就是 单调栈 结构，时间复杂度只有O(N),因为每个元素只有入栈出栈2个操作
 * <p>
 * 如果 考虑 数值元素是重复值
 * 则栈要存的是List，相同值的索引放到同一个List中
 */
public class MonotonousStackRepeat {


    /**
     * 解法一：暴力遍历
     * <p>
     * 返回值二维数组，代表某index位置左右最近小的数的索引
     */
    public static int[][] right(int[] arr) {

        // 边界条件
        if (arr == null || arr.length == 0) {
            return new int[][]{};
        }

        int N = arr.length;

        // 返回值二维数组，代表某index位置左右最近小的数的索引
        int[][] result = new int[N][2];

        for (int i = 0; i < N; i++) {
            // 寻找左边接近的最小值
            int leftLessNear = -1;
            for (int j = i - 1; j >= 0; j--) {
                if (arr[j] < arr[i]) {
                    leftLessNear = j;
                    break;
                }
            }
            // 寻找右边接近的最小值
            int rightLessNear = -1;
            for (int j = i + 1; j < N; j++) {
                if (arr[j] < arr[i]) {
                    rightLessNear = j;
                    break;
                }
            }

            // 给index位置赋值
            result[i] = new int[]{leftLessNear, rightLessNear};

        }

        // 返回
        return result;

    }


    /**
     * 解法二：单调栈法,此方法考虑重复值
     */
    public static int[][] getLessNearNoRepeat(int[] arr) {

        // 边界条件
        if (arr == null || arr.length == 0) {
            return new int[][]{};
        }

        int N = arr.length;

        // 返回值二维数组，代表某index位置左右最近小的数的索引
        int[][] result = new int[N][2];

        // Stack<栈要存的是List，相同值的索引放到同一个List中<Integer>> stack = new Stack<>();
        Stack<List<Integer>> stack = new Stack<>();


        for (int i = 0; i < N; i++) {

            // 比较值时，栈中某个列表的值都一样大，所以这里直接取0
            while (!stack.isEmpty() && arr[i] < arr[stack.peek().get(0)]) {
                // 出栈的元素要记录
                List<Integer> popIndexList = stack.pop();
                // 右边最接近的小于的数 就是 刚准备入栈的元素
                int rightLessNearIndex = i;
                // 左边最接近的小于的数 就是 弹出元素下面的元素中的最右的索引值
                int leftLessNearIndex = stack.isEmpty() ? -1 : stack.peek().get(stack.peek().size() - 1);

                for (Integer popIndex : popIndexList) {
                    result[popIndex] = new int[]{leftLessNearIndex, rightLessNearIndex};
                }
            }
            // 退出循环时，stack要么是空 或 这个元素比较大
            // 此时遍历的元素入栈，要考虑重复值的问题
            if (stack.isEmpty()) {
                List<Integer> newList = new ArrayList<>();
                newList.add(i);
                stack.push(newList);
            } else {
                // 值相等情况
                if (arr[stack.peek().get(0)] == arr[i]) {
                    stack.peek().add(i);
                } else {
                    List<Integer> newList = new ArrayList<>();
                    newList.add(i);
                    stack.push(newList);
                }
            }
        }

        // 退出循环时，代表i == N，看下栈中是否有元素
        while (!stack.isEmpty()) {
            // 出栈的元素要记录
            List<Integer> popIndexList = stack.pop();
            // 右边最接近的小于的数 就是 -1
            int rightLessNearIndex = -1;
            // 左边最接近的小于的数 就是 弹出元素下面的元素
            int leftLessNearIndex = stack.isEmpty() ? -1 : stack.peek().get(stack.peek().size() - 1);

            for (Integer popIndex : popIndexList) {
                result[popIndex][0] = leftLessNearIndex;
                result[popIndex][1] = rightLessNearIndex;
            }
        }

        return result;
    }


    // -------------------------------------------------------------------
    public static int[] getRandomArray(int maxLength, int maxValue) {

        // [0,1)-> [0,maxLength]
        int length = (int) (Math.random() * (maxLength + 1));

        int[] result = new int[length];

        for (int i = 0; i < length; i++) {
            result[i] = getRandomValue(maxValue);
        }

        return result;

    }

    // [-maxValue,maxValue]
    public static int getRandomValue(int maxValue) {
        // [0,maxValue] - [0,maxValue] =>  [-maxValue,maxValue]
        return ((int) (Math.random() * (maxValue + 1))) - ((int) (Math.random() * (maxValue + 1)));
    }


    public static void main(String[] args) {
        int loopTimes = 10000;
        int maxLength = 3;
        int maxValue = 100;

        for (int i = 0; i < loopTimes; i++) {
            int[] arr = getRandomArray(maxLength, maxValue);
            if (!Arrays.deepEquals(right(arr), getLessNearNoRepeat(arr))) {
                System.out.println("Error");
                break;
            }
        }
    }
}

```



#### 子数组min*sum最大值



```java
package com.aitx.study.base.code001;

import java.util.Stack;

/**
 * 链接：https://leetcode.cn/problems/maximum-subarray-min-product/description/
 * <p>
 * 给定一个只包含正数的数组arr，arr中任何一个子数组sub，
 * 一定都可以算出(sub累加和 )* (sub中的最小值)是什么，
 * 那么所有子数组中，这个值最大是多少？
 * <p>
 * 思路：
 * 1）暴力解法，求出所有的子数组，再求最大值与最小值
 * <p>
 * 2）如果能固定最小值是某位置，此时要求乘积最大，就是sum要大
 * 也就是区间长度要长，转化成单调栈（求最小值时用）与 前缀和（求数组区间和用）
 */
public class MaxSumMinProduct {


    /**
     * 暴力解法
     */
    public static int right(int[] arr) {
        // 边界条件
        if (arr == null || arr.length == 0) {
            return -1;
        }

        int N = arr.length;

        int result = Integer.MIN_VALUE;

        for (int i = 0; i < N; i++) {
            for (int j = i; j < N; j++) {
                // 形成[i,j]区间的子数组

                int sum = 0;
                int min = Integer.MAX_VALUE;

                for (int k = i; k <= j; k++) {
                    sum += arr[k];
                    min = Math.min(min, arr[k]);
                }


                result = Math.max(result, sum * min);

            }
        }

        return result;
    }


    /**
     * 解法二：单调栈法 加 前缀和数组
     */
    public static int maxSumMinProduct(int[] arr) {
        // 边界条件
        if (arr == null || arr.length == 0) {
            return -1;
        }

        int N = arr.length;

        int result = Integer.MIN_VALUE;

        // 1.求前缀和数组
        int[] prefixSumArr = new int[N];
        prefixSumArr[0] = arr[0];
        for (int i = 1; i < N; i++) {
            prefixSumArr[i] = prefixSumArr[i - 1] + arr[i];
        }

        // 遍历过程中求单调栈最小值
        Stack<Integer> stack = new Stack<>();
        for (int i = 0; i < N; i++) {
            // 注意，这里应该用小于才是 没有复重值时的单调栈，
            // 但发现相等时也能解，所以用 <=
            while (!stack.isEmpty() && arr[i] <= arr[stack.peek()]) {
                // 假设此时弹出的数就是最小值，也就是转换成此区间要sum要尽可能大
                int popIndex = stack.pop();

                int min = arr[popIndex];

                //  int leftLessNear = stack.isEmpty() ? -1 : stack.peek();
                //  int rightLessNear = i;
                // 求[leftLessNear+1,rightLessNear-1]区间的前缀和
                int sum = stack.isEmpty() ? prefixSumArr[i - 1] : prefixSumArr[i - 1] - prefixSumArr[stack.peek()];

                result = Math.max(result, sum * min);

            }
            stack.push(i);
        }

        while (!stack.isEmpty()) {
            int popIndex = stack.pop();
            int min = arr[popIndex];

            // int leftLessNear = stack.isEmpty() ? -1 : stack.peek();
            // int rightLessNear = -1;
            // [leftLessNear+1,rightLessNear-1]
            int sum = stack.isEmpty() ? prefixSumArr[N - 1] : prefixSumArr[N - 1] - prefixSumArr[stack.peek()];

            result = Math.max(result, sum * min);
        }

        return result;

    }


    // -----------------------------------------------------
    public static int getRandomValue(int maxValue) {
        // 数组每个值都是正数
        return ((int) (Math.random() * (maxValue + 1))) + 1;
    }

    public static int[] getRandomArray(int maxLength, int maxValue) {
        int length = ((int) (Math.random() * (maxLength + 1)));
        int[] result = new int[length];
        for (int i = 0; i < length; i++) {
            result[i] = getRandomValue(maxValue);
        }

        return result;
    }

    public static void main(String[] args) {
        int loopTimes = 10000;
        int maxLength = 10;
        int maxValue = 100;

        for (int i = 0; i < loopTimes; i++) {
            // 每个元素都是正数
            int[] arr = getRandomArray(maxLength, maxValue);
            if (right(arr) != maxSumMinProduct(arr)) {
                System.out.println("Error");
                break;
            }
        }
    }

}

```



### 线段树SegmentTree



#### 线段树实现



```java
package com.aitx.study.base.code001;

/**
 * 线段树概念：
 * 在数组中要实现，一种支持范围内 整体修改 和 整体查询 的数据结构
 * 解决的问题范畴：
 * 大范围信息可以只由左、右两侧信息加工出，
 * 而不必遍历左右两个子范围所有元素的具体状况
 * 线段树的时间复杂度为logN，因为只顺着高度路径求解
 * <p>
 * 给定一个数组arr，用户希望你实现如下三个方法
 * 1）void add(int L, int R, int V) :  让数组arr[L…R]上每个数都加上V
 * 2）void update(int L, int R, int V) :  让数组arr[L…R]上每个数都变成V
 * 3）int sum(int L, int R) :让返回arr[L…R]这个范围整体的累加和
 * 怎么让这三个方法，时间复杂度都是O(logN)
 * <p>
 * 注意：通过线段树数组都是从1开始计算，
 * 如果父节点为i，左子节点为2i，右子节点为2i+1,
 * 线段树相当于将某个区间一分为二，一直分到左右端点相等
 * <p>
 * 思考：1。遍历暴力求解
 * 2。线段树，区间范围上的更新或加值或查询
 * 为什么不能用前缀和数组呢，因为前缀和数组，
 * 如果原数组有更新，则要同步更新前缀和数组，时间复杂度为O(N)
 */
public class SegmentTree {

    // 转换数组的长度
    // 线段树的索引一般都是从1开始
    int maxN;

    // 转换的数组
    int[] arr;

    // 求的 区间和 的数组
    int[] sum;

    // 加数时的懒更新数组
    int[] lazy;

    // 修改数据时的数据，由于有默认值0，
    // 所以配个是否标识某位是否更新的数组
    int[] change;

    // 标识某位是否有更新
    boolean[] update;


    /**
     * 传入origin数组，转换成
     */
    public SegmentTree(int[] origin) {
        int N = origin.length;
        // 线段树数组都是从1开始计算
        // arr中的0位置只是占位，并无实际意义
        maxN = N + 1;
        arr = new int[maxN];
        for (int i = 1; i < maxN; i++) {
            arr[i] = origin[i - 1];
        }
        // 由于将原数组实现懒更新，所以要用4N的长度来做为优化数组的长度
        sum = new int[maxN << 2];
        lazy = new int[maxN << 2];
        change = new int[maxN << 2];
        update = new boolean[maxN << 2];
    }

    /**
     * 调用此递归方法，将sum数组填充好
     * rt索引的代表区间为[l,r]
     */
    public void build(int l, int r, int rt) {

        if (l == r) {
            sum[rt] = arr[l];
            return;
        }

        int mid = l + ((r - l) >> 1);

        // 左节点构建
        build(l, mid, rt << 1);

        // 右节点构建,这里的 位或1 相当于 直接加1
        build(mid + 1, r, (rt << 1) | 1);

        // 如果左右构建好，则将rt位置的数填好
        pushUp(rt);

    }

    private void pushUp(int rt) {
        sum[rt] = sum[rt << 1] + sum[(rt << 1) | 1];
    }

    /**
     * 任务：[L,R]区间添加常数C，所于的子区间处理这个任务
     * 相当于给rt位置代表的区间[l,r]区间添加了任务,
     * <p>
     * 为什么rt位置代表的区间[l,r]都要有，
     * 因为是子任务所需要的区间端点与位置信息
     */
    public void add(int L, int R, int C, int l, int r, int rt) {
        // baseCase 如果此节点的范围则好是[L,R]的 子区间，
        // 则这个任务不需要再下发了
        if (L <= l && r <= R) {
            // 这里要更新sum 与 lazy
            // 可以看到任务可能会被某个子任务完全覆盖其中的部分区间，
            // 则只更新这个任务的节点，没有涉及到其他节点（理应要涉及），
            // 这里就是懒更新
            sum[rt] += (r - l + 1) * C;
            lazy[rt] += C;
            return;
        }
        // 走到这，代表子区间只是有点交集，
        // 比如总任务为[3,100],区间为[1,50],则需要继续的分子任务处理
        // 注意，走到这里时要将原先rt位置的旧任务下发给子任务来处理


        int mid = l + ((r - l) >> 1);

        // 将当前的任务下发到左右子节点，
        // 传入当前位置，与左右子任务节点的元素数量
        pushDown(rt, (mid - l + 1), (r - mid));

        // 给左子节点下 原任务
        if (L <= mid) {
            add(L, R, C, l, mid, rt << 1);
        }

        // 给右子节点下 原任务
        if (R > mid) {
            add(L, R, C, mid + 1, r, (rt << 1) | 1);
        }

        // 左右子任务处理完了后，需要更新sum[rt]
        pushUp(rt);
    }

    /**
     * 将rt位置的任务下发到左右子节点,
     * 左子节点代表的区间元素个数为ln,右子节代表的区间的元素个数为rn
     */
    private void pushDown(int rt, int ln, int rn) {
        // 一定是先将 更新 的任务下发，再将 加和 的任务下发
        if (update[rt]) {
            change[rt << 1] = change[rt];
            update[rt << 1] = true;
            change[(rt << 1) | 1] = change[rt];
            update[(rt << 1) | 1] = true;

            lazy[rt << 1] = 0;
            lazy[(rt << 1) | 1] = 0;

            sum[rt << 1] = change[rt] * ln;
            sum[(rt << 1) | 1] = change[rt] * rn;

            // 子任务分配好后，刷新rt位置的update 布尔值，
            // change更不更新都行，因为决定是否更新是update数组
            update[rt] = false;
            // 更新后可能还 进行了 加和 操作，看下面的代码
        }
        if (lazy[rt] != 0) {
            sum[rt << 1] += lazy[rt] * ln;
            lazy[rt << 1] += lazy[rt];
            sum[(rt << 1) | 1] += lazy[rt] * rn;
            lazy[(rt << 1) | 1] += lazy[rt];
            // 子任务分配好后，刷新rt位置的lazy值
            lazy[rt] = 0;
        }
    }

    /**
     * 将[L,R]区间的数更新为C，求区间和
     * 相当于给rt位置代表的区间[l,r]区间添加了任务,
     */
    public void update(int L, int R, int C, int l, int r, int rt) {
        // baseCase 如果此节点的范围则好是[L,R]的 子区间，
        // 则这个任务不需要再下发了
        if (L <= l && r <= R) {
            // 这里要更新change 与 update，
            // 这里就是懒更新
            sum[rt] = (r - l + 1) * C;
            change[rt] = C;
            update[rt] = true;
            // 更新操作，原来的lazy值信息就要清空
            // 因为lazy信息代表此区间有加和操作，但只要执行更新，
            // 所有的元素都变成更新的值，原加程信息需要清空
            lazy[rt] = 0;
            return;
        }
        // 走到这，代表任务要继续拆分
        int mid = l + ((r - l) >> 1);
        // 将rt位置的任务下发
        pushDown(rt, (mid - l + 1), (r - mid));

        // 左子节点 处理任务
        if (L <= mid) {
            update(L, R, C, l, mid, rt << 1);
        }
        // 右子节点 处理任务
        if (R > mid) {
            update(L, R, C, mid + 1, r, (rt << 1) | 1);
        }

        // 左右子任务处理完了后，需要更新sum[rt]
        pushUp(rt);

    }

    /**
     * 求[L,R]区间的和
     * rt位置代表的任务节点区间为[l,r]
     */
    public int query(int L, int R, int l, int r, int rt) {
        if (L <= l && r <= R) {
            return sum[rt];
        }
        // 走到这，代表要向子节点要值
        int result = 0;
        int mid = l + ((r - l) >> 1);
        // 父节点解决不了的问题，找子节点处理
        pushDown(rt, mid - l + 1, r - mid);
        if (L <= mid) {
            result += query(L, R, l, mid, rt << 1);
        }
        if (R > mid) {
            result += query(L, R, mid + 1, r, (rt << 1) | 1);
        }

        return result;
    }


    /**
     * 以下是提供的暴力求解法
     */
    private static class Right {

        int[] arr;

        int MaxN;

        public Right(int[] origin) {
            int N = origin.length;
            MaxN = N + 1;
            arr = new int[MaxN];
            for (int i = 1; i < MaxN; i++) {
                arr[i] = origin[i - 1];
            }
        }


        public void add(int L, int R, int C) {
            for (int i = L; i <= R; i++) {
                arr[i] += C;
            }
        }

        public void update(int L, int R, int C) {
            for (int i = L; i <= R; i++) {
                arr[i] = C;
            }
        }

        public int query(int L, int R) {
            int result = 0;
            for (int i = L; i <= R; i++) {
                result += arr[i];
            }
            return result;
        }

    }

    // -------------------------------------------------------
    private static int[] getRandomArray(int maxlength, int maxValue) {
        int length = (int) (Math.random() * (maxlength + 1)) + 1;
        int[] origin = new int[length];
        for (int i = 0; i < length; i++) {
            origin[i] = getRandomValue(maxValue);
        }
        return origin;
    }

    private static int getRandomValue(int maxValue) {
        return ((int) (Math.random() * (maxValue + 1))) - ((int) (Math.random() * (maxValue + 1)));
    }

    public static void main(String[] args) {
        int loopTimes = 10000;
        int maxLength = 10;
        int maxValue = 100;

        for (int i = 0; i < loopTimes; i++) {

            int[] origin = getRandomArray(maxLength, maxValue);
            int N = origin.length;

            SegmentTree segmentTree = new SegmentTree(origin);
            segmentTree.build(1, N, 1);
            Right right = new Right(origin);

            // 生成左右端点，转换的数组范围是[0,N]
            int L = ((int) (Math.random() * N)) + 1;// [1,N]
            int R = ((int) (Math.random() * (N - L + 1))) + L;// [L,N]

            int C = getRandomValue(maxValue);

            if (Math.random() < 0.5) {
                segmentTree.add(L, R, C, 1, N, 1);
                right.add(L, R, C);
            } else {
                segmentTree.update(L, R, C, 1, N, 1);
                right.update(L, R, C);
            }

            if (segmentTree.query(L, R, 1, N, 1) != right.query(L, R)) {
                System.out.println("Error");
                break;
            }

        }
    }


}

```



#### 落方块



```java
package com.aitx.study.base.code002;

import java.util.*;

/**
 * 链接：https://leetcode.cn/problems/falling-squares/
 * <p>
 * 在二维平面上的 x 轴上，放置着一些方块。
 * 给你一个二维整数数组 positions ，其中 positions[i] = [left, sideLength]
 * 表示：第 i 个方块边长为 sideLength ，其左侧边与 x 轴上坐标点 left 对齐。
 * 每个方块都从一个比目前所有的落地方块更高的高度掉落而下。方块沿 y 轴负方向下落，
 * 直到着陆到 另一个正方形的顶边 或者是 x 轴上 。
 * 一个方块仅仅是擦过另一个方块的左侧边或右侧边不算着陆。一旦着陆，它就会固定在原地，无法移动。
 * 在每个方块掉落后，你必须记录目前所有已经落稳的 方块堆叠的最高高度 。
 * 返回一个整数数组  ans，其中 ans[i] 表示在第 i 块方块掉落后堆叠的最高高度。
 * <p>
 * 思考：将x轴看成区间，y轴看成高度，所以能转换对应的区间最大值，所以是线段树可以解决
 * 然后x轴点可以压缩成离散的点，且左闭右开解决贴边问题
 */
public class FallingSquares {


    private static class SegmentTree {

        int maxN;

        int[] max;

        int[] change;

        boolean[] update;


        public SegmentTree(int N) {
            maxN = N + 1;
            max = new int[maxN << 2];
            change = new int[maxN << 2];
            update = new boolean[maxN << 2];
        }

        public int query(int L, int R) {
            return queryProcess(L, R, 1, maxN - 1, 1);
        }

        private int queryProcess(int L, int R, int l, int r, int rt) {
            if (L <= l && r <= R) {
                return max[rt];
            }

            int mid = l + ((r - l) >> 1);

            pushDown(mid - l + 1, r - mid, rt);

            // 处理左节点的任务
            int left = 0;
            if (L <= mid) {
                left = queryProcess(L, R, l, mid, rt << 1);
            }

            // 处理右节点的任务
            int right = 0;
            if (R > mid) {
                right = queryProcess(L, R, mid + 1, r, (rt << 1) | 1);
            }

            return Math.max(left, right);

        }

        public void update(int L, int R, int C) {
            updateProcess(L, R, C, 1, maxN - 1, 1);
        }

        private void updateProcess(int L, int R, int C, int l, int r, int rt) {
            if (L <= l && r <= R) {
                change[rt] = C;
                update[rt] = true;
                max[rt] = C;
                return;
            }
            // 如果rt节点入处理不了任务，则需要分解任务
            int mid = l + ((r - l) >> 1);
            pushDown(mid - l + 1, r - mid, rt);

            // 处理左节点的任务
            if (L <= mid) {
                updateProcess(L, R, C, l, mid, rt << 1);
            }

            // 处理右节点的任务
            if (R > mid) {
                updateProcess(L, R, C, mid + 1, r, (rt << 1) | 1);
            }

            pushUp(rt);

        }

        /**
         * 收集rt索引的 值
         */
        private void pushUp(int rt) {
            max[rt] = Math.max(max[rt << 1], max[(rt << 1) | 1]);
        }

        private void pushDown(int ln, int rn, int rt) {
            if (update[rt]) {
                update[rt << 1] = true;
                update[(rt << 1) | 1] = true;
                change[rt << 1] = change[rt];
                change[(rt << 1) | 1] = change[rt];

                max[rt << 1] = change[rt];
                max[(rt << 1) | 1] = change[rt];

                update[rt] = false;
            }
        }

    }


    public List<Integer> fallingSquares(int[][] positions) {

        // 边界条件
        if (positions == null || positions.length == 0) {
            return new ArrayList<>();
        }

        // 这里先收集所有集点的端点对应的离散值，每个端点的离散值不一样
        Map<Integer, Integer> map = index(positions);
        int N = map.size();
        SegmentTree segmentTree = new SegmentTree(N);

        int maxHeight = 0;
        List<Integer> result = new ArrayList<>();
        for (int[] position : positions) {
            int L = map.get(position[0]);
            int R = map.get(position[0] + position[1] - 1);
            int curHeight = position[1];


            int height = segmentTree.query(L, R) + curHeight;

            maxHeight = Math.max(maxHeight, height);
            result.add(maxHeight);

            segmentTree.update(L, R, height);
        }

        return result;


    }

    private Map<Integer, Integer> index(int[][] positions) {
        // 使用TreeSet排序去重
        Set<Integer> set = new TreeSet<>();
        for (int[] position : positions) {
            int left = position[0]; // 左端点
            // 右端点按理说是position[0] + position[1],
            // 这里-1是左闭右开，解决值贴边的情况，要左端点代表这个线段
            int right = position[0] + position[1] - 1;
            set.add(left);
            set.add(right);
        }
        // 退出循环，收集到所有的端点
        // 再将所有的端点离散化，从1开始计数
        Map<Integer, Integer> result = new HashMap<>();

        int cnt = 1;
        for (Integer point : set) {
            result.put(point, cnt);
            cnt++;
        }

        return result;
    }


}

```



### 索引树IndexTree



#### IndexTree实现

```java
package com.aitx.study.base.code002;

/**
 * IndexTree
 * <p>
 * 特点：
 * 1）支持区间查询
 * 2）没有线段树那么强，但是非常容易改成一维、二维、三维的结构
 * 3）只支持单点更新
 * <p>
 * 思考：线段树是某节点代表某个区间的求值
 * 那么有没有一种结构方便进行位运算，且代表某个区间的求值
 * IndexTree就是这样的结构,索引也是从1开始算
 * 举例
 * arr = 1,2,3,4,....
 * tree = {1},{1,2},{3},{1,2,3,4}
 * 1位置只有1个，2位置是1个，前面也是1个，所以可以合并{1,2}
 * 3位置1个，前面是2个不能合并
 * 4位置1个，前面也是1个，所以合并成{3,4},合并后前面是{1,2},所以再合并成{1,2,3,4}
 * <p>
 * 时间复杂度：index二进制表示时有多少位1，就是时间复杂度
 */
public class IndexTree {

    int maxN;

    int[] tree;

    public IndexTree(int N) {
        maxN = N + 1;
        tree = new int[maxN];
    }

    /**
     * 给index位置加上C，如果提供个原始数组，则可以遍历调用此方法
     */
    public void add(int index, int C) {
        while (index < maxN) {
            // 某位置加数
            tree[index] += C;
            // 可以发现规律，刚好加最右侧的1就是下一跳位置
            index += index & (-index);
        }
    }

    /**
     * 求[1,index]位置的区间和
     */
    public int sum(int index) {
        int result = 0;
        while (index > 0) {
            result += tree[index];
            // 可以发现规律，刚好减最右侧的1就是向左下一跳位置
            index -= index & (-index);
        }
        return result;
    }

    /**
     * 暴力解法：遍历
     */
    private static class Right {

        int maxN;

        int[] origin;

        public Right(int N) {
            maxN = N + 1;
            origin = new int[maxN];
        }


        /**
         * index位置加上常数C
         */
        public void add(int index, int C) {
            origin[index] += C;
        }

        /**
         * [1,index]位置求区间和
         */
        public int sum(int index) {
            int result = 0;

            for (int i = 1; i <= index; i++) {
                result += origin[i];
            }

            return result;
        }


    }


    // ------------------------------------------------------------
    public static int getRandomValue(int maxValue) {
        // [0,maxValue] - [0,maxValue] ==> [-maxValue,maxValue]
        return ((int) (Math.random() * (maxValue + 1))) - ((int) (Math.random() * (maxValue + 1)));
    }

    public static void main(String[] args) {
        int loopTimes = 1000;
        int maxLength = 10;
        int maxValue = 100;
        int maxAdd = 10;

        for (int i = 0; i < loopTimes; i++) {
            // [1,maxLength]
            int N = ((int) (Math.random() * (maxLength))) + 1;


            IndexTree indexTree = new IndexTree(N);
            Right right = new Right(N);

            for (int j = 0; j < maxAdd; j++) {
                // [1,N]
                int index = (int) (Math.random() * (N)) + 1;
                int C = getRandomValue(maxValue);
                indexTree.add(index, C);
                right.add(index, C);
            }

            if (indexTree.sum(N) != right.sum(N)) {
                System.out.println("Error");
                break;
            }

        }
    }


}

```



#### IndexTree二维拓展



```java
package com.aitx.study.base.code002;

/**
 * 收费题：https://leetcode.cn/problems/range-sum-query-2d-mutable/description/
 * <p>
 * 给定一个二维矩阵，计算从下标(row1, col1) 到下标： (row2, col2)的子矩阵的和
 * <p>
 * 思考：indexTree相当于是一维的，更新某个索引值时，再求区间和
 * 现在indexTree可以拓展到多维，求的是某区域的区间和
 */
public class IndexTree2D {

    private static class IndexTree {

        int maxRow;

        int maxCol;

        // index数组，记录某个区间的和，下标从1开始
        int[][] tree;

        // 原数组转换成的数组，下标从1开始
        int[][] trans;

        public IndexTree(int[][] origin) {
            int row = origin.length;
            int col = origin[0].length;
            maxRow = row + 1;
            maxCol = col + 1;
            tree = new int[maxRow][maxCol];
            trans = new int[maxRow][maxCol];

            // 初始化
            for (int i = 0; i < row; i++) {
                for (int j = 0; j < col; j++) {
                    trans[i + 1][j + 1] = origin[i][j];
                    add(i + 1, j + 1, origin[i][j]);
                }
            }
        }

        /**
         * 在(row,col)加上常数C，这晨row,col都是从索引1开始
         */
        public void add(int row, int col, int C) {
            // tree数组变化
            for (int i = row; i < maxRow; i += (i & (-i))) {
                for (int j = col; j < maxCol; j += (j & (-j))) {
                    tree[i][j] += C;
                }
            }
            // trans数组变化
            trans[row][col] += C;
        }

        /**
         * 求[1,1] -> [row,col] 区域的和
         */
        public int sum(int row, int col) {
            int result = 0;
            for (int i = row; i > 0; i -= i & (-i)) {
                for (int j = col; j > 0; j -= j & (-j)) {
                    result += tree[i][j];
                }
            }
            return result;
        }

    }

    /**
     * 求二维数组区域和[row1,col1]->[row2,col2]
     */
    public static int regionSum(int[][] matrix, int row1, int col1, int row2, int col2) {
        // 边界条件
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return -1;
        }
        int row = matrix.length;
        int col = matrix[0].length;
        if (row1 < 0 || row2 < 0 || row1 >= row || row2 >= row) {
            return -1;
        }
        if (col1 < 0 || col2 < 0 || col1 >= col || col2 >= col) {
            return -1;
        }

        // 使用indexTree二维结构 来协助 求解
        IndexTree indexTree = new IndexTree(matrix);

        // 求二维数组区域和[row1,col1]->[row2,col2]
        // 注意这里要记得indexTree的索引从1开始，所以原坐标要加1
        return indexTree.sum(row2 + 1, col2 + 1)
                - indexTree.sum(row1, col2 + 1)
                - indexTree.sum(row2 + 1, col1)
                + indexTree.sum(row1, col1);
    }


}

```



### AC自动机



#### AC自动机实现



```java
package com.aitx.study.base.code002;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

/**
 * AC自动机（AC是人名）
 * 解决在一个大字符串中，找到多个候选字符串的问题
 * 步骤：
 * 1）把所有匹配串生成一棵前缀树
 * 2）前缀树节点增加fail指针
 * 3）fail指针的含义：如果必须以当前字符结尾，当前形成的路径是str，
 * 剩下哪一个字符串的前缀和str的后缀，拥有最大的匹配长度。
 * fail指针就指向那个字符串的最后一个字符所对应的节点。
 */
public class ACAutomation {

    PrefixTree prefixTree;

    public ACAutomation() {
        prefixTree = new PrefixTree();
    }

    /**
     * AC自动机依赖前缀树结构（英文PrefixTree或Trie）
     */
    private static class PrefixTree {

        // 前缀树头节点
        Node root;

        public PrefixTree() {
            root = new Node();
        }

        /**
         * 前缀树节点
         */
        private static class Node {

            // pass与end数量这里并不需要
            // 结尾节点代表的str
            String endStr;

            // 结尾是否使用
            boolean endUse;

            // 邻居节点
            Node[] nexts;

            // AC自动机使用的fail指针
            Node fail;

            public Node() {
                endStr = null;
                endUse = false;
                // 这里假设只有26个英文字母，如果实际有其他字符，可以通过HashMap定义
                nexts = new Node[26];
            }

        }

        /**
         * 前缀树,支持重复插入
         */
        public void insert(String str) {
            // 边界条件
            if (str == null || str.length() == 0) {
                return;
            }

            char[] chars = str.toCharArray();
            int N = chars.length;

            Node cur = this.root;
            for (int i = 0; i < N; i++) {
                int index = chars[i] - 'a';
                if (cur.nexts[index] == null) {
                    cur.nexts[index] = new Node();
                }
                cur = cur.nexts[index];
            }
            // 退出循环时，cur指向最后一个节点
            if (cur.endStr == null) {// 记录最后的节点为str
                cur.endStr = str;
            }
        }

        /**
         * 构建出fail指针,按层遍历所以需要队列结构
         * 有3个准则：
         * 头结点的fail指向null
         * 头结点的子节点fail 指向 头节点
         * 其他节点：沿着父节点的 fail 链向上找，看是否有相同的路，有则设置 fail
         */
        public void buildFail() {

            // 使用队列来处理 按层遍历
            LinkedList<Node> queue = new LinkedList<>();
            queue.addLast(root);

            while (!queue.isEmpty()) {
                // 头结节指向null
                Node poll = queue.pollFirst();
                for (int i = 0; i < 26; i++) {
                    if (poll.nexts[i] != null) {
                        // 除了头节点外，其他节点fail默认指向root头结点
                        poll.nexts[i].fail = root;
                        Node pollFail = poll.fail;
                        // 父是poll,子poll.next[i]
                        // 对应着
                        // 父是pollFail,子pollFail.next[i]
                        while (pollFail != null) {
                            // 如果父结点的fail有相同的路，
                            // 则poll子的fail需要指向pollFail的子
                            if (pollFail.nexts[i] != null) {
                                poll.nexts[i].fail = pollFail.nexts[i];
                                break;
                            }
                            // 如果没找到需要fail指针跳
                            pollFail = pollFail.fail;
                        }

                        // poll.nexts[i] != null 时代表是有效的通路，
                        // 需要加入队列中继续按层遍历
                        queue.addLast(poll.nexts[i]);

                    }
                }
            }

        }

    }

    /**
     * 大文章content是否包含前缀树中的str
     */
    public List<String> containsStrs(String content) {

        // trie.insert(); 初始化trie前缀树
        // trie.buildFail(); trie前缀树构建fail指针

        PrefixTree.Node root = prefixTree.root; // trie树的头结点

        // 大文章转成字符数组
        char[] chars = content.toCharArray();
        int N = chars.length;

        List<String> result = new ArrayList<>();
        PrefixTree.Node cur = root;

        // 遍历大文章
        for (int i = 0; i < N; i++) {
            // 文章中字符的路径索引
            int index = chars[i] - 'a';
            // 非头节点时cur没有通路时，要通过fail跳到下个节点
            while (cur.nexts[index] == null && cur != root) {
                cur = cur.fail;
            }
            // 退出循环时，cur.nexts[index] != null有通路 或 cur == root
            // 如果有通路或者是root，跳到下个节点
            cur = cur.nexts[index] != null ? cur.nexts[index] : root;
            // 每跳到一个节点时，要看看此时节点及其fail后续是否有命中的str
            PrefixTree.Node follow = cur;
            while (follow != root) { // 跳到root节点时，代表终止
                // 是否记录过
                if (follow.endUse) {
                    break;
                }
                // 如果是str的终止节点，要记录
                if (follow.endStr != null) {
                    result.add(follow.endStr);
                    follow.endUse = true;
                    // 注意这里要看看后续的fail要不要收集，不要break
                }
                follow = follow.fail;
            }
        }
        // 返回结果
        return result;
    }

    public static void main(String[] args) {
        ACAutomation ac = new ACAutomation();
        ac.prefixTree.insert("dhe");
        ac.prefixTree.insert("he");
        ac.prefixTree.insert("abcdheks");
        ac.prefixTree.insert("abcdheksbb");
        // 设置fail指针
        ac.prefixTree.buildFail();

        List<String> contains = ac.containsStrs("abcdhekskdjfafhasld");
        for (String word : contains) {
            System.out.println(word);
        }
    }
}

```



### Morris遍历



#### Morris遍历实现



```Java
package com.aitx.study.base.code002;

/**
 * 二叉树的morris遍历
 * <p>
 * 一种遍历二叉树的方式，并且时间复杂度O(N)，额外空间复杂度O(1)
 * 通过利用原树中大量空闲指针的方式，达到节省空间的目的
 * <p>
 * 对于没有左子树的节点只到达一次，
 * 对于有左子树的节点会到达两次
 * <p>
 * 遍历过程：
 * 假设来到当前节点cur，开始时cur来到头节点位置
 * 1）如果cur没有左孩子，cur向右移动(cur = cur.right)
 * 2）如果cur有左孩子，找到左子树上最右的节点mostRight：
 * a.如果mostRight的右指针指向空，让其指向cur，
 * 然后cur向左移动(cur = cur.left)
 * b.如果mostRight的右指针指向cur，让其指向null，
 * 然后cur向右移动(cur = cur.right)
 * 3）cur为空时遍历停止
 *
 * <p>
 * 思考：
 * 二叉树的遍历大体分为三种：
 * 深度遍历：DFS分前序、中序、后序
 * 宽度遍历：BFS
 * Morris遍历：时间复杂度一样，但省空间
 */
public class BinaryTreeMorrisTravel {

    /**
     * 二叉树节点
     */
    private static class Node {

        int value;

        Node left;

        Node right;

        public Node(int value) {
            this.value = value;
        }
    }

    /**
     * morris遍历
     */
    public void morris(Node root) {
        // 边界条件
        if (root == null) {
            return;
        }

        Node cur = root;
        // cur为null退出循环
        while (cur != null) {

            // 左子树为空时，直接跳到right
            if (cur.left == null) {
                cur = cur.right;
            } else {
                // 左子树不为空时，要看mostRight的情况
                Node mostRight = cur.left;
                // 求左子树的最右节点
                while (mostRight.right != null && mostRight.right != cur) {
                    mostRight = mostRight.right;
                }
                // 走到这，代表mostRight.right == null || mostRight.right == cur
                if (mostRight.right == null) {
                    mostRight.right = cur;
                    cur = cur.left;
                } else {
                    // mostRight.right == cur
                    mostRight.right = null;
                    // 这里可以跟第一个if条件合并,抽到外边去
                    cur = cur.right;
                }
            }
        }

    }

    /**
     * 解法二：DFS遍历
     */
    public void dfs(Node root) {
        // 边界条件
        if (root == null) {
            return;
        }
        process(root);
    }

    private void process(Node root) {
        if (root == null) {
            return;
        }

        // 根据root节点处理位置的不同，分为前中后序
        // System.out.println(root.value); // 前序
        process(root.left);
        // System.out.println(root.value); // 中序
        process(root.right);
        // System.out.println(root.value); // 后序
    }


}

```



#### Morris遍历前序(易)、中序(易)、后序(难)

```java
package com.aitx.study.base.code002;

/**
 * morris遍历实现前序、中序、后序
 * <p>
 * 思考：
 * Morris遍历有如下规律
 * 某个节点如果有左子树 会来到此节点2次
 * 没有左子树，只会来到一次
 * 所以可以考虑在合适的时机打印
 */
public class MorrisTravel {

    /**
     * 二叉树节点
     */
    private static class Node {

        int value;

        Node left;

        Node right;

        public Node(int value) {
            this.value = value;
        }
    }

    /**
     * Morris遍历序
     */
    public void morris(Node root) {
        if (root == null) {
            return;
        }

        Node cur = root;

        while (cur != null) {

            if (cur.left == null) {
                // 如果没有左子树，只会来到此节点1次
                cur = cur.right;
            } else {
                // 有左子树，会来到此节点2次
                Node mostRight = cur.left;
                while (mostRight.right != null && mostRight.right != cur) {
                    mostRight = mostRight.right;
                }
                if (mostRight.right == null) {
                    // 有左子树场景，第一次来到
                    mostRight.right = cur;
                    cur = cur.left;
                } else {
                    // 有左子树场景，第一次来到
                    mostRight.right = null;
                    cur = cur.right;
                }
            }
        }
    }

    /**
     * morris前序遍历，只会在第一次来到节点时打印，就是前序
     */
    public void morrisPre(Node root) {
        if (root == null) {
            return;
        }

        Node cur = root;

        while (cur != null) {

            if (cur.left == null) {
                // 如果没有左子树，只会来到此节点1次
                System.out.println(cur.value + " ");
                cur = cur.right;
            } else {
                // 有左子树，会来到此节点2次
                Node mostRight = cur.left;
                while (mostRight.right != null && mostRight.right != cur) {
                    mostRight = mostRight.right;
                }
                if (mostRight.right == null) {
                    // 有左子树场景，第一次来到
                    System.out.println(cur.value + " ");
                    mostRight.right = cur;
                    cur = cur.left;
                } else {
                    // 有左子树场景，第二次来到
                    mostRight.right = null;
                    cur = cur.right;
                }
            }
        }
    }

    /**
     * morris中序遍历，只会在第二次来到节点时打印，就是中序
     */
    public void morrisIn(Node root) {
        if (root == null) {
            return;
        }

        Node cur = root;

        while (cur != null) {

            if (cur.left == null) {
                // 如果没有左子树，只会来到此节点1次
                System.out.println(cur.value + " ");
                cur = cur.right;
            } else {
                // 有左子树，会来到此节点2次
                Node mostRight = cur.left;
                while (mostRight.right != null && mostRight.right != cur) {
                    mostRight = mostRight.right;
                }
                if (mostRight.right == null) {
                    // 有左子树场景，第一次来到
                    mostRight.right = cur;
                    cur = cur.left;
                } else {
                    // 有左子树场景，第二次来到
                    System.out.println(cur.value + " ");
                    mostRight.right = null;
                    cur = cur.right;
                }
            }
        }
    }

    /**
     * morris后序遍历，只会在第二次来到节点时打印，但是倒着打印某左子树的右边所有节点
     * 最后再打印头节点的右边所有节点
     */
    public void morrisPos(Node root) {
        if (root == null) {
            return;
        }

        Node cur = root;

        while (cur != null) {

            if (cur.left == null) {
                // 如果没有左子树，只会来到此节点1次
                cur = cur.right;
            } else {
                // 有左子树，会来到此节点2次
                Node mostRight = cur.left;
                while (mostRight.right != null && mostRight.right != cur) {
                    mostRight = mostRight.right;
                }
                if (mostRight.right == null) {
                    // 有左子树场景，第一次来到
                    mostRight.right = cur;
                    cur = cur.left;
                } else {
                    // 有左子树场景，第二次来到
                    printEdge(cur.left);// 注意：打印某左子树的右边所有节点
                    mostRight.right = null;
                    cur = cur.right;
                }
            }
        }
        // 最后要打印头节点的右边
        printEdge(root);
    }

    /**
     * 倒着打印
     */
    private void printEdge(Node root) {
        // 逆序所有节点
        Node tail = reverseEdge(root);
        Node cur = tail;
        while (cur != null) {
            System.out.println(cur.value + " ");
            cur = cur.right;
        }
        // 记得逆序回来
        reverseEdge(tail);
    }

    private Node reverseEdge(Node root) {
        Node pre = null;
        Node cur = root;
        while (cur != null) {
            Node next = cur.right;
            cur.right = pre;
            pre = cur;
            cur = next;
        }
        // 退出循环时cur == null ,pre指向最后节点
        return pre;
    }


}

```

