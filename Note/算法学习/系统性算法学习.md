

---

author: aitx

title: 系统性算法学习

time: 2023-12-17 周六

tags: 
  - 算法
  - 学习
  - 编程

---

## 基础入门



### 二进制与位运算简介

```
二进制：用0、1表示，逢二进一

位运算：与&，或｜，非！，异或^

```



### 阶乘和

```java
package com.aitx.study.base;  
  
/**  
 * 阶乘和 * 给定一个参数N， 
 * 返回：  1! + 2! + 3! + 4! + … + N!   的结果 
 * <p>  
 * 思路： * 一、求每部分后再加和 * 二、后一个跟前一个有关系，直接求和 
 * */
 public class Code001_Factorial {  
  
  
    /**  
     * 思路一：求每部分后再加和     
     * */    
    public static int factorialSum(int N) {  
        int sum = 0;  
        for (int i = 1; i <= N; i++) {  
            sum += factorial(i);  
        }  
        return sum;  
    }  
  
    // 求每部分的值  
    private static int factorial(int N) {  
        int result = 1;  
        for (int i = 1; i <= N; i++) {  
            result *= i;  
        }  
        return result;  
    }  
  
    /**  
     * 思路二：后一个跟前一个有关系，直接求和     
     * */
	public static int factorialSumNew(int N) {  
        int sum = 0;  
        int fac = 1;  
        for (int i = 1; i <= N; i++) {  
            fac *= i;  
            sum += fac;  
        }  
        return sum;  
    }  
  
}
```



### 打印int类型的二进制数表示

```
打印一个int型数的二进制表示， 比如5的二进制表示为00000000000000000000000000000101 
```

```java
package com.aitx.study.base;  
  
/**
 * 将一个数的二进制表示打印出来
 * <p>
 * 思路：
 * int型数占用4字节32位，打印二进制表示相当于 通过位运算取出各个位置的01打印出来
 * <p>
 * 其他相关：
 * 二进制转十进制，系数 * 2^n
 * 十进数转二进制，小数点前：除以2取余 从下向上写，小数点后：乘以2取整数，从上向下写
 * <p>
 * 一个数的相反数 就是 此数取反加一
 */
 public class PrintInteger2RadixNum {  
  
  
    public static void main(String[] args) {  
        int num = 5;  
        print(5);  
        System.out.println();  
        System.out.println("=======");  
        test();  
    }  
  
    /**  
     * 打印一个int型数的二进制表示   
     * @param num int类型的数  
     */    
     private static void print(int num) {  
        // int的二进制位数为4个字节，共32位数据，由于二进制的索引是从0开始，所以为0-31  
        // 那么我们想要打印出某位的数，只需要将数字与某位上的1进行与运算即可        
        int max = 31;  
        for (int i = max; i >= 0; i--) {  
            // 这里如果某位上是0，则位与后的数等于0，如果某位是1，则位与后的数肯定不等于0  
            char c = (num & (1 << i)) == 0 ? '0' : '1';  
            System.out.print(c);  
        }  
    }  
  
    /**  
     * 延伸：原码，反码，补码     
     * 1)最高位0表示正数，1表示负数；     
     * 2)由于Java中的int为有符号整型，且0归为非负范围，所以int类型的数值范围为-2^31 - 2^31-1    
     * 3)
     * 正数最高位为0，其他0-30位表示数值，原码     
     * 负数最高位为1，其他0-30位需要取反+1（可以进位到31位），补码     
     * 0的最高位为0，其他0-30位都为0     
     * 4)一个数的相反数 等于其取反+1，即：-N == (~N + 1)     
     * 由于正数范围比负数范围小1，所以最小负数的相反数还是其自身
     * 5)常用的位运算：
     * &位与
     * |位或
     * ^异或
     * ～取反
     * 
     * */    
     private static void test() {  
        // 先看下最大正数的二进制表示  
		// 最大正数，31位符号位为0，0-31位是1        
		System.out.println(Integer.MAX_VALUE); // 2147483647  
        print(Integer.MAX_VALUE); // 01111111111111111111111111111111  
  
        System.out.println();  
        System.out.println("=======");  
  
        // 再看下最小负数的二进制表示  
        // 最小负数，31位符号为1，0-31位是0        
        // ? 为什么有反直觉，我们认为最小的负数，除符号位之外其他位不应该是数值越大，就是越小吗？   
        // 其实，这里就是补码的原因：取反加一        
        // 10000000000000000000000000000000        
        // 最高位是1，代表是负数        
        // 其他位取反+1，是10000000000000000000000000000000，也就是2^31        
        // 所以是-2^31        
        System.out.println(Integer.MIN_VALUE);// -2147483648  
        print(Integer.MIN_VALUE);// 10000000000000000000000000000000  
  
        System.out.println();  
        System.out.println("=======");  
  
        // 最后看下怎么求一个数的相反数  
        // 最简单的方式加个负号        
        int N = 5; 
        // 00000000000000000000000000000101  
        print(N);   
        System.out.println();  
        int reverseN = -N;  
        // 11111111111111111111111111111011  
        print(reverseN);  
        System.out.println();  
        // 11111111111111111111111111111011  
        int reverseN2 = (~N + 1);  
        print(reverseN2);  
        System.out.println();  
    }  
  
}
```

	注：>>> 不带符号右移，>> 带符号右移；
	无符号右移：正负数在最高位均补0
	有符号右移：正数的最高位补0，负数的最高位补1

### 时间复杂度

```
常数时间操作：固定时间操作，与数据量N无关的操作。（常数：Constant）

常见的常数时间操作：

1）算术运算

2）位移运算

3）比较运算

4）赋值运算

5）寻址运算

6）自增自减运算
```

```
Big O(n)：时间复杂度是与数据量N相关的估算函数，N->无穷大时，忽略常数项与低阶项。（big O指的是omega）
```



### 时间复杂度：冒泡排序




```java
import java.util.Arrays;

public class TimeComplexity4BubbleSort {

    public static void main(String[] args) {
        int[] arr = {43, 12, 3, 78, 90, 45};
        bubbleSort(arr);
        System.out.println("arr = " + Arrays.toString(arr));
    }


    /**
     * 那么冒泡排序的时间复杂度为多少，我们可以看下内层的循环计算出总的次数
     * 1~end=>1~N-1=>N-1
     * 1~end=>1~N-2=>N-2
     * ...
     * 1~end=>1~1=>1
     * 1~end=>1~0=>0
     * 构成等差数列 1,2,...,N-1
     * 根据等差数列求和公式可得
     * S=N(N-1)/2 ==> O(n)=O(n^2)
     *
     * 那再看下稳定度：
     * bubbleSort,用>号比较时，是稳定的
     */
    public static void bubbleSort(int[] arr) {
        // 边界条件
        if (arr == null || arr.length < 2) {
            return;
        }
        // bubbleSort
        // 0~N-1 两两比较 大值向后移
        // 0~N-2
        // 0~i
        // 0~0
        // 左端点不变，右端点递减
        int N = arr.length;
        for (int end = N - 1; end >= 0; end--) {
            // 两两比较交换
            // 0,1;1,2;2,3;...;end-1,end
            // 可以看到右端点从1递增到end
            for (int right = 1; right <= end; right++) {
                // left > right => swap
                if (arr[right - 1] > arr[right]) {
                    swap(arr, right - 1, right);
                }
            }
        }
    }

    private static void swap(int[] arr, int left, int right) {
        int temp = arr[left];
        arr[left] = arr[right];
        arr[right] = temp;
    }
}
```



### 时间复杂度：选择排序



```java
import java.util.Arrays;

public class TimeComplexity4SelectSort {

    public static void main(String[] args) {
        int[] arr = {43, 12, 3, 78, 90, 45};
        selectSort(arr);
        System.out.println("arr = " + Arrays.toString(arr));
    }

    /**
     * 看下选择排序的时间复杂度：
     * 看下内层的循环
     * 1~N-1 => N-1
     * 2~N-1 => N-2
     * N-1~N-1 => 1
     * 构成等差数列：所以
     * O(n) = O(n^2)
     * <p>
     * 再看下稳定度
     * 有如下的数组：33,45,33,12
     * 则33,12换换后，原两个33相对位置改变，不稳定
     */
    public static void selectSort(int[] arr) {
        //  边界条件
        if (arr == null || arr.length < 2) {
            return;
        }
        // selectSort
        // 0~N-1 找到最小值 与 0 位置交换
        // 1~N-1
        // 2~N-1
        // i~N-1
        // N-1~N-1
        // 可以看到左端点依次递增，右端点不变
        int N = arr.length;
        for (int i = 0; i < N; i++) {
            // i 默认为最小值的索引
            int minNumIndex = i;
            // 如果 后面的数 有比 最小值索引代表的数 小，则记录
            for (int j = i + 1; j < N; j++) {
                if (arr[j] < arr[minNumIndex]) {
                    minNumIndex = j;
                }
            }
            // 交换i,minNumIndex
            swap(arr, i, minNumIndex);
        }
    }

    private static void swap(int[] arr, int left, int right) {
        int temp = arr[left];
        arr[left] = arr[right];
        arr[right] = temp;
    }
}

```



### 时间复杂度：插入排序



```java
import java.util.Arrays;

public class TimeComplexity4InsertSort {

    public static void main(String[] args) {
        int[] arr = {43, 12, 3, 78, 90, 45};
        insertSort(arr);
        System.out.println("arr = " + Arrays.toString(arr));
    }

    /**
     * 插入排序insertSort
     * 类似于打扑克牌
     * <p>
     * 首先看下时间复杂度
     * 我们想像一个最差的情况
     * 有个逆序的数组
     * 5,4,3,2,1
     * 现在要将此数组从小到大排序
     * 0~1=>1
     * 0~2=>2
     * 0~i=>i
     * 0~N-1=>N-1
     * 构成等差数列，时间复杂度O(n) = O(n power 2)
     * <p>
     * 再看下稳定度，当比较符号为>号时
     * 是稳定的
     */
    public static void insertSort(int[] arr) {
        // 边界条件
        if (arr == null || arr.length < 2) {
            return;
        }
        // insertSort
        // 0~0 有序
        // 0~1
        // 0~2
        // 0~i
        // 0~N-1
        // 左端点不变，右端点依次递增
        int N = arr.length;
        for (int i = 1; i < N; i++) {
            // i位置作为新加入的数，要与前面有序的数进行比较
            int newNumIndex = i;
            while ((newNumIndex - 1) >= 0 && arr[newNumIndex - 1] > arr[newNumIndex]) {
                swap(arr, newNumIndex - 1, newNumIndex);
                newNumIndex--;
            }
        }
    }

    private static void swap(int[] arr, int left, int right) {
        // 用eor(exclusive or)进行交换两数时，左右指针不能相同
        // 如果相同时，则两数相等，异或的值为0
        // 异或 == 无进位的位运算相加
        if (left == right) {
            return;
        }
        arr[left] = arr[left] ^ arr[right];
        arr[right] = arr[left] ^ arr[right];
        arr[left] = arr[left] ^ arr[right];
    }
}


```



### 额外空间复杂度



```
额外空间复杂度：关键是额外两字，就是入参、出参所需的空间不算额外，在算法过程中需要支持你算法运行的其他空间是额外空间复杂度。

如果只是有限几个变量，额外空间复杂度为O(1)
```



### 时间复杂度中的常数项



```
这里所说的常数项，准确说是时间复杂度函数前的常数系数。

如果我们的时间复杂度一样，就到比拼常数项阶段，一般都是实测来确定谁的常数项更好，更省时。
```



### 算法的最优解



```
时间复杂度>额外空间复杂度>常数项
```



### 随机数



#### 验证Math.random()生成随机数是概率相等

```java
package com.aitx.study.base.code002;

import java.util.Arrays;

/**
 * 验证Math.random()生成随机数是概率相等
 * <p>
 * 一. 当x <=1,Math.random < x的概率就是x
 * 二. Math.random() * M < N 的概率就是(double) N / M
 * 三. (int)( Math.random() * (N+1) ) 后生成的各数[0,N] 概率相等
 */
public class Code002_VerifyRandom {

    public static void main(String[] args) {
        verify3();
    }

    // ---------------------------------------------

    // 一. 当x <=1,Math.random < x的概率就是x
    public static void verify1() {
        int testTimes = 100000;
        double x = 0.75;
        int count = 0;
        for (int i = 0; i < testTimes; i++) {
            if (Math.random() < x) {
                count++;
            }
        }
        System.out.println(x);
        System.out.println(((double) count) / testTimes);
    }

    // ---------------------------------------------
    // 二. Math.random() * M < N 的概率就是(double) N / M
    public static void verify2() {
        int M = 10;
        int N = 5;

        int testTimes = 100000;
        int count = 0;
        for (int i = 0; i < testTimes; i++) {
            if (Math.random() * M < N) {
                count++;
            }
        }
        System.out.println(((double) N) / M);
        System.out.println((double) count / testTimes);
    }

    // ---------------------------------------------
    // 三. (int)( Math.random() * (N) ) 后生成的各数[0,N-1] 概率相等
    public static void verify3() {
        int testTimes = 100000;
        int N = 10;

        int[] result = new int[N];
        for (int i = 0; i < testTimes; i++) {
            int ans = (int) (Math.random() * N);
            result[ans]++;
        }

        System.out.println(Arrays.toString(result));

    }


}

```



#### 利用Math.random()函数把得到[0,x)范围上的数的概率从x调整成x^2



```java
package com.aitx.study.base.code002;

/**
 * 如果利用Math.random()函数，
 * 如果x属于[0,1]
 * 把得到[0,x)范围上的数的概率从x调整成x^2
 * <p>
 * 思路：
 * 这里的x就是Math.random()的概率，现在要求x^2，也就是x * x，概据乘法原理，
 * 也就是两个Math.random()都要满足 < x，也就是 两个随机数最大值要满足 < x
 */
public class Code002_Random2Power2 {

    public static double x2Power2() {
        return Math.max(Math.random(), Math.random());
    }
}

```



#### 从1~5随机到1~7随机



```java
package com.aitx.study.base.code002;


/**
 * 从1~5随机到1~7随机
 * 存在函数f1()生成随机的等概率[1,5]，现在要创建函数f()生成随机的等概率[1,7]
 * <p>
 * 思路：先创建01生成器，再通过位移的方式生成随机数
 */
public class Code002_Random15ToRandom17 {


    // jar包中的函数f1()，生成随机的[1,5]
    public static int f1() {
        return ((int) (Math.random() * 5)) + 1;
    }

    // 第一步：01生成器
    private static int zeroOneGen() {
        int ans;

        do {
            ans = f1();
        } while (ans == 3);

        // 走到这，代表ans != 3;

        return ans < 3 ? 0 : 1;
    }

    // 01生成器 随机到 [1,7]
    public static int f() {
        int ans;
        do {
            // 01 -> [0,6]
            ans = (zeroOneGen() << 2) + (zeroOneGen() << 1) + zeroOneGen();
        } while (ans == 7);

        return ans + 1;
    }


}

```



#### 01不等概率随机到01等概率随机



```java
package com.aitx.study.base.code002;

/**
 * 01不等概率随机到01等概率随机
 * <p>
 * 思路：假设0的概率为p,则1的概率为1-p，根据乘法原理，
 * 00概率为pp
 * 01概率p(1-p)
 * 10概率p(1-p)
 * 11概率(1-p)(1-p)
 * <p>
 * 所以只要计算2次，要求第二次不等第一次，则概率就会变成相等
 */
public class Code002_ZeroOneProbabilityNot2Equal {

    // jar包存在不等概率的01生成器
    public static int zeroOneGenNot() {
        return Math.random() < 0.75 ? 0 : 1;
    }

    public static int zeroOneGen() {
        int ans;
        
        do {
            ans = zeroOneGenNot();
        } while (ans == zeroOneGenNot());

        // 走到这，代表 ans != 第二次生成的值
        return ans;
    }
}

```



#### 盲盒随机函数 到 指定的等概率随机函数



```java
package com.aitx.study.base.code002;

/**
 * 盲盒随机函数 到 指定的等概率随机函数
 * <p>
 * 给你一个RandomBox，能等概率随机出[min,max]间的值，这是唯一能借助的随机机制，
 * 现在要求等概率返回from~to范围上任何一个数
 * 要求from<=to
 */
public class Code002_RandomBox2Random {


    public static class RandomBox {

        int min;

        int max;

        public RandomBox(int min, int max) {
            this.min = min;
            this.max = max;
        }

        public int min() {
            return this.min;
        }

        public int max() {
            return this.max;
        }

        // 盲盒随机方法
        public int random() {
            // [0,max-min] + min ---> [min,max]
            return ((int) (Math.random() * (max - min + 1))) + min;
        }

    }

    // 最重要的 01生成器
    private static int zeroOneGen(RandomBox randomBox) {

        int min = randomBox.min();
        int max = randomBox.max();

        // 查看盲盒能生成多少个数
        int size = max - min + 1;
        // 是否为奇数
        boolean odd = size % 2 == 1;

        // 如果size是7，中位数就是3，左右索引理解为012，456，相当于要去掉3
        // 如果是8，中位数是4，0123 4567，相当于没有去除任何数
        int mid = size / 2;

        int ans;
        do {
            // [min,max] ---> [0,max-min]
            ans = randomBox.random() - min;
        } while (odd && ans == mid);

        return ans < mid ? 0 : 1;

    }

    /**
     * 给你一个RandomBox，能等概率随机出[min,max]间的值，这是唯一能借助的随机机制，
     * 现在要求等概率返回from~to范围上任何一个数
     * 要求from<=to
     */
    public static int random(RandomBox randomBox, int from, int to) {
        if (from == to) {
            return from;
        }
        // 走到这，代表from < to

        // 看看要表示多少个数
        int size = to - from + 1;

        // 要表示size个数至少要多少位的01
        int num = 1;
        while ((1 << num) < size) {
            num++;
        }
        // 跳出循环时，( 1 << num ) >= size
        int ans = 0;

        do {
            for (int i = 0; i < num; i++) {
                // [0,2^num]
                ans |= zeroOneGen(randomBox) << i;
            }
            // 超出的数字 重新生成
        } while (ans > (to - from));

        // 走到这，代表ans 属于 [0,to-from]
        
        return ans + from;
    }


}

```



### 对数器



```java
package com.aitx.study.base;

public class NumComparer {

    /**
     * 生成随机数组
     *
     * @param maxLength 数组最大长度，[0,maxLength]
     * @param maxValue  数组元素最大值，[-maxValue,maxValue]
     * @return 随机数组
     */
    private static int[] generateRandomArr(int maxLength, int maxValue) {
      	// [0,maxLength]
        int length = (int) (Math.random() * (maxLength + 1));
        int[] result = new int[length];
        for (int i = 0; i < length; i++) {
            result[i] = generateRandomValue(maxValue);
        }
        return result;
    }

    /**
     * 生成随机整数
     *
     * @param maxValue 最大值 [-maxValue,maxValue]
     * @return 生成随机的整数
     */
    private static int generateRandomValue(int maxValue) {
        // [0,maxValue] - [0,maxValue] ==> [-maxValue,maxValue]
        return ((int) (Math.random() * (maxValue + 1))) - ((int) (Math.random() * (maxValue + 1)));
    }
}

```



### 数组区间和，前缀数组



```java
package com.aitx.study.base.code002;

/**
 * 前缀数组
 * 假设有一个数组arr，用户总是频繁的查询arr中某一段的累加和
 * 你如何组织数据，能让这种查询变得便利和快捷？
 * <p>
 * 思路：
 * 一、相当于求[L,R]区间的数据之和，如果存在矩阵，则行表示L，列表示R，则可以求出
 * 二、相当于求[L,R]区间的数据之和，如果存在数组prefixArray[],i位置数代表是[0,i]的数据之和，
 * 则转成求prefix[R] - prefix[L-1]
 * 三、遍历区间[L,R]求和
 * 
 * 显然思路二更可取
 */
public class Code002_PrefixArray {

    // 求数组[L,R]区间和
    public static int intervalSum(int[] arr, int L, int R) {

        // 思路：构建前缀数组
        int[] prefixArray = buildPrefixArray(arr);

        if (L < 1) {
            return prefixArray[R];
        } else {
            return prefixArray[R] - prefixArray[L - 1];
        }
    }

    private static int[] buildPrefixArray(int[] arr) {
        if (arr == null || arr.length == 0) {
            return new int[]{};
        }
        int N = arr.length;
        int[] result = new int[N];
        int sum = 0;
        for (int i = 0; i < N; i++) {
            sum += arr[i];
            result[i] = sum;
        }
        return result;
    }


}

```



### 通过二分法判断数是否存在于数组中



```java
import java.util.Arrays;

/**
 * 有序数组中找到num
 * <p>
 * 思考：
 * 一、遍历
 * 二、有序数组中，必然存在 小于此数的，大于此数的，考虑二分法
 */
public class BinarySearchExist {

    public static void main(String[] args) {
        int loopTimes = 100000;
        for (int i = 0; i < loopTimes; i++) {
            int[] randomArray = generateRandomArray(10, 100);
            // 注意，必须是有序数组
            Arrays.sort(randomArray);
            int target = ((int) (Math.random() * (100 + 1))) - ((int) (Math.random() * 100));
            boolean b1 = sequenceSearch(randomArray, target);
            boolean b2 = binarySearchExist(randomArray, target);
            if (b1 != b2) {
                System.out.println("randomArray=" + Arrays.toString(randomArray) + ", target=" + target);
            }
        }
    }

    /**
     * 通过二分查找来查看目标值是否存在数组中
     */
    public static boolean binarySearchExist(int[] arr, int target) {
        // 边界条件
        if (arr == null || arr.length == 0) {
            return false;
        }
        int L = 0;
        int R = arr.length - 1; 
      	// 注意，这里R是有效值，所以是闭区间
        // 所以我们这里可以用<=,当我们用<时，代表数组至少有2个数
        // 如下的写法就是代表至少有2个数，用<号
        while (L < R) {
            int mid = L + ((R - L) >> 1);
            if (arr[mid] == target) {
                return true;
            } else if (target < arr[mid]) {
                R = mid - 1;
            } else {
                L = mid + 1;
            }
        }
        // 因为上面用啊L<R，只覆盖了至少2个元素的数组
        // 这里要覆盖下只有1个数的场景
        return arr[L] == target;
    }

    // 对数器，产生随机数组
    public static int[] generateRandomArray(int maxLength, int maxValue) {
        int length = (int) (Math.random() * (maxLength + 1));
        int[] result = new int[length];
        for (int i = 0; i < length; i++) {
            int value = ((int) (Math.random() * (maxValue + 1))) - ((int) (Math.random() * maxValue));
            result[i] = value;
        }
        return result;
    }

    // 线性搜索
    public static boolean sequenceSearch(int[] arr, int target) {
        // 边界条件
        if (arr == null || arr.length == 0) {
            return false;
        }
        for (int i = 0; i < arr.length; i++) {
            if (target == arr[i]) {
                return true;
            }
        }
        return false;
    }


}

```



### 在数组中找到>=target最左边的值的索引



```java
package com.aitx.study.base.code003;

import java.util.Arrays;

/**
 * 有序数组中找到>=num最左的位置
 * <p>
 * 思路：
 * 一、遍历
 * 二、看到数组分区，想到二分法
 */
public class Code003_MostNearLeft {

    // 二分法
    public static int mostNearLeftByBinary(int[] arr, int num) {
        if (arr == null || arr.length == 0) {
            return -1;
        }
        int L = 0;
        int R = arr.length - 1;

        int result = -1;

        while (L <= R) {

            int mid = L + ((R - L) >> 1);

            if (arr[mid] >= num) {
                result = mid;
                R = mid - 1;
            } else {
                L = mid + 1;
            }
        }

        // 跳出循环时，L > R
        return result;
    }

    // ---------------------------------------------------------

    // 遍历
    public static int mostNearLeftBySequence(int[] arr, int num) {
        if (arr == null || arr.length == 0) {
            return -1;
        }
        int N = arr.length;
        for (int i = 0; i < N; i++) {
            if (arr[i] >= num) {
                return i;
            }
        }
        // 跳出循环时，i=N
        return -1;
    }

    // ---------------------------------------------------------


    // 生成随机数组
    public static int[] getRandomArray(int maxLength, int maxValue) {
        int length = (int) (Math.random() * (maxLength + 1));
        int[] result = new int[length];
        for (int i = 0; i < length; i++) {
            // [0-maxValue] - [0-maxValue] == [-maxValue,maxValue]
            result[i] = getRandomValue(maxValue);
        }
        return result;
    }

    // 随机数
    public static int getRandomValue(int maxValue) {
        return ((int) (Math.random() * (maxValue + 1))) - ((int) (Math.random() * (maxValue + 1)));
    }

    public static void main(String[] args) {
        int testTimes = 1000;
        int maxLength = 10;
        int maxValue = 100;

        for (int i = 0; i < testTimes; i++) {
            int[] randomArray = getRandomArray(maxLength, maxValue);
            // 注意一定要有序
            Arrays.sort(randomArray);
            int randomValue = getRandomValue(maxValue);
            if (mostNearLeftBySequence(randomArray, randomValue) != mostNearLeftByBinary(randomArray, randomValue)) {
                System.out.println("有误");
                break;
            }
        }
    }
}

```



### 在数组上找满足<=value的最右边值的索引



```java
package com.aitx.study.base.code003;

import java.util.Arrays;

/**
 * 有序数组中找到<=num最右的位置
 * <p>
 * 思路：
 * 一、倒着遍历
 * 二、看到分区，想到二分法
 */
public class Code003_MostNearRight {

    // 二分法
    public static int mostNearRightByBinary(int[] arr, int num) {
        if (arr == null || arr.length == 0) {
            return -1;
        }
        int L = 0;
        int R = arr.length - 1;

        int result = -1;

        while (L <= R) {

            int mid = L + ((R - L) >> 1);

            if (arr[mid] <= num) {
                result = mid;
                L = mid + 1;
            } else {
                R = mid - 1;
            }
        }

        // 跳出循环时，L > R
        return result;
    }

    // ---------------------------------------------------------

    // 遍历
    public static int mostNearRightBySequence(int[] arr, int num) {
        if (arr == null || arr.length == 0) {
            return -1;
        }
        int N = arr.length;
        for (int i = (N - 1); i >= 0; i--) {
            if (arr[i] <= num) {
                return i;
            }
        }
        // 跳出循环时，i=-1
        return -1;
    }

    // ---------------------------------------------------------


    // 生成随机数组
    public static int[] getRandomArray(int maxLength, int maxValue) {
        int length = (int) (Math.random() * (maxLength + 1));
        int[] result = new int[length];
        for (int i = 0; i < length; i++) {
            // [0-maxValue] - [0-maxValue] == [-maxValue,maxValue]
            result[i] = getRandomValue(maxValue);
        }
        return result;
    }

    // 随机数
    public static int getRandomValue(int maxValue) {
        return ((int) (Math.random() * (maxValue + 1))) - ((int) (Math.random() * (maxValue + 1)));
    }

    public static void main(String[] args) {
        int testTimes = 1000;
        int maxLength = 10;
        int maxValue = 100;

        for (int i = 0; i < testTimes; i++) {
            int[] randomArray = getRandomArray(maxLength, maxValue);
            // 注意一定要有序
            Arrays.sort(randomArray);
            int randomValue = getRandomValue(maxValue);
            if (mostNearRightBySequence(randomArray, randomValue) != mostNearRightByBinary(randomArray, randomValue)) {
                System.out.println("有误");
                break;
            }
        }
    }


}


```



### 求数组的局部最小值



```java
package com.aitx.study.base.code003;

/**
 * 一个数组，左右元素各不相等，求此数组的局部极小值的索引位置
 * <p>
 * 思考：
 * 一、左右不等，有几种情况：
 * 1）左大，右大，存在局部最小值
 * 2）左大，右小，则右端点处可能有最小值
 * 3）左小，右大，则左端点处可能有最小值
 * 4）左小，右小，则左右端点处可能有最小值
 * <p>
 * 这里也有左右分区，考虑二分法
 */
public class Code003_LocalMin {


    public static int localMin(int[] arr) {
        if (arr == null || arr.length == 0) {
            return -1;
        }
        int N = arr.length;
        if (N == 1) {
            return 0;
        }
        // 走到这，代表数组长度至少为2
        if (arr[0] < arr[1]) {
            return 0;
        }
        // 走到这，代表arr[0] > arr[1]
        if (arr[N - 1] < arr[N - 2]) {
            return N - 1;
        }
        // 走到这，代表arr[N-1] > arr[N-2]，且代表至少3个数

        // 结合看，函数图像给人是先减再增，则存在局部最小值

        int L = 0;
        int R = N - 1;

        // 涉及到三个数，保证有3个数存在
        while (L < R - 1) {
            int mid = L + ((R - L) >> 1);

            if (arr[mid] < arr[mid - 1] && arr[mid] < arr[mid + 1]) {
                return mid;
            } else {
                if (arr[mid] > arr[mid - 1]) {
                    R = mid - 1;
                } else {
                    L = mid + 1;
                }
            }
        }
        // 跳出循环时，L >= R-1
        // 1) L = R-1 则只有2个数，直接判断大小
        // 2）L > R-1 则 R-1，R，L或R-1，R(L)
        return arr[L] < arr[R] ? L : R;
    }

    // ------------------------------------------------

    // 生成左右不等的数组
    public static int[] getLRNotEqualRandomArray(int maxLength, int maxValue) {
        int length = (int) (Math.random() * (maxLength + 1));
        int[] result = new int[length];
        if (length == 0) {
            return result;
        }
        result[0] = ((int) (Math.random() * (maxValue + 1)));
        for (int i = 1; i < length; i++) {
            do {
                result[i] = ((int) (Math.random() * (maxValue + 1)));
            } while (result[i] == result[i - 1]);
        }
        return result;
    }

    private static boolean checkCorrect(int[] arr, int index) {
        if (arr == null || arr.length == 0) {
            return -1 == index;
        }
        int N = arr.length;
        if (N == 1) {
            return 0 == index;
        }
        int leftIndex = index - 1;
        int rightIndex = index + 1;
        boolean leftBigger = leftIndex < 0 || (arr[leftIndex] > arr[index]);
        boolean rightBigger = rightIndex >= N || (arr[rightIndex] > arr[index]);
        return leftBigger && rightBigger;
    }

    public static void main(String[] args) {
        int testTimes = 100000;
        int maxLength = 10;
        int maxValue = 100;
        for (int i = 0; i < testTimes; i++) {
            int[] lRNotEqualRandomArray = getLRNotEqualRandomArray(maxLength, maxValue);
            int localMinIndex = localMin(lRNotEqualRandomArray);
            if (!checkCorrect(lRNotEqualRandomArray, localMinIndex)) {
                System.out.println("有误");
                break;
            }
        }
    }

}


```





### 异或运算



```
异或运算：相同为0，不同为1

同或运算：相同为1，不同为0

异或运算 就相当于 无进位的相加

0 ^ N = N

N ^ N = 0

异或运算 满足交换律、结合律
```



### 不用额外空间实现两数交换



```java
public class SwapTwoNum {

    public static void main(String[] args) {

        int a = 3;
        int b = 4;

        a = a ^ b;
        b = a ^ b; // 原a ^ 原b ^ 原b == 原a ^ 0 = 原a
        a = a ^ b; // 原a ^ 原b ^ 原a == 0 ^ 原b = 原b

        // 用异或实现 交换两数
        System.out.println("a = " + a);
        System.out.println("b = " + b);


    }

    private static void swap(int[] arr, int left, int right) {
        // 如果left == right
        // 则
        // arr[left] = arr[left] ^ arr[left] = 0
        // arr[right] = 0 ^ 0 = 0
        // arr[left] = 0 ^ 0 = 0
        // 会将两数直接变成0，所以如果索引相同时，不能用异或eor来运算
      	// eor == exlusive or
      	// 也就是用异或两个数在内存中不能是同一内存空间
        //
        // 再考虑如果left != right,但arr[left] == arr[right]
        // arr[left] = 0
        // arr[right] = 0 ^ o-arr[right] = o-arr[right]
        // arr[left] = 0 ^ arr[right] = o-arr[right] = o-arr[left]
        // 所以两数相等，但索引不同，可以用异或进行交换
        if (left == right) {
            return;
        }
        arr[left] = arr[left] ^ arr[right];
        arr[right] = arr[left] ^ arr[right];
        arr[left] = arr[left] ^ arr[right];
    }
}
```



### 数组中只有一个数是奇数次个，求这个数



```java
public class OnlyOneIsOddNumArray {

    public static void main(String[] args) {
        int[] arr = {3, 3, 3, 4, 4, 5, 5, 5, 5};
        int num = onlyOneIsOddNum(arr);
        System.out.println("num = " + num); // num = 3
    }

  	// 解法二：用异或解决
    // 数组中只有一个数是奇数次个，求这个数
    private static int onlyOneIsOddNum(int[] arr) {
        // N ^ N = 0
        // 0 ^ N = N
        int eor = 0;
        for (int i = 0; i < arr.length; i++) {
            eor ^= arr[i];
        }
        return eor;
    }
  
  	// 解法一：用HashMap装词频，暴力解法
}
```



### 将int类型的数提取出最右侧的1(位运算视角)



```java
package com.aitx.study.base;

/**
 * 将int类型的数提取出最右侧的1,比如13，二进制数为1101，最右侧的1就是0001（十进制为1）
 */
public class getIntegerRightOne {

    public static void main(String[] args) {
        int testTimes = 10000;
        int maxValue = Integer.MAX_VALUE;
        for (int i = 0; i < testTimes; i++) {
            int num = getRandomValue(maxValue);
            if (getIntegerRightOne1(num) != getIntegerRightOne2(num)) {
                System.out.println("error" + num);
            }
        }
    }

    /**
     * 解法二：位与处理，
     * N & (-N) == N & (~N + 1)
     * 这里有个知识点就是 相反数 == 原数取反+1
     * 比如1101 0000 ^ (0010 1111 再加1,也就是0011 0000 )
     * 1101 0000 & 0011 0000
     * 也就求出最右侧的1了
     */
    private static int getIntegerRightOne2(int num) {
        return num & (-num);
    }


    /**
     * 解法一：找出int的二进制展示，并求出最右侧1的索引
     */
    private static int getIntegerRightOne1(int num) {
        String integerBinaryBitShow = getIntegerBinaryBitShow(num);
        String reverse = new StringBuilder(integerBinaryBitShow).reverse().toString();
        int index = reverse.indexOf('1');
        if (index == 31) {
            return Integer.MIN_VALUE;
        } else if (index == -1) {
            return 0;
        } else {
            return (1 << (index));
        }
    }


    private static String getIntegerBinaryBitShow(int num) {
        StringBuilder sb = new StringBuilder();
        // 索引为：0-31,依次递减
        for (int i = 31; i >= 0; i--) {
            char c = (num & (1 << i)) == 0 ? '0' : '1';
            sb.append(c);
        }
        return sb.toString();
    }


    // test
    private static int getRandomValue(int maxValue) {
        // [0,maxValue] - [0,maxValue] == [-maxValue,maxValue]
        return ((int) (Math.random() * (maxValue + 1))) - (int) (Math.random() * (maxValue + 1));
    }
}

```



### 数组中只有两种数出现奇数次，求出这两种数



```java
public class OnlyTwoOddNumArray {

    public static void main(String[] args) {
        int[] arr = {3, 4, 5, 5, 6, 6, 6, 6};
        onlyTwoOddNum(arr);
    }

  	// 解法二：异或
    // 数组中只有两种数出现奇数次，求出这两种数
    public static void onlyTwoOddNum(int[] arr) {
        // 进行异或运算消掉偶次个的数
        int eor = 0;
        for (int i = 0; i < arr.length; i++) {
            eor ^= arr[i];
        }
        // 循环结束，eor = a ^ b ( a != b)
        // 显然 a != b 肯定有位上是不同的，我们将eor最右侧的1提取出来
        int rightOne = eor & (-eor);
      	// int rightOne = eor & (~eor + 1);
        // 那么此时原数组的数可以分为二类：在此位上是1的、在此位上是0的
        int a = 0;
        for (int i = 0; i < arr.length; i++) {
            // 确定此位是1的情况,那第此区中必然只有一个是奇数个
            if ((arr[i] & rightOne) != 0) {
                a ^= arr[i];
            }
        }
        // 输出a
        System.out.println("a = " + a);
        // 输出b
        int b = eor ^ a;
        System.out.println("b = " + b);
    }
  
  	// 解法一：HashMap
}
```





### 求一个数二进制位上有几个1



```java
public class Bit1Count {

    public static void main(String[] args) {
        int count = bit1counts(14);
        System.out.println("count = " + count);
    }
		
  	// 解法二：位与运算，求最右边1，再异或消除，直到N==0
    // 求一个数有几个1，就是看一个数二进制位上有几个1
    public static int bit1counts(int N) {
        int count = 0;

        //   011011010000
        //   000000010000     1

        //   011011000000
        //

        // 看一个数有几个1，就是不断的将位的1消去，最后N==0
        while (N != 0) {
            // 求一个数最右侧的1，就是此数与相反数 位与，也等同于 此数与（取反 +1的数）位与
            int rightOne = N & ((~N) + 1);
            // 计算有几个1
            count++;
            // 异或运算，是无进位相加
            // 这里相当于，将原来的数最右的1消掉
            N ^= rightOne;
            // N -= rightOne
        }

        return count;
    }
  	// 解法一：求出一个数的二进制表示，最后统计
}
```



### 将一个整型数转成二进制数组表示,数组0-31索引依次表示int型数的0-31位的情况



```java
package com.aitx.study.base;

import java.util.Arrays;

/**
 * 将一个整型数转成二进制数组表示,数组0-31索引依次表示int型数的0-31位的情况
 */
public class IntegerBinaryArrayShow {

    public static void main(String[] args) {
        int testTimes = 100000;
        int maxValue = 1000;
        for (int i = 0; i < testTimes; i++) {
            int num = generateRandomValue(maxValue);
            if (!Arrays.equals(getIntegerBinaryArrayShow1(num), getIntegerBinaryArrayShow2(num))) {
                System.out.println(num);
            }
        }
    }


    /**
     * 解法二：1不动，num左移
     */
    private static int[] getIntegerBinaryArrayShow1(int num) {
        int[] result = new int[32];
        for (int i = 0; i < 32; i++) {
            // 相当于只取num的0索引处的值
            int res = ((num >> i) & 1);
            result[i] = res;
        }
        return result;
    }

    /**
     * 解法一：1动且向左移，num不动
     */
    private static int[] getIntegerBinaryArrayShow2(int num) {
        int[] result = new int[32];
        for (int i = 31; i >= 0; i--) {
            // 注意，这里1是要左移
            result[i] = (num & (1 << i)) == 0 ? 0 : 1;
        }
        return result;
    }


    // test
    private static int generateRandomValue(int maxValue) {
        // [0,maxValue] - [0,maxValue] == [-maxValue,maxValue]
        return ((int) (Math.random() * (maxValue + 1))) - ((int) (Math.random() * (maxValue + 1)));
    }
}

```



### 一个数组中，存在一种数会出现K次，其他种类数出现M次，M>1,K<M,求出现K次的数为多少



```java
package com.aitx.study.base;


import java.util.*;
import java.util.stream.Collectors;

/**
 * 一个数组中，存在一种数会出现K次，其他种类数出现M次，M>1,K<M,求出现K次的数为多少、
 * 词频的暴力解法肯定用HashMap能解决
 * 这里相当于数组中存在其他数为偶数次的数，1个奇数次的数的拓展，所以这道题也可以用位运算来解决
 */
public class KM {


    /**
     * 解法一：通过32位数组统计某位上的1个数
     */
    private static int getKTimesNum(int[] arr, int K, int M) {
        int[] calc = new int[32];
        for (int num : arr) {
            // 相当于统计所有数在此位上1的个数
            for (int i = 0; i < 32; i++) {
                calc[i] += (num >> i) & 1;
            }
        }
        int ans = 0;
        for (int i = 0; i < 32; i++) {
            // 如果对M取模不等于0，代表此位上会出现K次1,也就是要求的数在此位为1
            if (calc[i] % M != 0) {
                ans |= 1 << i;
            }
        }
        return ans;
    }

    /**
     * 解法二：通过HashMap统计
     */
    private static int getKTimesNumByHashMap(int[] arr, int K, int M) {
        // key:num,value:times
        Map<Integer, Integer> map = new HashMap<>();
        for (int num : arr) {
            if (map.containsKey(num)) {
                map.put(num, map.get(num) + 1);
            } else {
                map.put(num, 1);
            }
        }
        for (Integer num : map.keySet()) {
            if (map.get(num) == K) {
                return num;
            }
        }
        throw new RuntimeException("找不到此数");
    }

    // for test
    private static int[] generateRandomArray(int maxKinds, int maxValue, int K, int M) {
        // 种类数：[0,maxKinds-2] + 2 == [2,maxKinds]
        int kinds = ((int) (Math.random() * (maxKinds - 1))) + 2;
        // 所以 数组总长度为 K + (kinds - 1) * M
        int length = K + (kinds - 1) * M;
        int[] result = new int[length];
        int index = 0;
        int kTimesNum = generateRandomValue(maxValue);
        // 填充出现K次的数
        for (; index < K; index++) {
            result[index] = kTimesNum;
        }
        kinds--;
        Set<Integer> set = new HashSet<>();
        set.add(kTimesNum);
        // 填加其他种类的数
        while (kinds != 0) {
            int curNum;
            do {
                curNum = generateRandomValue(maxValue);
            } while (set.contains(curNum));
            for (int i = 0; i < M; i++) {
                result[index++] = curNum;
            }
            set.add(curNum);
            kinds--;
        }
        // 将数组打乱
        for (int i = 0; i < length; i++) {
            // [0,length-1]
            int j = ((int) (Math.random() * (length)));
            int temp = result[i];
            result[i] = result[j];
            result[j] = temp;
        }
        return result;
    }

    // for test
    private static int generateRandomValue(int maxValue) {
        return ((int) (Math.random() * (maxValue + 1))) - ((int) (Math.random() * (maxValue + 1)));
    }

    // for test
    public static void main(String[] args) {
        int testTimes = 100000;
        int maxKinds = 5;
        int maxValue = 100;
        int KMMax = 9;
        for (int i = 0; i < testTimes; i++) {
            // [0,KMMax-1] + 1 == [1,KMMax]
            int a = (int) (Math.random() * KMMax) + 1;
            // [1,KMMax]
            int b = (int) (Math.random() * KMMax) + 1;
            int K = Math.min(a, b);
            int M = Math.max(a, b);
            if (K == M) {
                M = K + 1;
            }

            int[] arr = generateRandomArray(maxKinds, maxValue, K, M);
            if (getKTimesNum(arr, K, M) != getKTimesNumByHashMap(arr, K, M)) {
                System.out.println("arr=" + Arrays.toString(arr) + ",K=" + K + ",M=" + M);
            }
        }
    }
}

```



### 数据结构-链表



```java
/**
 * 单向链表
 */
public class Node<T> {

    // 数据域
    T val;

    // 指针域
    Node<T> next;
}

/**
 * 双向链表
 */
class DoubleNode<T> {

    // 数据域
    T val;

    // 指针域
    Node<T> pre;

    Node<T> next;
}
```



### 链表反转



```java
package com.aitx.study.base;

import java.util.ArrayList;
import java.util.List;

/**
 * 给定一个单链表的头head，完成链表的逆序调整
 * 给定一个双链表的头head，完成链表的逆序调整
 * <p>
 * 思考：
 * 一、容器法
 * 二、指针法
 *
 * 任何链表问题都可以有两种解法：1指针法；2容器法
 */

public class LinkedListReverse {


    private static class Node {
        int value;

        Node next;

        public Node(int value) {
            this.value = value;
        }
    }

    private static class DoubleNode {

        int value;

        DoubleNode pre;

        DoubleNode next;

        public DoubleNode(int value) {
            this.value = value;
        }

    }


    /**
     * 翻转单链表
     * a->b->c->null
     * null<-a<-b<-c
     */
    private static Node reverseSingleNode(Node head) {
        Node pre = null;
        Node next = null;
        while (head != null) {
            next = head.next;
            head.next = pre;
            pre = head;
            head = next;
        }
        // 跳出while循环后，head == null,pre == 最后一个节点
        // 此时pre就是第一个节点（也兼容head==null的场景）
        return pre;
    }

    /**
     * 翻转双向链表
     */
    private static DoubleNode reverseDoubleNode(DoubleNode head) {
        DoubleNode pre = null;
        DoubleNode next = null;
        while (head != null) {
            next = head.next;
            // 注意双向链表反转时next,pre都要调转方向
            head.next = pre;
            head.pre = next;
            pre = head;
            head = next;
        }
        // 跳出循环时，head == null，pre == 最后一个节点
        return pre;
    }

    /**
     * 通过容器的方式翻转单链表
     */
    private static Node reverseSingleNodeByContainer(Node head) {
        if (head == null) {
            return null;
        }
        // 走到这，代表肯定有1个及以上的节点
        List<Node> list = new ArrayList<>();
        while (head != null) {
            list.add(head);
            head = head.next;
        }
        int N = list.size();
        // 将
        list.get(0).next = null;
        for (int i = 1; i < N; i++) {
            list.get(i).next = list.get(i - 1);
        }
        return list.get(N - 1);
    }

    /**
     * 通过容器的方式翻转双向链表
     */
    private static DoubleNode reverseDoubleNodeByContainer(DoubleNode head) {
        // 任何时候都要用边界条件，没写边界，代表是输入不可能是边界条件或后面代码兼容边界条件
        if (head == null) {
            return null;
        }
        // 走到这，代表只有1个节点
        List<DoubleNode> list = new ArrayList<>();
        while (head != null) {
            list.add(head);
            head = head.next;
        }
        DoubleNode firstNode = list.get(0);
        firstNode.next = null;
        int N = list.size();
        for (int i = 1; i < N; i++) {
            DoubleNode doubleNode = list.get(i);
            doubleNode.next = list.get(i - 1);
            // 这里不能直接取i+1索引处的值，所以我们要用前一个节点的
            doubleNode.pre = null;
            list.get(i - 1).pre = doubleNode;
        }
        return list.get(N - 1);
    }

    // for test 生成随机单链表
    private static Node generateRandomSingleLinkedList(int maxLength, int maxValue) {
        int length = (int) (Math.random() * (maxLength + 1));
        if (length == 0) {
            return null;
        }
        // 先生成头
        length--;
        Node head = new Node(generateRandomValue(maxValue));
        Node cur = head;
        for (int i = 0; i < length; i++) {
            Node node = new Node(generateRandomValue(maxValue));
            cur.next = node;
            cur = node;
        }
        return head;
    }

    // for test 生成随机值
    private static int generateRandomValue(int maxValue) {
        return ((int) (Math.random() * (maxValue + 1))) - ((int) (Math.random() * (maxValue + 1)));
    }

    // fot test 生成随机双向链表
    private static DoubleNode generateRandomDoubleLinkedList(int maxLength, int maxValue) {
        int length = (int) (Math.random() * (maxLength + 1));
        if (length == 0) {
            return null;
        }
        // 先生成头
        length--;
        DoubleNode head = new DoubleNode(generateRandomValue(maxValue));
        DoubleNode cur = head;
        for (int i = 0; i < length; i++) {
            DoubleNode doubleNode = new DoubleNode(generateRandomValue(maxValue));
            cur.next = doubleNode;
            doubleNode.pre = cur;
            cur = doubleNode;
        }

        return head;

    }

    // fot test 获取原单向链表值 列表
    private static List<Integer> getOriginSingleLinkedValueList(Node head) {
        List<Integer> result = new ArrayList<>();
        while (head != null) {
            result.add(head.value);
            head = head.next;
        }
        return result;
    }

    // for test 获取原双向链表值 列表
    private static List<Integer> getOriginDoubleLinkedValueList(DoubleNode head) {
        List<Integer> result = new ArrayList<>();
        while (head != null) {
            result.add(head.value);
            head = head.next;
        }
        return result;
    }

    // for test 检测单向链表是否已反转
    private static boolean checkSingleLinkedListIsReverse(List<Integer> originValueList, Node reverseHead) {
        int N = originValueList.size();
        for (int i = N - 1; i >= 0; i--) {
            if (!originValueList.get(i).equals(reverseHead.value)) {
                return false;
            }
            reverseHead = reverseHead.next;
        }
        if (reverseHead != null) {
            return false;
        }
        return true;
    }

    // for test 检测双向链表是否已反转
    private static boolean checkDoubleLinkedListIsReverse(List<Integer> originValueList, DoubleNode reverseHead) {
        int N = originValueList.size();
        DoubleNode end = null;
        for (int i = N - 1; i >= 0; i--) {
            if (!originValueList.get(i).equals(reverseHead.value)) {
                return false;
            }
            end = reverseHead;
            reverseHead = reverseHead.next;
        }
        // 循环结束时，正常情况下end就是最后一个节点
        // 想一下有没有可能双向链表中的一截刚好覆盖上面的list，那第此时end就是覆盖一截的最后一个节点
        if (reverseHead != null) {
            return false;
        }
        // 走这到，代表列表长度与链表长度一致
        for (int i = 0; i < N; i++) {
            if (!originValueList.get(i).equals(end.value)) {
                return false;
            }
            end = end.pre;
        }
        return true;
    }

    public static void main(String[] args) {
        int testTimes = 100000;
        int maxLength = 10;
        int maxValue = 100;
        for (int i = 0; i < testTimes; i++) {
            // 校验指针法反转单链表是否正确
            Node node1 = generateRandomSingleLinkedList(maxLength, maxValue);
            if (!checkSingleLinkedListIsReverse(getOriginSingleLinkedValueList(node1), reverseSingleNode(node1))) {
                System.out.println("checkSingleLinkedListIsReverse-pointer fail");
                break;
            }
            // 校验容器法反转单链表是否正确
            Node node2 = generateRandomSingleLinkedList(maxLength, maxValue);
            if (!checkSingleLinkedListIsReverse(getOriginSingleLinkedValueList(node2), reverseSingleNodeByContainer(node2))) {
                System.out.println("checkSingleLinkedListIsReverse-container fail");
            }
            // 校验指针法反转双向链表是否正确
            DoubleNode doubleNode1 = generateRandomDoubleLinkedList(maxLength, maxValue);
            if (!checkDoubleLinkedListIsReverse(getOriginDoubleLinkedValueList(doubleNode1), reverseDoubleNode(doubleNode1))) {
                System.out.println("checkDoubleLinkedListIsReverse-pointer fail");
                break;
            }
            DoubleNode doubleNode2 = generateRandomDoubleLinkedList(maxLength, maxValue);
            if (!checkDoubleLinkedListIsReverse(getOriginDoubleLinkedValueList(doubleNode2), doubleNode2)) {
                System.out.println("checkDoubleLinkedListIsReverse-container fail");
                break;
            }
        }

    }
}

```



### 单链表实现队列与栈



```java
package com.aitx.study.base.code004;

/**
 * 用单链表结构实现队列结构
 * 用单链表结构实现栈结构
 * <p>
 * 思考：
 * 队列与栈都是抽象结构
 * 队列：队尾新增，队首出，先进先出
 * 栈：相当于瓶子，先进后出
 * <p>
 * 如果使用链表构建队列，队首、队尾 要有2个指针，再加1个size属性
 * 如果使用链表构建栈，需要1个指针，再加1个size属性
 */
public class Code004_LinkedList2QueueAndStack {

    private static class Node<T> {

        T value;

        Node<T> next;

        public Node(T value) {
            this.value = value;
        }

    }


    // 单链表实现队列
    public static class Queue<T> {


        int size;

        Node<T> head;

        Node<T> tail;

        public int size() {
            return size;
        }

        public boolean isEmpty() {
            return size == 0;
        }

        // offer
        public void offer(T value) {
            Node<T> node = new Node<>(value);
            if (tail == null) {
                head = node;
                tail = node;
            } else {
                // 要考虑新进来的节点与原来的节点的链接关系
                // 原 -》 新
                // 新 -》 原 ,这样不可取
                tail.next = node;
                tail = node;
            }
            size++;
        }

        // poll
        public T poll() {
            T result = null;
            if (head != null) {
                result = head.value;
                head = head.next;
                size--;
            }
            if (head == null) {
                tail = null;
            }
            return result;
        }


        public T peek() {
            T result = null;
            if (head != null) {
                result = head.value;
            }
            return result;
        }

    }


    // 单链表实现栈
    public static class Stack<T> {

        int size;

        Node<T> head;

        public int size() {
            return size;
        }

        public boolean isEmpty() {
            return size == 0;
        }

        // push
        public void push(T value) {
            Node<T> node = new Node<>(value);
            if (head == null) {
                head = node;
            } else {
                // 新 -》原 ，可取
                // 原 -》 新，不可取
                node.next = head;
                head = node;
            }
            size++;
        }

        // pop
        public T pop() {
            T result = null;
            if (head != null) {
                result = head.value;
                head = head.next;
            }
            return result;
        }

        // peek
        public T peek() {
            T result = null;
            if (head != null) {
                result = head.value;
            }
            return result;
        }

    }


}

```



### 用双链表结构实现双端队列



```java
package com.aitx.study.base.code004;

/**
 * 用双链表结构实现双端队列
 * <p>
 * 思考：
 * 双端队列 Deque，Java中LinkedList就是双端队列
 * 从头可以加，从头可以减
 * 从尾可以加，从尾可以减
 * <p>
 * 用的节点的双向链表的节点
 * <p>
 * 要实现双端队列，要有头尾2个指针，size
 */
public class Code004_DoubleLinkedList2Deque {

    private static class DoubleNode<T> {

        T value;

        DoubleNode<T> pre;

        DoubleNode<T> next;

        public DoubleNode(T value) {
            this.value = value;
        }

    }

    // 用双向链表实现双端队列
    public static class Deque<T> {

        int size;

        DoubleNode<T> head;

        DoubleNode<T> tail;

        public int size() {
            return this.size;
        }

        public boolean isEmpty() {
            return size == 0;
        }

        public void offerHead(T value) {
            DoubleNode<T> doubleNode = new DoubleNode<>(value);
            if (head == null) {
                head = doubleNode;
                tail = doubleNode;
            } else {
                // 要考虑新节点与原节点的链接关系
                // 新 -》 原
                // 原 -》 新 ，2个都可以，但还是采用 更自然的 新 -》 原
                doubleNode.next = head;
                head.pre = doubleNode;
                head = doubleNode;
            }
            size++;
        }

        public void offerTail(T value) {
            DoubleNode<T> doubleNode = new DoubleNode<>(value);
            if (tail == null) {
                head = doubleNode;
                tail = doubleNode;
            } else {
                // 采用更自然的 原 -》 新
                tail.next = doubleNode;
                doubleNode.pre = tail;
                tail = doubleNode;
            }
            size++;
        }

        public T pollHead() {
            T result = null;
            if (head != null) {
                result = head.value;
                head = head.next;
                size--;
            }

            if (head == null) {
                tail = null;
            } else {
                head.pre = null;
            }
            return result;
        }

        public T pollTail() {
            T result = null;
            if (tail != null) {
                result = tail.value;
                tail = tail.pre;
                size--;
            }
            if (tail == null) {
                head = null;
            } else {
                tail.next = null;
            }
            return result;
        }

        public T peekHead() {
            T result = null;
            if (head != null) {
                result = head.value;
            }
            return result;
        }

        public T peekTail() {
            T result = null;
            if (tail != null) {
                result = tail.value;
            }
            return result;
        }

    }
}

```





### 根据给定值删除链表节点



```java
package com.aitx.study.base;

import java.util.ArrayList;
import java.util.List;

/**
 * 通过给定值删除链表节点
 */
public class DeleteLinkedListNodeByGiveValue {


    private static class Node {

        int value;

        Node next;

        public Node(int value) {
            this.value = value;
        }
    }

    // 解法一：指针法
    private static Node deleteByGivenValue(Node head, int val) {
        // 边界
        if (head == null) {
            return null;
        }

        // 有可能头结点就是val值，所以要找到第一个不是val的节点
        while (head != null) {
            if (head.value != val) {
                break;
            }
            head = head.next;
        }
        // 退出while循环时，要么head == null 或者 head.value != val
        if (head == null) {
            return null;
        }
        Node cur = head;
        Node pre = head;
        while (cur != null) {
            if (cur.value == val) {
                pre.next = cur.next;
                cur = cur.next;
            } else {
                pre = cur;
                cur = cur.next;
            }
        }
        return head;
    }

    // 解法二：指针加强法：dummy Node
    private static Node deleteByGivenValue2(Node head, int val) {
        if (head == null) {
            return null;
        }
        Node dummyNode = new Node(Integer.MIN_VALUE);
        dummyNode.next = head;

        Node pre = dummyNode;
        Node cur = head;
        while (cur != null) {
            if (cur.value == val) {
                pre.next = cur.next;
                cur = cur.next;
            } else {
                pre = cur;
                cur = cur.next;
            }
        }
        // 退出while循环后，cur == null
        return dummyNode.next;
    }

    // 解法三：容器法
    private static Node deleteByGivenValueContainer(Node head, int val) {
        if (head == null) {
            return null;
        }
        List<Node> result = new ArrayList<>();
        while (head != null) {
            result.add(head);
            head = head.next;
        }
        // 满足条件时移除节点
        result.removeIf(node -> node.value == val);
        if (result.size() == 0) {
            return null;
        }
        // 显然这时候要重建链表
        Node firstNode = result.get(0);
        firstNode.next = null;
        int N = result.size();
        Node pre = firstNode;
        for (int i = 1; i < N; i++) {
            Node node = result.get(i);
            pre.next = node;
            node.next = null;
            pre = node;
        }

        return firstNode;

    }

    // for test 生成随机值
    private static int generateRandomValue(int maxValue) {
        return ((int) (Math.random() * (maxValue + 1))) - ((int) (Math.random() * (maxValue + 1)));
    }

    // for test 生成随机链表
    private static Node generateRandomLinkedList(int maxLength, int maxValue) {
        int length = (int) (Math.random() * (maxLength + 1));
        if (length == 0) {
            return null;
        }
        // 生成头节点
        length--;
        Node head = new Node(generateRandomValue(maxValue));
        Node cur = head;
        for (int i = 0; i < length; i++) {
            Node node = new Node(generateRandomValue(maxValue));
            cur.next = node;
            cur = node;
        }

        return head;
    }

    // for test 获取链表值 列表
    private static List<Integer> getLinkedListValueList(Node head) {
        if (head == null) {
            return new ArrayList<>();
        }
        List<Integer> result = new ArrayList<>();
        while (head != null) {
            result.add(head.value);
            head = head.next;
        }
        // 退出while循环时，head == null
        return result;
    }

    // for test 复制链表(值顺序一样)
    private static Node copyLinkedList(Node head) {
        if (head == null) {
            return null;
        }
        // 先构造头
        Node copyHead = new Node(head.value);
        Node curCopy = copyHead;
        Node cur = head.next;
        while (cur != null) {
            Node node = new Node(cur.value);
            curCopy.next = node;
            cur = cur.next;
            curCopy = node;
        }
        return copyHead;
    }

    public static void main(String[] args) {
        int testTimes = 100000;
        int maxLength = 10;
        int maxValue = 100;
        for (int i = 0; i < testTimes; i++) {
            Node head = generateRandomLinkedList(maxLength, maxValue);
            Node copyHead = copyLinkedList(head);
            if (!getLinkedListValueList(head).equals(getLinkedListValueList(copyHead))) {
                System.out.println("error");
                break;
            }
        }
    }


}

```



### 并查集



#### 并查集的HashMap实现（了解）



```java
package com.aitx.study.base.code005;


import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Stack;

/**
 * 并查集 UnionFind
 * <p>
 * 思考：
 * 想像有一堆元素，初始化时每个元素的父就是本身 并且 归属于一个集合，这个集合的大小为1，只有对应的元素
 * <p>
 * 1） 现在将2个集合合并，较小的集合的代表节点 指向 较大集合的代表节点
 * 2） 判断两个元素是否就是同一个集合，就看所归属集合的代表节点是否是同一个
 * 3） 查找某个元素的代表节点 的过程中 要将路径上所有的节点 扁平化 指向 代表节点
 * <p>
 * 那么并查集这样的结构，就要有2个HashMap：
 * 1. FatherHashMap 存储每个节点的直接父亲节点
 * 2. SizeHashMap 只存储代表节点所在集合的size
 * <p>
 * 记住以下结论：
 * 并查集的时间复杂度为big O(1)，证明过程复杂
 */
public class Code005_UnionFind {


    public static class UnionFind<T> {

        Map<T, T> fatherMap;

        Map<T, Integer> sizeMap;


        // 构造器，初始化
        public UnionFind(List<T> valueList) {

            fatherMap = new HashMap<>();
            sizeMap = new HashMap<>();

            for (T value : valueList) {
                fatherMap.put(value, value);
                sizeMap.put(value, 1);
            }
        }

        // 找代表节点
        public T findAncestor(T value) {
            Stack<T> path = new Stack<>();
            while (value != fatherMap.get(value)) {
                path.push(value);
                value = fatherMap.get(value);
            }
            // 退出循环时，value == fatherMap.get(value)，此时value 就是集合的代表节点

            // 将路径上的节点扁平化指向代表节点value
            if (!path.isEmpty()) {
                fatherMap.put(path.pop(), value);
            }
            return value;
        }

        // 两个节点是否为同一集合
        public boolean isSameSet(T valueA, T valueB) {
            return findAncestor(valueA) == findAncestor(valueB);
        }

        // 两个节点归属的集合 合并
        public void union(T valueA, T valueB) {
            T ancestorA = findAncestor(valueA);
            T ancestorB = findAncestor(valueB);
            if (ancestorA != ancestorB) {
                Integer sizeA = sizeMap.get(ancestorA);
                Integer sizeB = sizeMap.get(ancestorB);

                if (sizeA > sizeB) {
                    // valueA的集合大
                    fatherMap.put(ancestorB, ancestorA);
                    sizeMap.put(ancestorA, sizeA + sizeB);
                    sizeMap.remove(ancestorB);
                } else {
                    // valueB的集合大
                    fatherMap.put(ancestorA, ancestorB);
                    sizeMap.put(ancestorB, sizeA + sizeB);
                    sizeMap.remove(ancestorA);
                }
            }

        }

        // 求有几个集合，就是看代表节点有几个，就是sizeMap的size
        public int setNum() {
            return sizeMap.size();
        }

    }


}

```



#### 并查集的数组实现（重要）



```java
package com.aitx.study.base.code005;

/**
 * 并查集数组实现
 * <p>
 * 思考：
 * 并查集要有father数组、size数组，再加个辅助数组help用于find时记录路径值
 */
public class Code005_UnionFindArrayImp {

    public static class UnionFind {

        int[] father;

        int[] size;

        // help数组是find时扁平化用的
        int[] help;

        // 构造器初始化，入参代表共有[0,n]索引值的数
        public UnionFind(int n) {
            father = new int[n + 1];
            size = new int[n + 1];
            help = new int[n + 1];

            for (int i = 0; i <= n; i++) {
                father[i] = i;
                size[i] = 1;
            }
        }

        // 查x索引的祖先索引
        public int find(int v) {
            int hi = 0;
            while (v != father[v]) {
                help[hi++] = v;
                v = father[v];
            }
            // 退出循环时x == father[x] ，x 就是代表节点

            // 路径上的索引的父索引就是 x
            for (hi--; hi >= 0; hi--) {
                father[help[hi]] = v;
            }

            return v;
        }

        public void union(int x, int y) {
            int xAncestor = find(x);
            int yAncestor = find(y);
            if (xAncestor != yAncestor) {

                int xSize = size[xAncestor];
                int ySize = size[yAncestor];

                if (xSize > ySize) {
                    father[yAncestor] = xAncestor;
                    size[yAncestor] = xSize + ySize;
                    // 小集合的代表节点size抹不抹看具体问题而定
                } else {
                    father[xAncestor] = yAncestor;
                    size[yAncestor] = xSize + ySize;
                }

            }
        }

        public boolean isSameSet(int x, int y) {
            return find(x) == find(y);
        }
    }


}

```



#### 省份数量



```java
package com.aitx.study.base.code005;

/**
 * 有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。
 * 省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。
 * <p>
 * 给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，
 * 而 isConnected[i][j] = 0 表示二者不直接相连。
 * <p>
 * 返回矩阵中 省份 的数量。
 * <p>
 * 链接：https://leetcode.cn/problems/bLyHh0/
 * <p>
 * 思考：
 * 间接相连也是同一个集合，这里显然是并查集的知识点
 */
public class Code005_FriendCircle {


    public int findCircleNum(int[][] isConnected) {
        if (isConnected == null || isConnected.length == 0) {
            return 0;
        }
        int N = isConnected.length;

        UnionFind unionFind = new UnionFind(N);

        // 只需看右上角的部分
        for (int i = 0; i < N; i++) {
            for (int j = i + 1; j < N; j++) {
                if (isConnected[i][j] == 1) {
                    unionFind.union(i, j);
                }
            }
        }
        return unionFind.sets();
    }


    // 最重要的要构建出 数组实现的并查集
    public static class UnionFind {

        // 节点的父节点
        int[] parent;


        // 集合的大小
        int[] size;

        // 辅助数组
        int[] help;

        // 集合的数量
        int sets;

        public UnionFind(int N) {
            parent = new int[N];
            size = new int[N];
            help = new int[N];
            sets = N;

            for (int i = 0; i < N; i++) {
                parent[i] = i;
                size[i] = 1;
            }
        }

        public int find(int index) {
            int hi = 0;
            while (index != parent[index]) {
                help[hi++] = index;
                index = parent[index];
            }
            // 退出循环时，index == parent[index]

            // 扁平化
            for (hi--; hi >= 0; hi--) {
                parent[help[hi]] = index;
            }

            return index;
        }

        public void union(int indexA, int indexB) {
            int parentA = find(indexA);
            int parentB = find(indexB);
            if (parentA != parentB) {
                int sizeA = size[parentA];
                int sizeB = size[parentB];
                if (sizeA > sizeB) {
                    parent[parentB] = parentA;
                    size[parentA] = sizeA + sizeB;
                } else {
                    parent[parentA] = parentB;
                    size[parentB] = sizeA + sizeB;
                }
                sets--;
            }
        }

        public int sets() {
            return sets;
        }

    }

}

```



#### 岛屿数量



```java
package com.aitx.study.base.code005;

import java.util.*;

/**
 * 岛屿数量
 * 给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。
 * 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
 * 此外，你可以假设该网格的四条边均被水包围。
 * <p>
 * 链接：https://leetcode.cn/problems/number-of-islands/description/
 * <p>
 * 思考：
 * 一、通过递归，感染的方法
 * 二、并查集
 */
public class Code005_IslandNumber {


    // 一、递归法
    public int numIslands(char[][] grid) {
        if (grid == null || grid.length == 0 || grid[0].length == 0) {
            return 0;
        }
        int result = 0;
        int rowNum = grid.length;
        int columnNum = grid[0].length;

        for (int i = 0; i < rowNum; i++) {
            for (int j = 0; j < columnNum; j++) {
                if ('1' == grid[i][j]) {
                    result++;
                    infect(grid, i, j);
                }
            }
        }
        return result;
    }

    private void infect(char[][] grid, int i, int j) {
        int rowNum = grid.length;
        int columnNum = grid[0].length;
        if (i < 0 || i >= rowNum) {
            return;
        }
        if (j < 0 || j >= columnNum) {
            return;
        }
        if ('1' != grid[i][j]) {
            return;
        }
        grid[i][j] = '2';
        infect(grid, i, j - 1); // 左
        infect(grid, i - 1, j); // 上
        infect(grid, i, j + 1); // 右
        infect(grid, i + 1, j); // 下
    }

    // ---------------------------------------

    // 二、并查集 HashMap实现
    public int numIslands2(char[][] grid) {
        if (grid == null || grid.length == 0 || grid[0].length == 0) {
            return 0;
        }
        int rowNum = grid.length;
        int columnNum = grid[0].length;

        Dot[][] dots = new Dot[rowNum][columnNum];


        // char[][] -> Dot[][] ，char数组转Dot数组，'1'就是非null，'0'就是null
        List<Dot> list = new ArrayList<>();
        for (int i = 0; i < rowNum; i++) {
            for (int j = 0; j < columnNum; j++) {
                if ('1' == grid[i][j]) {
                    dots[i][j] = new Dot();
                    list.add(dots[i][j]);
                }
            }
        }

        UnionFind<Dot> unionFind = new UnionFind<>(list);

        // 第0行
        for (int j = 1; j < columnNum; j++) {
            if (grid[0][j - 1] == '1' && grid[0][j] == '1') {
                unionFind.union(dots[0][j - 1], dots[0][j]);
            }
        }

        // 第0列
        for (int i = 1; i < rowNum; i++) {
            if (grid[i - 1][0] == '1' && grid[i][0] == '1') {
                unionFind.union(dots[i - 1][0], dots[i][0]);
            }
        }

        for (int i = 1; i < rowNum; i++) {
            for (int j = 1; j < columnNum; j++) {
                if (grid[i][j] == '1') {
                    if (grid[i][j - 1] == '1') {
                        unionFind.union(dots[i][j - 1], dots[i][j]);
                    }
                    if (grid[i - 1][j] == '1') {
                        unionFind.union(dots[i - 1][j], dots[i][j]);
                    }
                }
            }
        }

        return unionFind.sets();
    }

    private static class UnionFind<T> {

        Map<T, T> parentMap;

        Map<T, Integer> sizeMap;


        public UnionFind(List<T> values) {
            parentMap = new HashMap<>();
            sizeMap = new HashMap<>();
            for (T value : values) {
                parentMap.put(value, value);
                sizeMap.put(value, 1);
            }
        }

        public T find(T value) {
            Stack<T> path = new Stack<>();
            while (value != parentMap.get(value)) {
                path.push(value);
                value = parentMap.get(value);
            }

            // 退出循环时，value == parentMap.get(value)
            while (!path.isEmpty()) {
                parentMap.put(path.pop(), value);
            }

            return value;
        }


        public void union(T valueA, T valueB) {
            T ancestorA = find(valueA);
            T ancestorB = find(valueB);
            if (ancestorA != ancestorB) {
                Integer sizeA = sizeMap.get(ancestorA);
                Integer sizeB = sizeMap.get(ancestorB);
                if (sizeA > sizeB) {
                    parentMap.put(ancestorB, ancestorA);
                    sizeMap.put(ancestorA, sizeA + sizeB);
                    sizeMap.remove(ancestorB);
                } else {
                    parentMap.put(ancestorA, ancestorB);
                    sizeMap.put(ancestorB, sizeA + sizeB);
                    sizeMap.remove(ancestorA);
                }
            }
        }

        public int sets() {
            return sizeMap.size();
        }

    }

    private static class Dot {

    }

    // ----------------------------------------------------

    // 三、并查集 数组实现

    public int numIslands3(char[][] grid) {

        if (grid == null || grid.length == 0 || grid[0].length == 0) {
            return 0;
        }
        int rowNum = grid.length;
        int columnNum = grid[0].length;


        UnionFind3 unionFind = new UnionFind3(grid);

        // 第0行
        for (int j = 1; j < columnNum; j++) {
            if (grid[0][j - 1] == '1' && grid[0][j] == '1') {
                unionFind.union(0, j - 1, 0, j);
            }
        }

        // 第0列
        for (int i = 1; i < rowNum; i++) {
            if (grid[i - 1][0] == '1' && grid[i][0] == '1') {
                unionFind.union(i - 1, 0, i, 0);
            }
        }

        for (int i = 1; i < rowNum; i++) {
            for (int j = 1; j < columnNum; j++) {
                if (grid[i][j] == '1') {
                    if (grid[i][j - 1] == '1') {
                        unionFind.union(i, j, i, j - 1);
                    }
                    if (grid[i - 1][j] == '1') {
                        unionFind.union(i, j, i - 1, j);
                    }
                }
            }
        }

        return unionFind.sets();

    }

    private static class UnionFind3 {

        int[] parent;

        int[] size;

        int[] help;

        int sets;

        int rowNum;

        int columnNum;


        public UnionFind3(char[][] grid) {

            rowNum = grid.length;
            columnNum = grid[0].length;

            int length = rowNum * columnNum;

            parent = new int[length];
            size = new int[length];
            help = new int[length];

            sets = 0;

            for (int i = 0; i < rowNum; i++) {
                for (int j = 0; j < columnNum; j++) {
                    if (grid[i][j] == '1') {
                        int index = index(i, j);
                        parent[index] = index;
                        size[index] = 1;
                        sets++;
                    }
                }
            }

        }

        public int find(int rowIndex, int columnIndex) {

            int index = index(rowIndex, columnIndex);
            int hi = 0;

            while (index != parent[index]) {
                help[hi++] = index;
                index = parent[index];
            }

            // 退出循环时 index == parent[index]
            for (hi--; hi >= 0; hi--) {
                parent[help[hi]] = index;
            }

            return index;
        }

        public void union(int rowIndex1, int columnIndex1, int rowIndex2, int columnIndex2) {

            int ancestor1 = find(rowIndex1, columnIndex1);
            int ancestor2 = find(rowIndex2, columnIndex2);
            if (ancestor1 != ancestor2) {
                int index1 = index(rowIndex1, columnIndex1);
                int index2 = index(rowIndex2, columnIndex2);
                int size1 = size[index1];
                int size2 = size[index2];
                if (size1 > size2) {
                    parent[ancestor2] = ancestor1;
                    size[ancestor1] = size1 + size2;
                } else {
                    parent[ancestor1] = ancestor2;
                    size[ancestor2] = size1 + size2;
                }
                sets--;
            }
        }

        public int sets() {
            return sets;
        }

        private int index(int rowIndex, int columnIndex) {
            return rowIndex * columnNum + columnIndex;
        }


    }


}

```





#### 岛屿数量II



```java
package com.aitx.study.base.code005;

import java.util.*;

/**
 * 岛屿数量2
 * <p>
 * 给你一个大小为 m x n 的二进制网格 grid 。网格表示一个地图，其中，0 表示水，1 表示陆地。
 * 最初，grid 中的所有单元格都是水单元格（即，所有单元格都是 0）。
 * 可以通过执行 addLand 操作，将某个位置的水转换成陆地。给你一个数组 positions ，
 * 其中 positions[i] = [ri, ci] 是要执行第 i 次操作的位置 (ri, ci) 。
 * 返回一个整数数组 answer ，其中 answer[i] 是将单元格 (ri, ci) 转换为陆地后，地图中岛屿的数量。
 * 岛屿 的定义是被「水」包围的「陆地」，通过水平方向或者垂直方向上相邻的陆地连接而成。
 * 你可以假设地图网格的四边均被无边无际的「水」所包围。
 * <p>
 * 付费题：https://leetcode.com/problems/number-of-islands-ii/description/
 * <p>
 * 思考：
 * 岛屿数量还是用的并查集，但原来是直接给出数组，求数量
 * 现在是每次添加，必然并查集的部分初始化要放到一个方法里进行，这里就是connect()方法
 */
public class Code005_IslandNumber2 {


    public List<Integer> numIslands21(int m, int n, int[][] positions) {

        List<Integer> result = new ArrayList<>();


        UnionFind unionFind = new UnionFind();
        for (int[] position : positions) {
            result.add(unionFind.connect(position[0], position[1]));
        }

        return result;
    }

    private static class UnionFind {


        Map<String, String> parentMap;

        Map<String, Integer> sizeMap;

        Integer sets;


        private String index(int rowIndex, int columnIndex) {
            return String.valueOf(rowIndex) + "_" + String.valueOf(columnIndex);
        }


        public UnionFind() {
            parentMap = new HashMap<>();
            sizeMap = new HashMap<>();
            sets = 0;
        }


        public String find(String index) {

            Stack<String> path = new Stack<String>();

            while (index.equals(parentMap.get(index))) {

                path.push(index);

                index = parentMap.get(index);
            }

            // 退出循环时，index = parentMap.get(index)
            while (!path.isEmpty()) {
                parentMap.put(path.pop(), index);
            }

            return index;

        }

        public void union(String index1, String index2) {

            if ((!parentMap.containsKey(index1)) || (!parentMap.containsKey(index2))) {
                return;
            }


            String ancestor1 = find(index1);
            String ancestor2 = find(index2);

            if (!ancestor1.equals(ancestor2)) {
                Integer size1 = sizeMap.get(ancestor1);
                Integer size2 = sizeMap.get(ancestor2);
                if (size1 > size2) {
                    parentMap.put(ancestor2, ancestor1);
                    sizeMap.put(ancestor1, size1 + size2);
                    sizeMap.remove(ancestor2);
                } else {
                    parentMap.put(ancestor1, ancestor2);
                    sizeMap.put(ancestor2, size1 + size2);
                    sizeMap.remove(ancestor1);
                }
                sets--;
            }

        }


        public int sets() {
            return sets;
        }


        public int connect(int rowIndex, int columnIndex) {


            String index = index(rowIndex, columnIndex);
            if (!parentMap.containsKey(index)) {
                parentMap.put(index, index);
                sizeMap.put(index, 1);
                sets++;

                // 上下左右 合并
                union(index(rowIndex - 1, columnIndex), index);
                union(index(rowIndex + 1, columnIndex), index);
                union(index(rowIndex, columnIndex - 1), index);
                union(index(rowIndex, columnIndex + 1), index);
            }


            return sets();
        }

    }


    // -----------------------------------------------------------------------

    public List<Integer> numIslands22(int m, int n, int[][] positions) {

        List<Integer> result = new ArrayList<>();


        UnionFindArrayImp unionFindArrayImp = new UnionFindArrayImp(m, n);
        for (int[] position : positions) {
            result.add(unionFindArrayImp.connect(position[0], position[1]));
        }

        return result;
    }

    private static class UnionFindArrayImp {

        int[] parent;

        int[] size;

        int[] help;

        int sets;

        int rowNum;

        int columnNum;

        public UnionFindArrayImp(int rowNum, int columnNum) {

            this.rowNum = rowNum;
            this.columnNum = columnNum;
            int length = this.rowNum * this.columnNum;

            parent = new int[length];
            size = new int[length];
            help = new int[length];
            sets = 0;
        }

        private int index(int rowIndex, int columnIndex) {
            return rowIndex * columnNum + columnIndex;
        }

        public int find(int index) {

            int hi = 0;
            while (index != parent[index]) {
                help[hi++] = index;
                index = parent[index];
            }

            for (hi--; hi >= 0; hi--) {
                parent[help[hi]] = index;
            }

            return index;

        }

        public void union(int indexA, int indexB) {

            if (size[indexA] == 0 || size[indexB] == 0) {
                return;
            }

            int ancestorA = find(indexA);
            int ancestorB = find(indexB);

            if (ancestorA != ancestorB) {
                int sizeA = size[ancestorA];
                int sizeB = size[ancestorB];
                if (sizeA > sizeB) {
                    parent[ancestorB] = ancestorA;
                    size[ancestorA] = sizeA + sizeB;
                } else {
                    parent[ancestorA] = ancestorB;
                    size[ancestorB] = sizeA + sizeB;
                }

                sets--;
            }
        }

        public int sets() {
            return sets;
        }


        public int connect(int rowIndex, int columnIndex) {
            int index = index(rowIndex, columnIndex);

            if (size[index] == 0) {
                parent[index] = index;
                size[index] = 1;
                sets++;

                // 上下左右
                int up = rowIndex - 1;
                int down = rowIndex + 1;
                int left = columnIndex - 1;
                int right = columnIndex + 1;
                if (up >= 0) {
                    union(index(up, columnIndex), index);
                }
                if (down < rowNum) {
                    union(index(down, columnIndex), index);
                }
                if (left >= 0) {
                    union(index(rowIndex, left), index);
                }
                if (right < columnNum) {
                    union(index(rowIndex, right), index);
                }

            }


            return sets();

        }

    }


}

```



### 动态规划

> 暴力递归到动态规划
>
> 某一个暴力递归，有解的重复调用，就可以把这个暴力递归优化成动态规划；任何动态规划问题，都一定对应着某一个有重复过程的暴力递归。但不是所有的暴力递归，都一定对应着动态规划
>
> 
>
> 什么暴力递归可以继续优化？
>
> ​	有重复调用同一个子问题的解，这种递归可以优化；如果每一个子问题都是不同的解，无法优化也不用优化
>
> 
>
> 如何找到某个问题的动态规划方式？
>
> ​	1）设计暴力递归：重要原则+4种常见尝试模型！重点！
>
> ​	2）分析有没有重复解：套路解决
>
> ​	3）用记忆化搜索 -> 用严格表结构实现动态规划：套路解决
>
> ​	4）看看能否继续优化：套路解决
>
> 
>
> 面试中设计暴力递归过程的原则
>
> ​	1）每一个可变参数的类型，一定不要比int类型更加复杂
>
> ​	2）原则1）可以违反，让类型突破到一维线性结构，那必须是单一可变参数
>
> ​	3）如果发现原则1）被违反，但不违反原则2），只需要做到记忆化搜索即可
>
> ​	4）可变参数的个数，能少则少
>
> 
>
> 常见的4种尝试模型
>
> ​	1）从左往右的尝试模型
>
> ​	2）范围上的尝试模型
>
> ​	3）多样本位置全对应的尝试模型
>
> ​	4）寻找业务限制的尝试模型
>
> 
>
> 暴力递归到动态规划的套路
>
> ​	1）你已经有了一个不违反原则的暴力递归，而且的确存在解的重复调用
>
> ​	2）找到哪些参数的变化会影响返回值，对每一个列出变化范围
>
> ​	3）参数间的所有的组合数量，意味着表大小
>
> ​	4）记忆化搜索的方法就是傻缓存，非常容易得到
>
> ​	5）规定好严格表的大小，分析位置的依赖顺序，然后从基础填写到最终解
>
> ​	6）对于有枚举行为的决策过程，进一步优化
>
> 
>
> 动态规划的进一步优化
>
> ​	1）空间压缩
>
> ​	2）状态化简
>
> ​	3）四边形不等式
>
> ​	4）其他优化技巧



#### 机器人步行

```java
package com.aitx.study.base.code001;

/**
 * 假设有排成一行的N个位置，记为1~N，N 一定大于或等于 2
 * 开始时机器人在其中的M位置上(M 一定是 1~N 中的一个)
 * 如果机器人来到1位置，那么下一步只能往右来到2位置；
 * 如果机器人来到N位置，那么下一步只能往左来到 N-1 位置；
 * 如果机器人来到中间位置，那么下一步可以往左走或者往右走；
 * 规定机器人必须走 K 步，最终能来到P位置(P也是1~N中的一个)的方法有多少种
 * 给定四个参数 N、M、K、P，返回方法数。
 * <p>
 * 思考：考虑机器人当前在什么位置，要怎么走
 */
public class RobotWalk {


    /**
     * 方法一：暴力递归(尝试)
     * 机器人起始位置M，要走K步，目标P位置，格子有N个位置
     */
    public static int ways1(int N, int M, int P, int K) {

        if (N < 2 || M < 1 || M > N || P < 1 || P > N || K < 1) {
            return -1;
        }

        return process1(M, K, N, P);

    }

    /**
     * 机器人起始位置start，要走rest步，目标aim位置，格子有N个位置
     */
    private static int process1(int start, int rest, int N, int aim) {
        if (rest == 0) {
            return start == aim ? 1 : 0;
        }
        // 走到这，代表还有rest步要走
        if (start == 1) {
            return process1(2, rest - 1, N, aim);
        } else if (start == N) {
            return process1(N - 1, rest - 1, N, aim);
        } else {
            return process1(start - 1, rest - 1, N, aim) + process1(start + 1, rest - 1, N, aim);
        }
    }


    /**
     * 方法二：暴力递归过程中加入缓存（傻缓存）
     * 机器人起始位置M，要走K步，目标P位置，格子有N个位置
     */
    public static int ways2(int N, int M, int P, int K) {

        if (N < 2 || M < 1 || M > N || P < 1 || P > N || K < 1) {
            return -1;
        }

        // start [1,N]
        // rest [0,K]

        // 要求都从0索引开始，则表的大小为 (N + 1) * (K + 1)
        int[][] dp = new int[N + 1][K + 1];

        for (int i = 0; i <= N; i++) {
            for (int j = 0; j <= K; j++) {
                dp[i][j] = -1;
            }
        }


        return process2(M, K, N, P, dp);

    }


    /**
     * 机器人起始位置start，要走rest步，目标aim位置，格子有N个位置
     * <p>
     * 由于暴力递归有重复运算，所以可以加入傻缓存方法
     */
    private static int process2(int start, int rest, int N, int aim, int[][] dp) {
        if (dp[start][rest] != -1) {
            return dp[start][rest];
        }

        int ans;

        if (rest == 0) {
            ans = start == aim ? 1 : 0;
        } else {
            // 走到这，代表还有rest步要走
            if (start == 1) {
                ans = process1(2, rest - 1, N, aim);
            } else if (start == N) {
                ans = process1(N - 1, rest - 1, N, aim);
            } else {
                ans = process1(start - 1, rest - 1, N, aim) + process1(start + 1, rest - 1, N, aim);
            }
        }

        dp[start][rest] = ans;

        return ans;

    }


    /**
     * 方法三：暴力递归到动态规划（状态转移）
     * 机器人起始位置M，要走K步，目标P位置，格子有N个位置
     */
    public static int ways3(int N, int M, int P, int K) {

        if (N < 2 || M < 1 || M > N || P < 1 || P > N || K < 1) {
            return -1;
        }

        /**
         *         if (rest == 0) {
         *             return start == aim ? 1 : 0;
         *         }
         *         // 走到这，代表还有rest步要走
         *         if (start == 1) {
         *             return process1(2, rest - 1, N, aim);
         *         } else if (start == N) {
         *             return process1(N - 1, rest - 1, N, aim);
         *         } else {
         *             return process1(start - 1, rest - 1, N, aim) + process1(start + 1, rest - 1, N, aim);
         *         }
         */

        /**
         *         // start [1,N]
         *         // rest [0,K]
         */

        // 1。新建表
        int[][] dp = new int[N + 1][K + 1];

        // 初始化表
        dp[P][0] = 1;
        for (int rest = 1; rest <= K; rest++) {
            dp[1][rest] = dp[2][rest - 1];

            for (int start = 2; start < N; start++) {
                dp[start][rest] = dp[start - 1][rest - 1] + dp[start + 1][rest - 1];
            }

            dp[N][rest] = dp[N - 1][rest - 1];
        }

        // 机器人起始位置M，要走K步，目标P位置，格子有N个位置
        return dp[M][K];

    }


    public static void main(String[] args) {
        System.out.println(ways1(5, 2, 4, 6)); // 13
        System.out.println(ways2(5, 2, 4, 6)); // 13
        System.out.println(ways3(5, 2, 4, 6)); // 13
    }

}

```



#### 纸牌

```java
package com.aitx.study.base.code001;

/**
 * 给定一个整型数组arr，代表数值不同的纸牌排成一条线
 * 玩家A和玩家B依次拿走每张纸牌
 * 规定玩家A先拿，玩家B后拿
 * 但是每个玩家每次只能拿走最左或最右的纸牌
 * 玩家A和玩家B都绝顶聪明
 * 请返回最后获胜者的分数。
 * <p>
 * 思路：递归尝试
 */
public class ChooseCard {


    /**
     * 方法一：暴力递归
     */
    public static int chooseCard1(int[] arr) {

        // 边界条件
        if (arr == null || arr.length == 0) {
            return -1;
        }

        int N = arr.length;

        // 我在一个过程中可能先手，也会后手
        int f1 = f1(0, N - 1, arr);
        int g1 = g1(0, N - 1, arr);

        return Math.max(f1, g1);

    }

    private static int g1(int L, int R, int[] arr) {

        if (L == R) {
            return 0;
        }

        int p1 = f1(L + 1, R, arr);
        int p2 = f1(L, R - 1, arr);

        return Math.min(p1, p2);
    }

    private static int f1(int L, int R, int[] arr) {

        if (L == R) {
            return arr[L];
        }

        int p1 = arr[L] + g1(L + 1, R, arr);

        int p2 = arr[R] + g1(L, R - 1, arr);

        return Math.max(p1, p2);
    }


    // -----------------------------------------------------------

    /**
     * 方法二：暴力递归,傻缓存
     */
    public static int chooseCard2(int[] arr) {

        // 边界条件
        if (arr == null || arr.length == 0) {
            return -1;
        }

        int N = arr.length;


        // L 左边界，[0,N-1]
        // R 右边界，[0,N-1]
        int[][] fMap = new int[N][N];
        int[][] gMap = new int[N][N];

        // 初始化表
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                fMap[i][j] = -1;
                gMap[i][j] = -1;
            }
        }


        // 我在一个过程中可能先手，也会后手
        int f2 = f2(0, N - 1, arr, fMap, gMap);
        int g2 = g2(0, N - 1, arr, fMap, gMap);

        return Math.max(f2, g2);

    }

    private static int g2(int L, int R, int[] arr, int[][] fMap, int[][] gMap) {

        if (gMap[L][R] != -1) {
            return gMap[L][R];
        }


        int ans;
        if (L == R) {
            ans = 0;
            gMap[L][R] = ans;
            return ans;
        }

        int p1 = f1(L + 1, R, arr);
        int p2 = f1(L, R - 1, arr);

        ans = Math.min(p1, p2);

        gMap[L][R] = ans;

        return ans;
    }

    private static int f2(int L, int R, int[] arr, int[][] fMap, int[][] gMap) {

        if (fMap[L][R] != -1) {
            return fMap[L][R];
        }

        int ans;

        if (L == R) {
            ans = arr[L];
            fMap[L][R] = ans;
            return ans;
        }

        int p1 = arr[L] + g1(L + 1, R, arr);

        int p2 = arr[R] + g1(L, R - 1, arr);

        ans = Math.max(p1, p2);
        fMap[L][R] = ans;

        return ans;
    }


    /**
     * 方法三：暴力递归到动态规化（位置依赖）
     */
    public static int chooseCard3(int[] arr) {

        // 边界条件
        if (arr == null || arr.length == 0) {
            return -1;
        }

        int N = arr.length;


        // L 左边界，[0,N-1]
        // R 右边界，[0,N-1]
        int[][] fMap = new int[N][N];
        int[][] gMap = new int[N][N];

        // 初始化表
        /**
         *        if (L == R) {
         *             return arr[L];
         *         }
         *
         *         int p1 = arr[L] + g1(L + 1, R, arr); // 依赖下边
         *
         *         int p2 = arr[R] + g1(L, R - 1, arr);// 依赖左边
         *
         *         return Math.max(p1, p2);
         */
        for (int i = 0; i < N; i++) {
            fMap[i][i] = arr[i];
        }
        /**
         *         if (L == R) {
         *             return 0;
         *         }
         *
         *         int p1 = f1(L + 1, R, arr); // 依赖下边
         *         int p2 = f1(L, R - 1, arr);// 依赖左边
         *
         *         return Math.min(p1, p2);
         */

        for (int startCol = 1; startCol < N; startCol++) {
            int L = 0;
            int R = startCol;
            while (R < N) {
                fMap[L][R] = Math.max(arr[L] + gMap[L + 1][R], arr[R] + gMap[L][R - 1]);
                gMap[L][R] = Math.min(fMap[L + 1][R], fMap[L][R - 1]);
                L++;
                R++;
            }
        }


        // 我在一个过程中可能先手，也会后手
        int f3 = fMap[0][N - 1];
        int g3 = gMap[0][N - 1];

        return Math.max(f3, g3);
    }


}

```







